{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CPLUS QGIS plugin Introduction The challenge of mitigating climate change and achieving global and national climate targets requires innovative and holistic approaches. In this pursuit, the Climate Positive Land Use Strategy (CPLUS) decision support tool has emerged as a crucial resource. CPLUS is a spatially-explicit roadmap designed to guide land-use planning strategies, utilizing natural climate solutions to drive meaningful and sustainable change. The CPLUS decision support tool combines open-source technology, localized data sets, and modelled products to empower policymakers, land managers, and stakeholders in making informed decisions. By integrating spatial information, such as land cover, carbon stocks, and potential for carbon sequestration, CPLUS enables the identification of key areas for intervention and investment. By prioritizing these nature-based interventions, CPLUS seeks to harness the power of ecosystems and optimize their climate mitigation potential. One of the distinguishing features of CPLUS is its ability to address both global and national climate targets. While global climate targets provide a broad framework for action, national targets require context-specific strategies tailored to the unique characteristics of each country. The CPLUS decision support tool considers these diverse factors and assists in designing land-use planning strategies that align with national commitments while contributing to global climate goals. Furthermore, CPLUS recognizes that effective land-use planning involves collaboration and engagement among various stakeholders. It fosters dialogue and cooperation between governments, local communities, indigenous groups, conservation organizations, and private entities, facilitating the development of inclusive and equitable solutions. By involving diverse perspectives and expertise, CPLUS ensures that the decision-making process is participatory and informed by local knowledge. Piloted in the Bushbuckridge Municipality in the Kruger to Canyons Biosphere of South Africa, the CPLUS framework was tested with a diverse set of stakeholders to identify land use priorities and understand the carbon benefits and biodiversity, ecosystem services co-benefits of different scenarios. CPLUS model Implementation models Figure 1 shows a flow diagram of the CPLUS analysis model. Figure 1: Simplified analysis model Algorithms Shown in Figure 2 is the algorithms applied by the CPLUS model analysis model. Figure 2: CPLUS simplified analysis workflow with algorithms References https://www.pnas.org/doi/10.1073/pnas.1710465114 https://royalsocietypublishing.org/doi/10.1098/rstb.2019.0126 Site contents The aim of this is site is to provide details on the models and algorithms used by the CPLUS plugin, help a user on using the plugin, guide administrators on testings and providing feedback for the plugin, and provide guidance to developers who want to contribute to the plugin. Here is a quick introduction on the sections on the site: Users : Help for users of the plugin Quick Start : Installation guide and how to get started with the plugin Guide : Detailed workflow on how to use the plugin Manual : Descriptions of each UI element Administrators : Help for an administrator of the plugin Guide : Detailed guide for administrative requirements Repository : Downloadable versions of the plugin Developers : People who want to contribute towards improving the plugin Setup : How to set up the developers environment for the plugin Architecture : Documentation : Help on adding towards the API documentation for a developer API : Application programming interface for the plugin About : Information on CI and other contributors to the plugin","title":"Home"},{"location":"#cplus-qgis-plugin","text":"","title":"CPLUS QGIS plugin"},{"location":"#introduction","text":"The challenge of mitigating climate change and achieving global and national climate targets requires innovative and holistic approaches. In this pursuit, the Climate Positive Land Use Strategy (CPLUS) decision support tool has emerged as a crucial resource. CPLUS is a spatially-explicit roadmap designed to guide land-use planning strategies, utilizing natural climate solutions to drive meaningful and sustainable change. The CPLUS decision support tool combines open-source technology, localized data sets, and modelled products to empower policymakers, land managers, and stakeholders in making informed decisions. By integrating spatial information, such as land cover, carbon stocks, and potential for carbon sequestration, CPLUS enables the identification of key areas for intervention and investment. By prioritizing these nature-based interventions, CPLUS seeks to harness the power of ecosystems and optimize their climate mitigation potential. One of the distinguishing features of CPLUS is its ability to address both global and national climate targets. While global climate targets provide a broad framework for action, national targets require context-specific strategies tailored to the unique characteristics of each country. The CPLUS decision support tool considers these diverse factors and assists in designing land-use planning strategies that align with national commitments while contributing to global climate goals. Furthermore, CPLUS recognizes that effective land-use planning involves collaboration and engagement among various stakeholders. It fosters dialogue and cooperation between governments, local communities, indigenous groups, conservation organizations, and private entities, facilitating the development of inclusive and equitable solutions. By involving diverse perspectives and expertise, CPLUS ensures that the decision-making process is participatory and informed by local knowledge. Piloted in the Bushbuckridge Municipality in the Kruger to Canyons Biosphere of South Africa, the CPLUS framework was tested with a diverse set of stakeholders to identify land use priorities and understand the carbon benefits and biodiversity, ecosystem services co-benefits of different scenarios.","title":"Introduction"},{"location":"#cplus-model","text":"","title":"CPLUS model"},{"location":"#implementation-models","text":"Figure 1 shows a flow diagram of the CPLUS analysis model. Figure 1: Simplified analysis model","title":"Implementation models"},{"location":"#algorithms","text":"Shown in Figure 2 is the algorithms applied by the CPLUS model analysis model. Figure 2: CPLUS simplified analysis workflow with algorithms","title":"Algorithms"},{"location":"#references","text":"https://www.pnas.org/doi/10.1073/pnas.1710465114 https://royalsocietypublishing.org/doi/10.1098/rstb.2019.0126","title":"References"},{"location":"#site-contents","text":"The aim of this is site is to provide details on the models and algorithms used by the CPLUS plugin, help a user on using the plugin, guide administrators on testings and providing feedback for the plugin, and provide guidance to developers who want to contribute to the plugin. Here is a quick introduction on the sections on the site: Users : Help for users of the plugin Quick Start : Installation guide and how to get started with the plugin Guide : Detailed workflow on how to use the plugin Manual : Descriptions of each UI element Administrators : Help for an administrator of the plugin Guide : Detailed guide for administrative requirements Repository : Downloadable versions of the plugin Developers : People who want to contribute towards improving the plugin Setup : How to set up the developers environment for the plugin Architecture : Documentation : Help on adding towards the API documentation for a developer API : Application programming interface for the plugin About : Information on CI and other contributors to the plugin","title":"Site contents"},{"location":"about/ci/","text":"Conservation International Through the help of community leaders and policymakers, the mission of Conservation International (CI) is to combat climate change and preserve carbon stores. CI and the Climate Positive Land Use Strategy (CPLUS) project need the ability to spatially analyze a given area to determine the best land use in order to naturally combat climate change and the effects thereof on a global scale. Further, reports need to be generated to communicate to stakeholders the importance of conserving and maintaining certain areas and the need to restore lost climate-positive environments. Thus, mitigating the negative effects of climate change produced by our daily activities. The aim is to ensure a better future for everyone.","title":"Conservation International"},{"location":"about/ci/#conservation-international","text":"Through the help of community leaders and policymakers, the mission of Conservation International (CI) is to combat climate change and preserve carbon stores. CI and the Climate Positive Land Use Strategy (CPLUS) project need the ability to spatially analyze a given area to determine the best land use in order to naturally combat climate change and the effects thereof on a global scale. Further, reports need to be generated to communicate to stakeholders the importance of conserving and maintaining certain areas and the need to restore lost climate-positive environments. Thus, mitigating the negative effects of climate change produced by our daily activities. The aim is to ensure a better future for everyone.","title":"Conservation International"},{"location":"about/kartoza/","text":"Kartoza Kartoza will make geospatial data and technology work for you by partnering with us for training, development and maintenance of GIS systems. Kartoza is a South Africa-based Free and Open Source GIS (FOSSGIS) service provider. We use GIS software to solve complex location-related problems for individuals, businesses and governments around the world. Our team develops software using FOSSGIS to give you the freedom to share and modify your GIS as your needs grow and change.","title":"Kartoza"},{"location":"about/kartoza/#kartoza","text":"Kartoza will make geospatial data and technology work for you by partnering with us for training, development and maintenance of GIS systems. Kartoza is a South Africa-based Free and Open Source GIS (FOSSGIS) service provider. We use GIS software to solve complex location-related problems for individuals, businesses and governments around the world. Our team develops software using FOSSGIS to give you the freedom to share and modify your GIS as your needs grow and change.","title":"Kartoza"},{"location":"about/license/","text":"License","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"administrator/","text":"Administrators This section is for administrators of the plugin: The guide details how to create new tasks, and how to download and install a staging version of the plugin. The repository provides access to different versions of the plugin. This includes version based on specific pull requests.","title":"Administrators"},{"location":"administrator/#administrators","text":"This section is for administrators of the plugin: The guide details how to create new tasks, and how to download and install a staging version of the plugin. The repository provides access to different versions of the plugin. This includes version based on specific pull requests.","title":"Administrators"},{"location":"administrator/guide/","text":"Administrators guide Pilot area data This section deals with making updates to the data of the pilot study area (Bushback Ridge). This needs to be done in the GitHub repository, or locally on the repository clone, and then pushed into the repository. The change can be made as follows: The following JSON files needs to be considered when doing this, all of which are stored in \"src/cplus_plugin/data/default\" implementation_model.json ncs_pathways.json priority_weighted_layers.json Implementation models In this file existing implementation models can be edited (e.g. change name or description), be removed or a new model can be added. Here is a quick overview of a model stored in the JSON file Each model contains the following elements: uuid : A Universally unique identifier (UUID) for the model name : A unique name for the model description : Detailed description of the model pwls_ids : UUIDs of the priority weighted layers associated with the IM style : The style which will be applied to the Editing these will have an effect on the IM in the plugin When adding a new IM to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove an IM from the list of models, an administrator can simply remove the entry in the JSON file. Remove this text to remove a model: To update the list of priority weighted layers for a model, the ID needs to be retrieved: Open the priority_weighted_layers.json file Each available PWL will be listed under \"layers\" Cope and paste the UUID that needs to be added to the IM pwls_ids field Save the file A section on PWL editing will soon follow. NCS pathways An administrator can access/edit the NCS pathways as follows: Open the ncs_pathways.json file Here is a description of each element: uuid : A unique identifier for the pathway name : Unique title for the pathway description : Detailed description of the pathway path : Directory with file name for the pathway data layer_type : Zero (0) for rasters, one (1) for vector layers carbon_paths : A list of the carbon footprint rasters. This should be a directory with the raster name. Tif is the preferred format Editing these elements will make changes to the pilot area data in the plugin When adding a new pathway to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove a pathway from the list of layers, an administrator can simply remove the entry in the JSON file. Remove this text to remove a model: Priority weighted layers Do the following to change/add/remove priority weighted layers for the pilot study area Open the priority_weighted_layers.json file Here is a description of each element: uuid : A unique ID for the PWL name : Unique name for the PWL description : A detailed description of the PWL selected : Whether the PWL should be selected on default path : A directory with file name for the PWL data. This should be a raster Changing the above values will have an impact on the data in the plugin for the pilot study area When adding a new PWL to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove a PWL from the list of layers, an administrator can simply remove the entry in the JSON file. Remove this text to remove a model: Bugs and suggestions This section relates to creating an issue for when a bug is found in the plugin, or if the user has a suggested improvement for the plugin. Go to the CPLUS repository Click on the Issues tab Click on New Issue (see Figure 1 ) Title: Short, but descriptive Description: Detailed description. If it's a bug, an explanation on how to replicate the bug will be best. Screenshots of the bug or suggestion will also be helpful Figure 1: An example of a new GitHub issue Select a Label (e.g. bug, enhancement, etc.) as shown in Figure 2 Figure 2: Selecting a label for an issue Select the CPLUS Project ( Figure 3 ). This will add the issue/task to the project board Figure 3: Selecting a Project for an issue The end result should be similar to Figure 4 . Figure 4: An example of a finalized issue Click Submit new issue The issue will now be submitted to the GitHub repository and be available to the developers. Staging version of the plugin When a pull requested is performed, an automatic staging version is created. This will allow a developer to test their changes to the plugin with other changes which has not been merged into the main branch. Another advantage of this approach is to show the client to progress of the plugin. Get the staging version Go to the repository: https://github.com/kartoza/cplus-plugin To the right there is a section named Releases Click on Latest release Download the cplus_plugin .zip file if you want to install the plugin in QGIS Developers will likely be interested in Source code (zip) and Source code (tar.gz) options See user/installation on how to install a QGIS plugin If you want to have a look at past versions of the plugin: On the repository page, click on Releases A list of option will appear Choose the version you are interested in, and follow the steps discussed above","title":"Guide"},{"location":"administrator/guide/#administrators-guide","text":"","title":"Administrators guide"},{"location":"administrator/guide/#pilot-area-data","text":"This section deals with making updates to the data of the pilot study area (Bushback Ridge). This needs to be done in the GitHub repository, or locally on the repository clone, and then pushed into the repository. The change can be made as follows: The following JSON files needs to be considered when doing this, all of which are stored in \"src/cplus_plugin/data/default\" implementation_model.json ncs_pathways.json priority_weighted_layers.json","title":"Pilot area data"},{"location":"administrator/guide/#implementation-models","text":"In this file existing implementation models can be edited (e.g. change name or description), be removed or a new model can be added. Here is a quick overview of a model stored in the JSON file Each model contains the following elements: uuid : A Universally unique identifier (UUID) for the model name : A unique name for the model description : Detailed description of the model pwls_ids : UUIDs of the priority weighted layers associated with the IM style : The style which will be applied to the Editing these will have an effect on the IM in the plugin When adding a new IM to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove an IM from the list of models, an administrator can simply remove the entry in the JSON file. Remove this text to remove a model: To update the list of priority weighted layers for a model, the ID needs to be retrieved: Open the priority_weighted_layers.json file Each available PWL will be listed under \"layers\" Cope and paste the UUID that needs to be added to the IM pwls_ids field Save the file A section on PWL editing will soon follow.","title":"Implementation models"},{"location":"administrator/guide/#ncs-pathways","text":"An administrator can access/edit the NCS pathways as follows: Open the ncs_pathways.json file Here is a description of each element: uuid : A unique identifier for the pathway name : Unique title for the pathway description : Detailed description of the pathway path : Directory with file name for the pathway data layer_type : Zero (0) for rasters, one (1) for vector layers carbon_paths : A list of the carbon footprint rasters. This should be a directory with the raster name. Tif is the preferred format Editing these elements will make changes to the pilot area data in the plugin When adding a new pathway to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove a pathway from the list of layers, an administrator can simply remove the entry in the JSON file. Remove this text to remove a model:","title":"NCS pathways"},{"location":"administrator/guide/#priority-weighted-layers","text":"Do the following to change/add/remove priority weighted layers for the pilot study area Open the priority_weighted_layers.json file Here is a description of each element: uuid : A unique ID for the PWL name : Unique name for the PWL description : A detailed description of the PWL selected : Whether the PWL should be selected on default path : A directory with file name for the PWL data. This should be a raster Changing the above values will have an impact on the data in the plugin for the pilot study area When adding a new PWL to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove a PWL from the list of layers, an administrator can simply remove the entry in the JSON file. Remove this text to remove a model:","title":"Priority weighted layers"},{"location":"administrator/guide/#bugs-and-suggestions","text":"This section relates to creating an issue for when a bug is found in the plugin, or if the user has a suggested improvement for the plugin. Go to the CPLUS repository Click on the Issues tab Click on New Issue (see Figure 1 ) Title: Short, but descriptive Description: Detailed description. If it's a bug, an explanation on how to replicate the bug will be best. Screenshots of the bug or suggestion will also be helpful Figure 1: An example of a new GitHub issue Select a Label (e.g. bug, enhancement, etc.) as shown in Figure 2 Figure 2: Selecting a label for an issue Select the CPLUS Project ( Figure 3 ). This will add the issue/task to the project board Figure 3: Selecting a Project for an issue The end result should be similar to Figure 4 . Figure 4: An example of a finalized issue Click Submit new issue The issue will now be submitted to the GitHub repository and be available to the developers.","title":"Bugs and suggestions"},{"location":"administrator/guide/#staging-version-of-the-plugin","text":"When a pull requested is performed, an automatic staging version is created. This will allow a developer to test their changes to the plugin with other changes which has not been merged into the main branch. Another advantage of this approach is to show the client to progress of the plugin.","title":"Staging version of the plugin"},{"location":"administrator/guide/#get-the-staging-version","text":"Go to the repository: https://github.com/kartoza/cplus-plugin To the right there is a section named Releases Click on Latest release Download the cplus_plugin .zip file if you want to install the plugin in QGIS Developers will likely be interested in Source code (zip) and Source code (tar.gz) options See user/installation on how to install a QGIS plugin If you want to have a look at past versions of the plugin: On the repository page, click on Releases A list of option will appear Choose the version you are interested in, and follow the steps discussed above","title":"Get the staging version"},{"location":"administrator/repository/","text":"Pull requests artifacts PR title PR url Artifact name Artifact link Created date Main branch artifacts Commit link Artifact name Artifact link Created date import { Octokit, App } from \"https://esm.sh/octokit\"; const octokit = new Octokit(); const pulls = await octokit.request( \"GET /repos/kartoza/cplus-plugin/pulls\", {'state':'all'} ); const fetched_artifacts = await octokit.request( \"GET /repos/kartoza/cplus-plugin/actions/artifacts\", {'per_page': 30} ); const pulls_artifacts = []; const commits_artifacts = []; const artifacts_comments = []; for ( const pull of pulls.data ){ const head_sha = pull['head']['sha']; const pull_artifact = {}; const artifact_comments = []; if (pull == undefined) continue; for ( const artifact of fetched_artifacts.data.artifacts){ if ( artifact['workflow_run']['head_sha'] == head_sha && artifact['name'].indexOf('cplus_plugin') != -1 ){ pull_artifact['pull'] = pull; pull_artifact['artifact'] = artifact; artifact_comments['artifact'] = artifact; artifact_comments['comments'] = pull['comments_url']; } } pulls_artifacts.push(pull_artifact); artifacts_comments.push(artifact_comments); } for ( const artifact of fetched_artifacts.data.artifacts){ if ( artifact['name'].indexOf('cplus_plugin') == -1){ continue; } const commit = await octokit.request( \"GET /repos/kartoza/cplus-plugin/commits/\"+ artifact['workflow_run']['head_sha'] ); if ( commit == undefined | commit.data.parents.length < 2 ){ continue; } const commit_artifact = { 'commit': commit, 'artifact': artifact }; commits_artifacts.push(commit_artifact); } const pulls_tbody = document.getElementById('pulls_tbody'); const main_tbody = document.getElementById('main_tbody'); for (const pull_artifact of pulls_artifacts){ if (pull_artifact['pull'] == undefined) { continue; } const tr = document.createElement('tr'); const first_td = document.createElement('td'); const second_td = document.createElement('td'); const third_td = document.createElement('td'); const fourth_td = document.createElement('td'); const fifth_td = document.createElement('td'); const pull_link = document.createElement(\"a\"); const link_node = document.createTextNode( pull_artifact['pull']['title'] ); pull_link.appendChild(link_node); pull_link.textContent = pull_artifact['pull']['html_url']; pull_link.title = pull_artifact['pull']['html_url']; pull_link.href = pull_artifact['pull']['html_url']; first_td.appendChild(link_node); second_td.appendChild(pull_link); tr.appendChild(first_td); tr.appendChild(second_td); const artifact_link = document.createElement(\"a\"); const second_link_node = document.createTextNode( pull_artifact['artifact']['name'] ); const date_node = document.createTextNode( pull_artifact['artifact']['created_at'] ); artifact_link.appendChild(second_link_node); artifact_link.textContent = pull_artifact['artifact']['archive_download_url']; artifact_link.href = pull_artifact['artifact']['archive_download_url']; artifact_link.id = pull_artifact['artifact']['name']; third_td.appendChild(second_link_node); fourth_td.appendChild(artifact_link); fifth_td.appendChild(date_node); tr.appendChild(third_td); tr.appendChild(fourth_td); tr.appendChild(fifth_td); pulls_tbody.appendChild(tr) } for( const artifact_comment of artifacts_comments){ if (artifact_comment['comments'] === undefined) continue; const comments = await fetch(artifact_comment['comments']); const result = comments.json().then(function(results){ for(const comment of results){ if (comment.body.indexOf(\"Download the plugin zip file here\") != -1){ const artifact_link_regex = /(https?:\\/\\/[^ ]*)/; const matches = comment.body.match(artifact_link_regex); const art_link = matches[0]; const artifact_name = artifact_comment['artifact']['name']; const artifact_url = art_link.split(\"\\n\")[0]; const pull_artifact = document.getElementById(artifact_name); if( pull_artifact == undefined){ continue; } pull_artifact.textContent = artifact_url; pull_artifact.href = artifact_url; } } }) } for (const commit_artifact of commits_artifacts){ if (commit_artifact['commit'] === undefined) continue; const tr = document.createElement('tr'); const first_td = document.createElement('td'); const second_td = document.createElement('td'); const third_td = document.createElement('td'); const fourth_td = document.createElement('td'); const fifth_td = document.createElement('td'); const pull_link = document.createElement(\"a\"); const link_node = document.createTextNode( commit_artifact['commit']['data']['sha'] ); pull_link.appendChild(link_node); pull_link.textContent = commit_artifact['commit']['data']['html_url']; pull_link.title = commit_artifact['commit']['data']['html_url']; pull_link.href = commit_artifact['commit']['data']['html_url']; first_td.appendChild(link_node); second_td.appendChild(pull_link); tr.appendChild(second_td); const artifact_link = document.createElement(\"a\"); const second_link_node = document.createTextNode( commit_artifact['artifact']['name'] ); const date_node = document.createTextNode( commit_artifact['artifact']['created_at'] ); artifact_link.appendChild(second_link_node); artifact_link.textContent = commit_artifact['artifact']['archive_download_url']; artifact_link.href = commit_artifact['artifact']['archive_download_url']; third_td.appendChild(second_link_node); artifact_link.id = commit_artifact['artifact']['name']; fourth_td.appendChild(artifact_link); fifth_td.appendChild(date_node); tr.appendChild(third_td); tr.appendChild(fourth_td); tr.appendChild(fifth_td); main_tbody.appendChild(tr) } const response = await fetch( \"https://raw.githubusercontent.com/kartoza/cplus-plugin/docs/docs/admin/artifacts_list.txt\" ); const file_text_promise = response.text(); const res = file_text_promise.then(function(result){ const art_list = result.split(\"\\n\"); for( const art of art_list){ if( art === \"\"){ continue; } const parts = art.split(\" - \"); const artifact_name = parts[0].trim(); const artifact_url = parts[1].trim(); const main_artifact = document.getElementById(artifact_name); if( main_artifact == undefined){ continue; } main_artifact.textContent = artifact_url; main_artifact.href = artifact_url; } const loading_div = document.getElementById('loading_div'); loading_div.remove(); });","title":"Repository"},{"location":"developer/","text":"Developers Section which aims at guiding developers of the plugin: Setup details how to set up a developers environment of the plugin. Developers documentation details how a developer should document changes to the code. Architecture of the plugin","title":"Developers"},{"location":"developer/#developers","text":"Section which aims at guiding developers of the plugin: Setup details how to set up a developers environment of the plugin. Developers documentation details how a developer should document changes to the code. Architecture of the plugin","title":"Developers"},{"location":"developer/api/core/api_conf/","text":"Configuration Handles storage and retrieval of the plugin QgsSettings. ScenarioSettings dataclass Bases: Scenario Plugin Scenario settings. from_qgs_settings classmethod from_qgs_settings ( identifier , settings ) Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. Parameters: Name Type Description Default identifier str Scenario identifier required settings QgsSettings Scenario identifier required Returns: Type Description ScenarioSettings Scenario settings object Source code in src/cplus_plugin/conf.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @classmethod def from_qgs_settings ( cls , identifier : str , settings : QgsSettings ): \"\"\"Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. :param identifier: Scenario identifier :type identifier: str :param settings: Scenario identifier :type settings: QgsSettings :returns: Scenario settings object :rtype: ScenarioSettings \"\"\" return cls ( uuid = uuid . UUID ( identifier ), name = settings . value ( \"name\" , None ), description = settings . value ( \"description\" , None ), ) get_scenario_extent classmethod get_scenario_extent () Fetches Scenario extent from the passed scenario settings. Returns: Type Description SpatialExtent Spatial extent instance extent Source code in src/cplus_plugin/conf.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def get_scenario_extent ( cls ): \"\"\"Fetches Scenario extent from the passed scenario settings. :returns: Spatial extent instance extent :rtype: SpatialExtent \"\"\" spatial_key = \"extent/spatial\" with qgis_settings ( spatial_key , cls ) as settings : bbox = settings . value ( \"bbox\" , None ) spatial_extent = SpatialExtent ( bbox = bbox ) return spatial_extent Settings Bases: Enum Plugin settings names SettingsManager Bases: QObject Manages saving/loading settings for the plugin in QgsSettings. delete_all_scenarios delete_all_scenarios () Deletes all the plugin scenarios settings. Source code in src/cplus_plugin/conf.py 355 356 357 358 359 360 361 def delete_all_scenarios ( self ): \"\"\"Deletes all the plugin scenarios settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_name in settings . childGroups (): settings . remove ( scenario_name ) delete_priority_group delete_priority_group ( identifier ) Removes priority group that match the passed identifier Parameters: Name Type Description Default identifier str Priority group identifier required Source code in src/cplus_plugin/conf.py 676 677 678 679 680 681 682 683 684 685 686 687 def delete_priority_group ( self , identifier ): \"\"\"Removes priority group that match the passed identifier :param identifier: Priority group identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } /\" ) as settings : for priority_group in settings . childGroups (): if str ( priority_group ) == str ( identifier ): settings . remove ( priority_group ) delete_priority_groups delete_priority_groups () Deletes all the plugin priority groups settings. Source code in src/cplus_plugin/conf.py 689 690 691 692 693 694 695 def delete_priority_groups ( self ): \"\"\"Deletes all the plugin priority groups settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for priority_group in settings . childGroups (): settings . remove ( priority_group ) delete_priority_layer delete_priority_layer ( identifier ) Removes priority layer that match the passed identifier Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 565 566 567 568 569 570 571 572 573 574 575 576 def delete_priority_layer ( self , identifier ): \"\"\"Removes priority layer that match the passed identifier :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): if str ( priority_layer ) == str ( identifier ): settings . remove ( priority_layer ) delete_priority_layers delete_priority_layers () Deletes all the plugin priority weighting layers settings. Source code in src/cplus_plugin/conf.py 557 558 559 560 561 562 563 def delete_priority_layers ( self ): \"\"\"Deletes all the plugin priority weighting layers settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for priority_layer in settings . childGroups (): settings . remove ( priority_layer ) delete_settings delete_settings () Deletes the all the plugin settings. Source code in src/cplus_plugin/conf.py 238 239 240 def delete_settings ( self ): \"\"\"Deletes the all the plugin settings.\"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } \" ) find_group_by_name find_group_by_name ( name ) Finds a priority group setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Name of the group required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 def find_group_by_name ( self , name ) -> typing . Dict : \"\"\"Finds a priority group setting inside the plugin QgsSettings by name. :param name: Name of the group :type name: str :returns: Priority group :rtype: typing.Dict \"\"\" found_id = None with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for group_id in settings . childGroups (): group_settings_key = self . _get_priority_groups_settings_base ( group_id ) with qgis_settings ( group_settings_key ) as group_settings_key : group_name = group_settings_key . value ( \"name\" ) if group_name == name : found_id = uuid . UUID ( group_id ) break return self . get_priority_group ( found_id ) find_implementation_model_by_name find_implementation_model_by_name ( name ) Finds an implementation model setting inside the plugin QgsSettings that equals or matches the name. Parameters: Name Type Description Default name str Implementation model name required Returns: Type Description ImplementationModel Implementation model Source code in src/cplus_plugin/conf.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 def find_implementation_model_by_name ( self , name ) -> typing . Dict : \"\"\"Finds an implementation model setting inside the plugin QgsSettings that equals or matches the name. :param name: Implementation model name :type name: str :returns: Implementation model :rtype: ImplementationModel \"\"\" for model in self . get_all_implementation_models (): model_name = model . name trimmed_name = model_name . replace ( \" \" , \"_\" ) if model_name == name or model_name in name or trimmed_name in name : return model return None find_layer_by_name find_layer_by_name ( name ) Finds a priority layer setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Priority layers identifier required Returns: Type Description dict Priority layers dict Source code in src/cplus_plugin/conf.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def find_layer_by_name ( self , name ) -> typing . Dict : \"\"\"Finds a priority layer setting inside the plugin QgsSettings by name. :param name: Priority layers identifier :type name: str :returns: Priority layers dict :rtype: dict \"\"\" found_id = None with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): layer_settings_key = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( layer_settings_key ) as layer_settings : layer_name = layer_settings . value ( \"name\" ) if layer_name == name : found_id = uuid . UUID ( layer_id ) break return self . get_priority_layer ( found_id ) if found_id is not None else None find_layers_by_group find_layers_by_group ( group ) Finds priority layers inside the plugin QgsSettings that contain the passed group. Parameters: Name Type Description Default group str Priority group name required Returns: Type Description list Priority layers list Source code in src/cplus_plugin/conf.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 def find_layers_by_group ( self , group ) -> typing . List : \"\"\"Finds priority layers inside the plugin QgsSettings that contain the passed group. :param group: Priority group name :type group: str :returns: Priority layers list :rtype: list \"\"\" layers = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : if group == group_settings . value ( \"name\" ): layers . append ( self . get_priority_layer ( layer_id )) return layers find_settings find_settings ( name ) Returns the plugin setting keys from the plugin root group that matches the passed name Parameters: Name Type Description Default name str Setting name to search for required Returns: Type Description list List of the matching settings names Source code in src/cplus_plugin/conf.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def find_settings ( self , name ): \"\"\"Returns the plugin setting keys from the plugin root group that matches the passed name :param name: Setting name to search for :type name: str :returns result: List of the matching settings names :rtype result: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } \" ) as settings : for settings_name in settings . childKeys (): if name in settings_name : result . append ( settings_name ) return result get_all_implementation_models get_all_implementation_models () Get all the implementation model objects stored in settings. Returns: Type Description list Returns all the implementation model objects. Source code in src/cplus_plugin/conf.py 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 def get_all_implementation_models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Get all the implementation model objects stored in settings. :returns: Returns all the implementation model objects. :rtype: list \"\"\" implementation_models = [] implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : keys = settings . childKeys () for k in keys : implementation_model = self . get_implementation_model ( k ) if implementation_model is not None : implementation_models . append ( implementation_model ) return sorted ( implementation_models , key = lambda imp_model : imp_model . name ) get_all_ncs_pathways get_all_ncs_pathways () Get all the NCS pathway objects stored in settings. Returns: Type Description list Returns all the NCS pathway objects. Source code in src/cplus_plugin/conf.py 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 def get_all_ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Get all the NCS pathway objects stored in settings. :returns: Returns all the NCS pathway objects. :rtype: list \"\"\" ncs_pathways = [] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : keys = settings . childKeys () for k in keys : ncs_pathway = self . get_ncs_pathway ( k ) if ncs_pathway is not None : ncs_pathways . append ( ncs_pathway ) return sorted ( ncs_pathways , key = lambda ncs : ncs . name ) get_implementation_model get_implementation_model ( implementation_model_uuid ) Gets an implementation model object matching the given unique identified. Parameters: Name Type Description Default implementation_model_uuid str Unique identifier for the implementation model object. required Returns: Type Description ImplementationModel Returns the implementation model object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 def get_implementation_model ( self , implementation_model_uuid : str ) -> typing . Union [ ImplementationModel , None ]: \"\"\"Gets an implementation model object matching the given unique identified. :param implementation_model_uuid: Unique identifier for the implementation model object. :type implementation_model_uuid: str :returns: Returns the implementation model object matching the given identifier else None if not found. :rtype: ImplementationModel \"\"\" implementation_model = None implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : implementation_model = settings . value ( implementation_model_uuid , None ) ncs_uuids = [] if implementation_model is not None : implementation_model_dict = {} try : implementation_model_dict = json . loads ( implementation_model ) except json . JSONDecodeError : log ( \"Implementation model JSON is invalid.\" ) if PATHWAYS_ATTRIBUTE in implementation_model_dict : ncs_uuids = implementation_model_dict [ PATHWAYS_ATTRIBUTE ] implementation_model = create_implementation_model ( implementation_model_dict ) if implementation_model is not None : for ncs_uuid in ncs_uuids : ncs = self . get_ncs_pathway ( ncs_uuid ) if ncs is not None : implementation_model . add_ncs_pathway ( ncs ) return implementation_model get_ncs_pathway get_ncs_pathway ( ncs_uuid ) Gets an NCS pathway object matching the given unique identified. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description NcsPathway Returns the NCS pathway object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 def get_ncs_pathway ( self , ncs_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Gets an NCS pathway object matching the given unique identified. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway object matching the given identifier else None if not found. :rtype: NcsPathway \"\"\" ncs_pathway = None ncs_dict = self . get_ncs_pathway_dict ( ncs_uuid ) if len ( ncs_dict ) == 0 : return None ncs_pathway = create_ncs_pathway ( ncs_dict ) return ncs_pathway get_ncs_pathway_dict get_ncs_pathway_dict ( ncs_uuid ) Gets an NCS pathway attribute values as a dictionary. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description dict Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. Source code in src/cplus_plugin/conf.py 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 def get_ncs_pathway_dict ( self , ncs_uuid : str ) -> dict : \"\"\"Gets an NCS pathway attribute values as a dictionary. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. :rtype: dict \"\"\" ncs_pathway_dict = {} ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : ncs_model = settings . value ( ncs_uuid , dict ()) if len ( ncs_model ) > 0 : try : ncs_pathway_dict = json . loads ( ncs_model ) except json . JSONDecodeError : log ( \"NCS pathway JSON is invalid\" ) return ncs_pathway_dict get_priority_group get_priority_group ( identifier ) Retrieves the priority group that matches the passed identifier. Parameters: Name Type Description Default identifier str Priority group identifier required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 def get_priority_group ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority group that matches the passed identifier. :param identifier: Priority group identifier :type identifier: str :returns: Priority group :rtype: typing.Dict \"\"\" if identifier is None : return None settings_key = self . _get_priority_groups_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : priority_group = { \"uuid\" : identifier } priority_group [ \"name\" ] = settings . value ( \"name\" ) priority_group [ \"value\" ] = settings . value ( \"value\" ) priority_group [ \"description\" ] = settings . value ( \"description\" ) return priority_group get_priority_groups get_priority_groups () Gets all the available priority groups in the plugin. Returns: Type Description list List of the priority groups instances Source code in src/cplus_plugin/conf.py 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 def get_priority_groups ( self ) -> typing . List [ typing . Dict ]: \"\"\"Gets all the available priority groups in the plugin. :returns: List of the priority groups instances :rtype: list \"\"\" priority_groups = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_groups_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : group = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"value\" : priority_settings . value ( \"value\" ), \"description\" : priority_settings . value ( \"description\" ), } priority_groups . append ( group ) return priority_groups get_priority_layer get_priority_layer ( identifier ) Retrieves the priority layer that matches the passed identifier. Parameters: Name Type Description Default identifier uuid.UUID Priority layers identifier required Returns: Type Description dict Priority layer dict Source code in src/cplus_plugin/conf.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def get_priority_layer ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority layer that matches the passed identifier. :param identifier: Priority layers identifier :type identifier: uuid.UUID :returns: Priority layer dict :rtype: dict \"\"\" priority_layer = None settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : groups_key = f \" { settings_key } /groups\" groups = [] if len ( settings . childKeys ()) <= 0 : return priority_layer with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"uuid\" ] = group_settings . value ( \"uuid\" ) stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) priority_layer = { \"uuid\" : str ( identifier )} priority_layer [ \"name\" ] = settings . value ( \"name\" ) priority_layer [ \"description\" ] = settings . value ( \"description\" ) priority_layer [ \"path\" ] = settings . value ( \"path\" ) priority_layer [ \"selected\" ] = settings . value ( \"selected\" , type = bool ) priority_layer [ \"user_defined\" ] = settings . value ( \"user_defined\" , defaultValue = True , type = bool ) priority_layer [ \"groups\" ] = groups return priority_layer get_priority_layers get_priority_layers () Gets all the available priority layers in the plugin. Returns: Type Description list Priority layers list Source code in src/cplus_plugin/conf.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 def get_priority_layers ( self ) -> typing . List : \"\"\"Gets all the available priority layers in the plugin. :returns: Priority layers list :rtype: list \"\"\" priority_layer_list = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" groups = [] with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"uuid\" ] = group_settings . value ( \"uuid\" ) stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) layer = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"description\" : priority_settings . value ( \"description\" ), \"path\" : priority_settings . value ( \"path\" ), \"selected\" : priority_settings . value ( \"selected\" , type = bool ), \"user_defined\" : priority_settings . value ( \"user_defined\" , defaultValue = True , type = bool ), \"groups\" : groups , } priority_layer_list . append ( layer ) return priority_layer_list get_scenario get_scenario ( scenario_id ) Retrieves the first scenario that matched the passed scenario id. Parameters: Name Type Description Default scenario_id str Scenario id required Returns: Type Description ScenarioSettings Scenario settings instance Source code in src/cplus_plugin/conf.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def get_scenario ( self , scenario_id ): \"\"\"Retrieves the first scenario that matched the passed scenario id. :param scenario_id: Scenario id :type scenario_id: str :returns: Scenario settings instance :rtype: ScenarioSettings \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : scenario = ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) if scenario . id == scenario_id : return scenario return None get_scenarios get_scenarios () Gets all the available scenarios settings in the plugin. Returns: Type Description list List of the scenario settings instances Source code in src/cplus_plugin/conf.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def get_scenarios ( self ): \"\"\"Gets all the available scenarios settings in the plugin. :returns: List of the scenario settings instances :rtype: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : scenario = ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) scenario . extent = self . get_scenario_ result . append ( ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) ) return result get_value get_value ( name , default = None , setting_type = None ) Gets value of the setting with the passed name. Parameters: Name Type Description Default name str Name of setting key required default Any Default value returned when the setting key does not exist None setting_type Any Type of the store setting None Returns: Type Description Any Value of the setting Source code in src/cplus_plugin/conf.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def get_value ( self , name : str , default = None , setting_type = None ): \"\"\"Gets value of the setting with the passed name. :param name: Name of setting key :type name: str :param default: Default value returned when the setting key does not exist :type default: Any :param setting_type: Type of the store setting :type setting_type: Any :returns: Value of the setting :rtype: Any \"\"\" if setting_type : return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default , setting_type ) return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default ) remove remove ( name ) Remove the setting with the specified name. Parameters: Name Type Description Default name str Name of the setting key required Source code in src/cplus_plugin/conf.py 230 231 232 233 234 235 236 def remove ( self , name ): \"\"\"Remove the setting with the specified name. :param name: Name of the setting key :type name: str \"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } / { name } \" ) remove_implementation_model remove_implementation_model ( implementation_model_uuid ) Removes an implementation model settings entry using the UUID. Parameters: Name Type Description Default implementation_model_uuid str Unique identifier of the implementation model entry to removed. required Source code in src/cplus_plugin/conf.py 1021 1022 1023 1024 1025 1026 1027 1028 1029 def remove_implementation_model ( self , implementation_model_uuid : str ): \"\"\"Removes an implementation model settings entry using the UUID. :param implementation_model_uuid: Unique identifier of the implementation model entry to removed. :type implementation_model_uuid: str \"\"\" if self . get_implementation_model ( implementation_model_uuid ) is not None : self . remove ( f \" { self . IMPLEMENTATION_MODEL_BASE } / { implementation_model_uuid } \" ) remove_ncs_pathway remove_ncs_pathway ( ncs_uuid ) Removes an NCS pathway settings entry using the UUID. Parameters: Name Type Description Default ncs_uuid str Unique identifier of the NCS pathway entry to removed. required Source code in src/cplus_plugin/conf.py 842 843 844 845 846 847 848 849 850 def remove_ncs_pathway ( self , ncs_uuid : str ): \"\"\"Removes an NCS pathway settings entry using the UUID. :param ncs_uuid: Unique identifier of the NCS pathway entry to removed. :type ncs_uuid: str \"\"\" if self . get_ncs_pathway ( ncs_uuid ) is not None : self . remove ( f \" { self . NCS_PATHWAY_BASE } / { ncs_uuid } \" ) save_implementation_model save_implementation_model ( implementation_model ) Saves an implementation model object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default implementation_model Union [ ImplementationModel , dict ] Implementation model object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 def save_implementation_model ( self , implementation_model : typing . Union [ ImplementationModel , dict ] ): \"\"\"Saves an implementation model object serialized to a json string indexed by the UUID. :param implementation_model: Implementation model object or attribute values in a dictionary which are then serialized to a JSON string. :type implementation_model: ImplementationModel, dict \"\"\" if isinstance ( implementation_model , ImplementationModel ): priority_layers = implementation_model . priority_layers layer_styles = implementation_model . layer_styles style_pixel_value = implementation_model . style_pixel_value ncs_pathways = [] for ncs in implementation_model . pathways : ncs_pathways . append ( str ( ncs . uuid )) implementation_model = layer_component_to_dict ( implementation_model ) implementation_model [ PRIORITY_LAYERS_SEGMENT ] = priority_layers implementation_model [ PATHWAYS_ATTRIBUTE ] = ncs_pathways implementation_model [ STYLE_ATTRIBUTE ] = layer_styles implementation_model [ PIXEL_VALUE_ATTRIBUTE ] = style_pixel_value if isinstance ( implementation_model , dict ): priority_layers = [] if implementation_model . get ( \"pwls_ids\" ) is not None : for layer_id in implementation_model . get ( \"pwls_ids\" , []): layer = self . get_priority_layer ( layer_id ) priority_layers . append ( layer ) if len ( priority_layers ) > 0 : implementation_model [ PRIORITY_LAYERS_SEGMENT ] = priority_layers implementation_model_str = json . dumps ( implementation_model ) implementation_model_uuid = implementation_model [ UUID_ATTRIBUTE ] implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : settings . setValue ( implementation_model_uuid , implementation_model_str ) save_ncs_pathway save_ncs_pathway ( ncs_pathway ) Saves an NCS pathway object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default ncs_pathway Union [ NcsPathway , dict ] NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 def save_ncs_pathway ( self , ncs_pathway : typing . Union [ NcsPathway , dict ]): \"\"\"Saves an NCS pathway object serialized to a json string indexed by the UUID. :param ncs_pathway: NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. :type ncs_pathway: NcsPathway, dict \"\"\" if isinstance ( ncs_pathway , NcsPathway ): ncs_pathway = ncs_pathway_to_dict ( ncs_pathway ) ncs_str = json . dumps ( ncs_pathway ) ncs_uuid = ncs_pathway [ UUID_ATTRIBUTE ] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : settings . setValue ( ncs_uuid , ncs_str ) save_priority_group save_priority_group ( priority_group ) Save the priority group into the plugin settings Parameters: Name Type Description Default priority_group str Priority group required Source code in src/cplus_plugin/conf.py 662 663 664 665 666 667 668 669 670 671 672 673 674 def save_priority_group ( self , priority_group ): \"\"\"Save the priority group into the plugin settings :param priority_group: Priority group :type priority_group: str \"\"\" settings_key = self . _get_priority_groups_settings_base ( priority_group [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"name\" , priority_group [ \"name\" ]) settings . setValue ( \"value\" , priority_group [ \"value\" ]) settings . setValue ( \"description\" , priority_group . get ( \"description\" )) save_priority_layer save_priority_layer ( priority_layer ) Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal Parameters: Name Type Description Default priority_layer dict Priority layer required Source code in src/cplus_plugin/conf.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 def save_priority_layer ( self , priority_layer ): \"\"\"Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal :param priority_layer: Priority layer :type priority_layer: dict \"\"\" settings_key = self . _get_priority_layers_settings_base ( priority_layer [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : groups = priority_layer . get ( \"groups\" , []) settings . setValue ( \"name\" , priority_layer [ \"name\" ]) settings . setValue ( \"description\" , priority_layer [ \"description\" ]) settings . setValue ( \"path\" , priority_layer [ \"path\" ]) settings . setValue ( \"selected\" , priority_layer . get ( \"selected\" , False )) settings . setValue ( \"user_defined\" , priority_layer . get ( \"user_defined\" , True )) groups_key = f \" { settings_key } /groups\" with qgis_settings ( groups_key ) as groups_settings : for group_id in groups_settings . childGroups (): groups_settings . remove ( group_id ) for group in groups : group_key = f \" { groups_key } / { group [ 'name' ] } \" with qgis_settings ( group_key ) as group_settings : group_settings . setValue ( \"uuid\" , group . get ( \"uuid\" )) group_settings . setValue ( \"name\" , group [ \"name\" ]) group_settings . setValue ( \"value\" , group [ \"value\" ]) self . priority_layers_changed . emit () save_scenario save_scenario ( scenario_settings ) Save the passed scenario settings into the plugin settings Parameters: Name Type Description Default scenario_settings ScenarioSettings Scenario settings required Source code in src/cplus_plugin/conf.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def save_scenario ( self , scenario_settings ): \"\"\"Save the passed scenario settings into the plugin settings :param scenario_settings: Scenario settings :type scenario_settings: ScenarioSettings \"\"\" settings_key = self . _get_scenario_settings_base ( scenario_settings . uuid ) self . save_scenario_extent ( settings_key , scenario_settings . extent ) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"name\" , scenario_settings . name ) settings . setValue ( \"description\" , scenario_settings . description ) settings . setValue ( \"uuid\" , scenario_settings . uuid ) save_scenario_extent save_scenario_extent ( key , extent ) Saves the scenario extent into plugin settings using the provided settings group key. Parameters: Name Type Description Default key SpatialExtent Scenario extent required extent str Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key QgsSettings group key required Source code in src/cplus_plugin/conf.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def save_scenario_extent ( self , key , extent ): \"\"\"Saves the scenario extent into plugin settings using the provided settings group key. :param key: Scenario extent :type key: SpatialExtent :param extent: QgsSettings group key :type extent: str Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key \"\"\" spatial_extent = extent . spatial . bbox spatial_key = f \" { key } /extent/spatial/\" with qgis_settings ( spatial_key ) as settings : settings . setValue ( \"bbox\" , spatial_extent ) set_current_priority_layer set_current_priority_layer ( identifier ) Set current priority layer Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 def set_current_priority_layer ( self , identifier ): \"\"\"Set current priority layer :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as layer_settings : layer_settings . setValue ( \"selected\" , str ( priority_layer ) == str ( identifier ) ) set_value set_value ( name , value ) Adds a new setting key and value on the plugin specific settings. Parameters: Name Type Description Default name str Name of setting key required value Any Value of the setting required Source code in src/cplus_plugin/conf.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def set_value ( self , name : str , value ): \"\"\"Adds a new setting key and value on the plugin specific settings. :param name: Name of setting key :type name: str :param value: Value of the setting :type value: Any \"\"\" self . settings . setValue ( f \" { self . BASE_GROUP_NAME } / { name } \" , value ) if isinstance ( name , Settings ): name = name . value self . settings_updated . emit ( name , value ) update_implementation_model update_implementation_model ( implementation_model ) Updates the attributes of the Implementation object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. Parameters: Name Type Description Default implementation_model ImplementationModel ImplementationModel object to be updated. required Source code in src/cplus_plugin/conf.py 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 def update_implementation_model ( self , implementation_model : ImplementationModel ): \"\"\"Updates the attributes of the Implementation object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. :param implementation_model: ImplementationModel object to be updated. :type implementation_model: ImplementationModel \"\"\" base_dir = self . get_value ( Settings . BASE_DIR ) if base_dir : # PWLs path update for layer in implementation_model . priority_layers : if layer in PRIORITY_LAYERS and base_dir not in layer . get ( PATH_ATTRIBUTE ): abs_pwl_path = ( f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } /\" f \" { layer . get ( PATH_ATTRIBUTE ) } \" ) abs_pwl_path = str ( os . path . normpath ( abs_pwl_path )) layer [ PATH_ATTRIBUTE ] = abs_pwl_path # Remove then re-insert self . remove_implementation_model ( str ( implementation_model . uuid )) self . save_implementation_model ( implementation_model ) update_implementation_models update_implementation_models () Updates the attributes of the avaialable implementation models Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model object to be updated. required Source code in src/cplus_plugin/conf.py 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 def update_implementation_models ( self ): \"\"\"Updates the attributes of the avaialable implementation models :param implementation_model: Implementation model object to be updated. :type implementation_model: ImplementationModel \"\"\" models = self . get_all_implementation_models () for implementation_model in models : self . update_implementation_model ( implementation_model ) update_ncs_pathway update_ncs_pathway ( ncs_pathway ) Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be updated. required Source code in src/cplus_plugin/conf.py 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 def update_ncs_pathway ( self , ncs_pathway : NcsPathway ): \"\"\"Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. :param ncs_pathway: NCS pathway object to be updated. :type ncs_pathway: NcsPathway \"\"\" base_dir = self . get_value ( Settings . BASE_DIR ) if not base_dir : return # Pathway location for default pathway if not ncs_pathway . user_defined : p = Path ( ncs_pathway . path ) # Only update if path does not exist otherwise # fallback to check under base directory. if not p . exists (): abs_path = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } /\" f \" { p . name } \" abs_path = str ( os . path . normpath ( abs_path )) ncs_pathway . path = abs_path # Carbon location abs_carbon_paths = [] for cb_path in ncs_pathway . carbon_paths : cp = Path ( cb_path ) # Similarly, if the given carbon path does not exist then try # to use the default one in the ncs_carbon directory. if not cp . exists (): abs_carbon_path = f \" { base_dir } / { NCS_CARBON_SEGMENT } /\" f \" { cp . name } \" abs_carbon_path = str ( os . path . normpath ( abs_carbon_path )) abs_carbon_paths . append ( abs_carbon_path ) else : abs_carbon_paths . append ( cb_path ) ncs_pathway . carbon_paths = abs_carbon_paths # Remove then re-insert self . remove_ncs_pathway ( str ( ncs_pathway . uuid )) self . save_ncs_pathway ( ncs_pathway ) update_ncs_pathways update_ncs_pathways () Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. Source code in src/cplus_plugin/conf.py 787 788 789 790 791 792 793 794 795 796 def update_ncs_pathways ( self ): \"\"\"Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. \"\"\" ncs_pathways = self . get_all_ncs_pathways () for ncs in ncs_pathways : self . update_ncs_pathway ( ncs ) qgis_settings qgis_settings ( group_root , settings = None ) Context manager to help defining groups when creating QgsSettings. :yields: Instance of the created settings :ytype: QgsSettings Parameters: Name Type Description Default group_root str Name of the root group for the settings required settings QgsSettings QGIS settings to use None Source code in src/cplus_plugin/conf.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @contextlib . contextmanager def qgis_settings ( group_root : str , settings = None ): \"\"\"Context manager to help defining groups when creating QgsSettings. :param group_root: Name of the root group for the settings :type group_root: str :param settings: QGIS settings to use :type settings: QgsSettings :yields: Instance of the created settings :ytype: QgsSettings \"\"\" if settings is None : settings = QgsSettings () settings . beginGroup ( group_root ) try : yield settings finally : settings . endGroup ()","title":"Configuration"},{"location":"developer/api/core/api_conf/#configuration","text":"Handles storage and retrieval of the plugin QgsSettings.","title":"Configuration"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.ScenarioSettings","text":"Bases: Scenario Plugin Scenario settings.","title":"ScenarioSettings"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.ScenarioSettings.from_qgs_settings","text":"from_qgs_settings ( identifier , settings ) Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. Parameters: Name Type Description Default identifier str Scenario identifier required settings QgsSettings Scenario identifier required Returns: Type Description ScenarioSettings Scenario settings object Source code in src/cplus_plugin/conf.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @classmethod def from_qgs_settings ( cls , identifier : str , settings : QgsSettings ): \"\"\"Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. :param identifier: Scenario identifier :type identifier: str :param settings: Scenario identifier :type settings: QgsSettings :returns: Scenario settings object :rtype: ScenarioSettings \"\"\" return cls ( uuid = uuid . UUID ( identifier ), name = settings . value ( \"name\" , None ), description = settings . value ( \"description\" , None ), )","title":"from_qgs_settings()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.ScenarioSettings.get_scenario_extent","text":"get_scenario_extent () Fetches Scenario extent from the passed scenario settings. Returns: Type Description SpatialExtent Spatial extent instance extent Source code in src/cplus_plugin/conf.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def get_scenario_extent ( cls ): \"\"\"Fetches Scenario extent from the passed scenario settings. :returns: Spatial extent instance extent :rtype: SpatialExtent \"\"\" spatial_key = \"extent/spatial\" with qgis_settings ( spatial_key , cls ) as settings : bbox = settings . value ( \"bbox\" , None ) spatial_extent = SpatialExtent ( bbox = bbox ) return spatial_extent","title":"get_scenario_extent()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.Settings","text":"Bases: Enum Plugin settings names","title":"Settings"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager","text":"Bases: QObject Manages saving/loading settings for the plugin in QgsSettings.","title":"SettingsManager"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_all_scenarios","text":"delete_all_scenarios () Deletes all the plugin scenarios settings. Source code in src/cplus_plugin/conf.py 355 356 357 358 359 360 361 def delete_all_scenarios ( self ): \"\"\"Deletes all the plugin scenarios settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_name in settings . childGroups (): settings . remove ( scenario_name )","title":"delete_all_scenarios()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_priority_group","text":"delete_priority_group ( identifier ) Removes priority group that match the passed identifier Parameters: Name Type Description Default identifier str Priority group identifier required Source code in src/cplus_plugin/conf.py 676 677 678 679 680 681 682 683 684 685 686 687 def delete_priority_group ( self , identifier ): \"\"\"Removes priority group that match the passed identifier :param identifier: Priority group identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } /\" ) as settings : for priority_group in settings . childGroups (): if str ( priority_group ) == str ( identifier ): settings . remove ( priority_group )","title":"delete_priority_group()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_priority_groups","text":"delete_priority_groups () Deletes all the plugin priority groups settings. Source code in src/cplus_plugin/conf.py 689 690 691 692 693 694 695 def delete_priority_groups ( self ): \"\"\"Deletes all the plugin priority groups settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for priority_group in settings . childGroups (): settings . remove ( priority_group )","title":"delete_priority_groups()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_priority_layer","text":"delete_priority_layer ( identifier ) Removes priority layer that match the passed identifier Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 565 566 567 568 569 570 571 572 573 574 575 576 def delete_priority_layer ( self , identifier ): \"\"\"Removes priority layer that match the passed identifier :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): if str ( priority_layer ) == str ( identifier ): settings . remove ( priority_layer )","title":"delete_priority_layer()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_priority_layers","text":"delete_priority_layers () Deletes all the plugin priority weighting layers settings. Source code in src/cplus_plugin/conf.py 557 558 559 560 561 562 563 def delete_priority_layers ( self ): \"\"\"Deletes all the plugin priority weighting layers settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for priority_layer in settings . childGroups (): settings . remove ( priority_layer )","title":"delete_priority_layers()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_settings","text":"delete_settings () Deletes the all the plugin settings. Source code in src/cplus_plugin/conf.py 238 239 240 def delete_settings ( self ): \"\"\"Deletes the all the plugin settings.\"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } \" )","title":"delete_settings()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_group_by_name","text":"find_group_by_name ( name ) Finds a priority group setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Name of the group required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 def find_group_by_name ( self , name ) -> typing . Dict : \"\"\"Finds a priority group setting inside the plugin QgsSettings by name. :param name: Name of the group :type name: str :returns: Priority group :rtype: typing.Dict \"\"\" found_id = None with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for group_id in settings . childGroups (): group_settings_key = self . _get_priority_groups_settings_base ( group_id ) with qgis_settings ( group_settings_key ) as group_settings_key : group_name = group_settings_key . value ( \"name\" ) if group_name == name : found_id = uuid . UUID ( group_id ) break return self . get_priority_group ( found_id )","title":"find_group_by_name()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_implementation_model_by_name","text":"find_implementation_model_by_name ( name ) Finds an implementation model setting inside the plugin QgsSettings that equals or matches the name. Parameters: Name Type Description Default name str Implementation model name required Returns: Type Description ImplementationModel Implementation model Source code in src/cplus_plugin/conf.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 def find_implementation_model_by_name ( self , name ) -> typing . Dict : \"\"\"Finds an implementation model setting inside the plugin QgsSettings that equals or matches the name. :param name: Implementation model name :type name: str :returns: Implementation model :rtype: ImplementationModel \"\"\" for model in self . get_all_implementation_models (): model_name = model . name trimmed_name = model_name . replace ( \" \" , \"_\" ) if model_name == name or model_name in name or trimmed_name in name : return model return None","title":"find_implementation_model_by_name()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_layer_by_name","text":"find_layer_by_name ( name ) Finds a priority layer setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Priority layers identifier required Returns: Type Description dict Priority layers dict Source code in src/cplus_plugin/conf.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def find_layer_by_name ( self , name ) -> typing . Dict : \"\"\"Finds a priority layer setting inside the plugin QgsSettings by name. :param name: Priority layers identifier :type name: str :returns: Priority layers dict :rtype: dict \"\"\" found_id = None with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): layer_settings_key = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( layer_settings_key ) as layer_settings : layer_name = layer_settings . value ( \"name\" ) if layer_name == name : found_id = uuid . UUID ( layer_id ) break return self . get_priority_layer ( found_id ) if found_id is not None else None","title":"find_layer_by_name()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_layers_by_group","text":"find_layers_by_group ( group ) Finds priority layers inside the plugin QgsSettings that contain the passed group. Parameters: Name Type Description Default group str Priority group name required Returns: Type Description list Priority layers list Source code in src/cplus_plugin/conf.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 def find_layers_by_group ( self , group ) -> typing . List : \"\"\"Finds priority layers inside the plugin QgsSettings that contain the passed group. :param group: Priority group name :type group: str :returns: Priority layers list :rtype: list \"\"\" layers = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : if group == group_settings . value ( \"name\" ): layers . append ( self . get_priority_layer ( layer_id )) return layers","title":"find_layers_by_group()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_settings","text":"find_settings ( name ) Returns the plugin setting keys from the plugin root group that matches the passed name Parameters: Name Type Description Default name str Setting name to search for required Returns: Type Description list List of the matching settings names Source code in src/cplus_plugin/conf.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def find_settings ( self , name ): \"\"\"Returns the plugin setting keys from the plugin root group that matches the passed name :param name: Setting name to search for :type name: str :returns result: List of the matching settings names :rtype result: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } \" ) as settings : for settings_name in settings . childKeys (): if name in settings_name : result . append ( settings_name ) return result","title":"find_settings()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_all_implementation_models","text":"get_all_implementation_models () Get all the implementation model objects stored in settings. Returns: Type Description list Returns all the implementation model objects. Source code in src/cplus_plugin/conf.py 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 def get_all_implementation_models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Get all the implementation model objects stored in settings. :returns: Returns all the implementation model objects. :rtype: list \"\"\" implementation_models = [] implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : keys = settings . childKeys () for k in keys : implementation_model = self . get_implementation_model ( k ) if implementation_model is not None : implementation_models . append ( implementation_model ) return sorted ( implementation_models , key = lambda imp_model : imp_model . name )","title":"get_all_implementation_models()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_all_ncs_pathways","text":"get_all_ncs_pathways () Get all the NCS pathway objects stored in settings. Returns: Type Description list Returns all the NCS pathway objects. Source code in src/cplus_plugin/conf.py 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 def get_all_ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Get all the NCS pathway objects stored in settings. :returns: Returns all the NCS pathway objects. :rtype: list \"\"\" ncs_pathways = [] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : keys = settings . childKeys () for k in keys : ncs_pathway = self . get_ncs_pathway ( k ) if ncs_pathway is not None : ncs_pathways . append ( ncs_pathway ) return sorted ( ncs_pathways , key = lambda ncs : ncs . name )","title":"get_all_ncs_pathways()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_implementation_model","text":"get_implementation_model ( implementation_model_uuid ) Gets an implementation model object matching the given unique identified. Parameters: Name Type Description Default implementation_model_uuid str Unique identifier for the implementation model object. required Returns: Type Description ImplementationModel Returns the implementation model object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 def get_implementation_model ( self , implementation_model_uuid : str ) -> typing . Union [ ImplementationModel , None ]: \"\"\"Gets an implementation model object matching the given unique identified. :param implementation_model_uuid: Unique identifier for the implementation model object. :type implementation_model_uuid: str :returns: Returns the implementation model object matching the given identifier else None if not found. :rtype: ImplementationModel \"\"\" implementation_model = None implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : implementation_model = settings . value ( implementation_model_uuid , None ) ncs_uuids = [] if implementation_model is not None : implementation_model_dict = {} try : implementation_model_dict = json . loads ( implementation_model ) except json . JSONDecodeError : log ( \"Implementation model JSON is invalid.\" ) if PATHWAYS_ATTRIBUTE in implementation_model_dict : ncs_uuids = implementation_model_dict [ PATHWAYS_ATTRIBUTE ] implementation_model = create_implementation_model ( implementation_model_dict ) if implementation_model is not None : for ncs_uuid in ncs_uuids : ncs = self . get_ncs_pathway ( ncs_uuid ) if ncs is not None : implementation_model . add_ncs_pathway ( ncs ) return implementation_model","title":"get_implementation_model()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_ncs_pathway","text":"get_ncs_pathway ( ncs_uuid ) Gets an NCS pathway object matching the given unique identified. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description NcsPathway Returns the NCS pathway object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 def get_ncs_pathway ( self , ncs_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Gets an NCS pathway object matching the given unique identified. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway object matching the given identifier else None if not found. :rtype: NcsPathway \"\"\" ncs_pathway = None ncs_dict = self . get_ncs_pathway_dict ( ncs_uuid ) if len ( ncs_dict ) == 0 : return None ncs_pathway = create_ncs_pathway ( ncs_dict ) return ncs_pathway","title":"get_ncs_pathway()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_ncs_pathway_dict","text":"get_ncs_pathway_dict ( ncs_uuid ) Gets an NCS pathway attribute values as a dictionary. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description dict Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. Source code in src/cplus_plugin/conf.py 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 def get_ncs_pathway_dict ( self , ncs_uuid : str ) -> dict : \"\"\"Gets an NCS pathway attribute values as a dictionary. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. :rtype: dict \"\"\" ncs_pathway_dict = {} ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : ncs_model = settings . value ( ncs_uuid , dict ()) if len ( ncs_model ) > 0 : try : ncs_pathway_dict = json . loads ( ncs_model ) except json . JSONDecodeError : log ( \"NCS pathway JSON is invalid\" ) return ncs_pathway_dict","title":"get_ncs_pathway_dict()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_group","text":"get_priority_group ( identifier ) Retrieves the priority group that matches the passed identifier. Parameters: Name Type Description Default identifier str Priority group identifier required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 def get_priority_group ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority group that matches the passed identifier. :param identifier: Priority group identifier :type identifier: str :returns: Priority group :rtype: typing.Dict \"\"\" if identifier is None : return None settings_key = self . _get_priority_groups_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : priority_group = { \"uuid\" : identifier } priority_group [ \"name\" ] = settings . value ( \"name\" ) priority_group [ \"value\" ] = settings . value ( \"value\" ) priority_group [ \"description\" ] = settings . value ( \"description\" ) return priority_group","title":"get_priority_group()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_groups","text":"get_priority_groups () Gets all the available priority groups in the plugin. Returns: Type Description list List of the priority groups instances Source code in src/cplus_plugin/conf.py 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 def get_priority_groups ( self ) -> typing . List [ typing . Dict ]: \"\"\"Gets all the available priority groups in the plugin. :returns: List of the priority groups instances :rtype: list \"\"\" priority_groups = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_groups_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : group = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"value\" : priority_settings . value ( \"value\" ), \"description\" : priority_settings . value ( \"description\" ), } priority_groups . append ( group ) return priority_groups","title":"get_priority_groups()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_layer","text":"get_priority_layer ( identifier ) Retrieves the priority layer that matches the passed identifier. Parameters: Name Type Description Default identifier uuid.UUID Priority layers identifier required Returns: Type Description dict Priority layer dict Source code in src/cplus_plugin/conf.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def get_priority_layer ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority layer that matches the passed identifier. :param identifier: Priority layers identifier :type identifier: uuid.UUID :returns: Priority layer dict :rtype: dict \"\"\" priority_layer = None settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : groups_key = f \" { settings_key } /groups\" groups = [] if len ( settings . childKeys ()) <= 0 : return priority_layer with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"uuid\" ] = group_settings . value ( \"uuid\" ) stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) priority_layer = { \"uuid\" : str ( identifier )} priority_layer [ \"name\" ] = settings . value ( \"name\" ) priority_layer [ \"description\" ] = settings . value ( \"description\" ) priority_layer [ \"path\" ] = settings . value ( \"path\" ) priority_layer [ \"selected\" ] = settings . value ( \"selected\" , type = bool ) priority_layer [ \"user_defined\" ] = settings . value ( \"user_defined\" , defaultValue = True , type = bool ) priority_layer [ \"groups\" ] = groups return priority_layer","title":"get_priority_layer()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_layers","text":"get_priority_layers () Gets all the available priority layers in the plugin. Returns: Type Description list Priority layers list Source code in src/cplus_plugin/conf.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 def get_priority_layers ( self ) -> typing . List : \"\"\"Gets all the available priority layers in the plugin. :returns: Priority layers list :rtype: list \"\"\" priority_layer_list = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" groups = [] with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"uuid\" ] = group_settings . value ( \"uuid\" ) stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) layer = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"description\" : priority_settings . value ( \"description\" ), \"path\" : priority_settings . value ( \"path\" ), \"selected\" : priority_settings . value ( \"selected\" , type = bool ), \"user_defined\" : priority_settings . value ( \"user_defined\" , defaultValue = True , type = bool ), \"groups\" : groups , } priority_layer_list . append ( layer ) return priority_layer_list","title":"get_priority_layers()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_scenario","text":"get_scenario ( scenario_id ) Retrieves the first scenario that matched the passed scenario id. Parameters: Name Type Description Default scenario_id str Scenario id required Returns: Type Description ScenarioSettings Scenario settings instance Source code in src/cplus_plugin/conf.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def get_scenario ( self , scenario_id ): \"\"\"Retrieves the first scenario that matched the passed scenario id. :param scenario_id: Scenario id :type scenario_id: str :returns: Scenario settings instance :rtype: ScenarioSettings \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : scenario = ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) if scenario . id == scenario_id : return scenario return None","title":"get_scenario()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_scenarios","text":"get_scenarios () Gets all the available scenarios settings in the plugin. Returns: Type Description list List of the scenario settings instances Source code in src/cplus_plugin/conf.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def get_scenarios ( self ): \"\"\"Gets all the available scenarios settings in the plugin. :returns: List of the scenario settings instances :rtype: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : scenario = ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) scenario . extent = self . get_scenario_ result . append ( ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) ) return result","title":"get_scenarios()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_value","text":"get_value ( name , default = None , setting_type = None ) Gets value of the setting with the passed name. Parameters: Name Type Description Default name str Name of setting key required default Any Default value returned when the setting key does not exist None setting_type Any Type of the store setting None Returns: Type Description Any Value of the setting Source code in src/cplus_plugin/conf.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def get_value ( self , name : str , default = None , setting_type = None ): \"\"\"Gets value of the setting with the passed name. :param name: Name of setting key :type name: str :param default: Default value returned when the setting key does not exist :type default: Any :param setting_type: Type of the store setting :type setting_type: Any :returns: Value of the setting :rtype: Any \"\"\" if setting_type : return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default , setting_type ) return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default )","title":"get_value()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove","text":"remove ( name ) Remove the setting with the specified name. Parameters: Name Type Description Default name str Name of the setting key required Source code in src/cplus_plugin/conf.py 230 231 232 233 234 235 236 def remove ( self , name ): \"\"\"Remove the setting with the specified name. :param name: Name of the setting key :type name: str \"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } / { name } \" )","title":"remove()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove_implementation_model","text":"remove_implementation_model ( implementation_model_uuid ) Removes an implementation model settings entry using the UUID. Parameters: Name Type Description Default implementation_model_uuid str Unique identifier of the implementation model entry to removed. required Source code in src/cplus_plugin/conf.py 1021 1022 1023 1024 1025 1026 1027 1028 1029 def remove_implementation_model ( self , implementation_model_uuid : str ): \"\"\"Removes an implementation model settings entry using the UUID. :param implementation_model_uuid: Unique identifier of the implementation model entry to removed. :type implementation_model_uuid: str \"\"\" if self . get_implementation_model ( implementation_model_uuid ) is not None : self . remove ( f \" { self . IMPLEMENTATION_MODEL_BASE } / { implementation_model_uuid } \" )","title":"remove_implementation_model()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove_ncs_pathway","text":"remove_ncs_pathway ( ncs_uuid ) Removes an NCS pathway settings entry using the UUID. Parameters: Name Type Description Default ncs_uuid str Unique identifier of the NCS pathway entry to removed. required Source code in src/cplus_plugin/conf.py 842 843 844 845 846 847 848 849 850 def remove_ncs_pathway ( self , ncs_uuid : str ): \"\"\"Removes an NCS pathway settings entry using the UUID. :param ncs_uuid: Unique identifier of the NCS pathway entry to removed. :type ncs_uuid: str \"\"\" if self . get_ncs_pathway ( ncs_uuid ) is not None : self . remove ( f \" { self . NCS_PATHWAY_BASE } / { ncs_uuid } \" )","title":"remove_ncs_pathway()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_implementation_model","text":"save_implementation_model ( implementation_model ) Saves an implementation model object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default implementation_model Union [ ImplementationModel , dict ] Implementation model object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 def save_implementation_model ( self , implementation_model : typing . Union [ ImplementationModel , dict ] ): \"\"\"Saves an implementation model object serialized to a json string indexed by the UUID. :param implementation_model: Implementation model object or attribute values in a dictionary which are then serialized to a JSON string. :type implementation_model: ImplementationModel, dict \"\"\" if isinstance ( implementation_model , ImplementationModel ): priority_layers = implementation_model . priority_layers layer_styles = implementation_model . layer_styles style_pixel_value = implementation_model . style_pixel_value ncs_pathways = [] for ncs in implementation_model . pathways : ncs_pathways . append ( str ( ncs . uuid )) implementation_model = layer_component_to_dict ( implementation_model ) implementation_model [ PRIORITY_LAYERS_SEGMENT ] = priority_layers implementation_model [ PATHWAYS_ATTRIBUTE ] = ncs_pathways implementation_model [ STYLE_ATTRIBUTE ] = layer_styles implementation_model [ PIXEL_VALUE_ATTRIBUTE ] = style_pixel_value if isinstance ( implementation_model , dict ): priority_layers = [] if implementation_model . get ( \"pwls_ids\" ) is not None : for layer_id in implementation_model . get ( \"pwls_ids\" , []): layer = self . get_priority_layer ( layer_id ) priority_layers . append ( layer ) if len ( priority_layers ) > 0 : implementation_model [ PRIORITY_LAYERS_SEGMENT ] = priority_layers implementation_model_str = json . dumps ( implementation_model ) implementation_model_uuid = implementation_model [ UUID_ATTRIBUTE ] implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : settings . setValue ( implementation_model_uuid , implementation_model_str )","title":"save_implementation_model()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_ncs_pathway","text":"save_ncs_pathway ( ncs_pathway ) Saves an NCS pathway object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default ncs_pathway Union [ NcsPathway , dict ] NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 def save_ncs_pathway ( self , ncs_pathway : typing . Union [ NcsPathway , dict ]): \"\"\"Saves an NCS pathway object serialized to a json string indexed by the UUID. :param ncs_pathway: NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. :type ncs_pathway: NcsPathway, dict \"\"\" if isinstance ( ncs_pathway , NcsPathway ): ncs_pathway = ncs_pathway_to_dict ( ncs_pathway ) ncs_str = json . dumps ( ncs_pathway ) ncs_uuid = ncs_pathway [ UUID_ATTRIBUTE ] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : settings . setValue ( ncs_uuid , ncs_str )","title":"save_ncs_pathway()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_priority_group","text":"save_priority_group ( priority_group ) Save the priority group into the plugin settings Parameters: Name Type Description Default priority_group str Priority group required Source code in src/cplus_plugin/conf.py 662 663 664 665 666 667 668 669 670 671 672 673 674 def save_priority_group ( self , priority_group ): \"\"\"Save the priority group into the plugin settings :param priority_group: Priority group :type priority_group: str \"\"\" settings_key = self . _get_priority_groups_settings_base ( priority_group [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"name\" , priority_group [ \"name\" ]) settings . setValue ( \"value\" , priority_group [ \"value\" ]) settings . setValue ( \"description\" , priority_group . get ( \"description\" ))","title":"save_priority_group()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_priority_layer","text":"save_priority_layer ( priority_layer ) Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal Parameters: Name Type Description Default priority_layer dict Priority layer required Source code in src/cplus_plugin/conf.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 def save_priority_layer ( self , priority_layer ): \"\"\"Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal :param priority_layer: Priority layer :type priority_layer: dict \"\"\" settings_key = self . _get_priority_layers_settings_base ( priority_layer [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : groups = priority_layer . get ( \"groups\" , []) settings . setValue ( \"name\" , priority_layer [ \"name\" ]) settings . setValue ( \"description\" , priority_layer [ \"description\" ]) settings . setValue ( \"path\" , priority_layer [ \"path\" ]) settings . setValue ( \"selected\" , priority_layer . get ( \"selected\" , False )) settings . setValue ( \"user_defined\" , priority_layer . get ( \"user_defined\" , True )) groups_key = f \" { settings_key } /groups\" with qgis_settings ( groups_key ) as groups_settings : for group_id in groups_settings . childGroups (): groups_settings . remove ( group_id ) for group in groups : group_key = f \" { groups_key } / { group [ 'name' ] } \" with qgis_settings ( group_key ) as group_settings : group_settings . setValue ( \"uuid\" , group . get ( \"uuid\" )) group_settings . setValue ( \"name\" , group [ \"name\" ]) group_settings . setValue ( \"value\" , group [ \"value\" ]) self . priority_layers_changed . emit ()","title":"save_priority_layer()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_scenario","text":"save_scenario ( scenario_settings ) Save the passed scenario settings into the plugin settings Parameters: Name Type Description Default scenario_settings ScenarioSettings Scenario settings required Source code in src/cplus_plugin/conf.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def save_scenario ( self , scenario_settings ): \"\"\"Save the passed scenario settings into the plugin settings :param scenario_settings: Scenario settings :type scenario_settings: ScenarioSettings \"\"\" settings_key = self . _get_scenario_settings_base ( scenario_settings . uuid ) self . save_scenario_extent ( settings_key , scenario_settings . extent ) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"name\" , scenario_settings . name ) settings . setValue ( \"description\" , scenario_settings . description ) settings . setValue ( \"uuid\" , scenario_settings . uuid )","title":"save_scenario()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_scenario_extent","text":"save_scenario_extent ( key , extent ) Saves the scenario extent into plugin settings using the provided settings group key. Parameters: Name Type Description Default key SpatialExtent Scenario extent required extent str Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key QgsSettings group key required Source code in src/cplus_plugin/conf.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def save_scenario_extent ( self , key , extent ): \"\"\"Saves the scenario extent into plugin settings using the provided settings group key. :param key: Scenario extent :type key: SpatialExtent :param extent: QgsSettings group key :type extent: str Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key \"\"\" spatial_extent = extent . spatial . bbox spatial_key = f \" { key } /extent/spatial/\" with qgis_settings ( spatial_key ) as settings : settings . setValue ( \"bbox\" , spatial_extent )","title":"save_scenario_extent()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.set_current_priority_layer","text":"set_current_priority_layer ( identifier ) Set current priority layer Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 def set_current_priority_layer ( self , identifier ): \"\"\"Set current priority layer :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as layer_settings : layer_settings . setValue ( \"selected\" , str ( priority_layer ) == str ( identifier ) )","title":"set_current_priority_layer()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.set_value","text":"set_value ( name , value ) Adds a new setting key and value on the plugin specific settings. Parameters: Name Type Description Default name str Name of setting key required value Any Value of the setting required Source code in src/cplus_plugin/conf.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def set_value ( self , name : str , value ): \"\"\"Adds a new setting key and value on the plugin specific settings. :param name: Name of setting key :type name: str :param value: Value of the setting :type value: Any \"\"\" self . settings . setValue ( f \" { self . BASE_GROUP_NAME } / { name } \" , value ) if isinstance ( name , Settings ): name = name . value self . settings_updated . emit ( name , value )","title":"set_value()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_implementation_model","text":"update_implementation_model ( implementation_model ) Updates the attributes of the Implementation object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. Parameters: Name Type Description Default implementation_model ImplementationModel ImplementationModel object to be updated. required Source code in src/cplus_plugin/conf.py 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 def update_implementation_model ( self , implementation_model : ImplementationModel ): \"\"\"Updates the attributes of the Implementation object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. :param implementation_model: ImplementationModel object to be updated. :type implementation_model: ImplementationModel \"\"\" base_dir = self . get_value ( Settings . BASE_DIR ) if base_dir : # PWLs path update for layer in implementation_model . priority_layers : if layer in PRIORITY_LAYERS and base_dir not in layer . get ( PATH_ATTRIBUTE ): abs_pwl_path = ( f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } /\" f \" { layer . get ( PATH_ATTRIBUTE ) } \" ) abs_pwl_path = str ( os . path . normpath ( abs_pwl_path )) layer [ PATH_ATTRIBUTE ] = abs_pwl_path # Remove then re-insert self . remove_implementation_model ( str ( implementation_model . uuid )) self . save_implementation_model ( implementation_model )","title":"update_implementation_model()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_implementation_models","text":"update_implementation_models () Updates the attributes of the avaialable implementation models Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model object to be updated. required Source code in src/cplus_plugin/conf.py 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 def update_implementation_models ( self ): \"\"\"Updates the attributes of the avaialable implementation models :param implementation_model: Implementation model object to be updated. :type implementation_model: ImplementationModel \"\"\" models = self . get_all_implementation_models () for implementation_model in models : self . update_implementation_model ( implementation_model )","title":"update_implementation_models()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_ncs_pathway","text":"update_ncs_pathway ( ncs_pathway ) Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be updated. required Source code in src/cplus_plugin/conf.py 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 def update_ncs_pathway ( self , ncs_pathway : NcsPathway ): \"\"\"Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. :param ncs_pathway: NCS pathway object to be updated. :type ncs_pathway: NcsPathway \"\"\" base_dir = self . get_value ( Settings . BASE_DIR ) if not base_dir : return # Pathway location for default pathway if not ncs_pathway . user_defined : p = Path ( ncs_pathway . path ) # Only update if path does not exist otherwise # fallback to check under base directory. if not p . exists (): abs_path = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } /\" f \" { p . name } \" abs_path = str ( os . path . normpath ( abs_path )) ncs_pathway . path = abs_path # Carbon location abs_carbon_paths = [] for cb_path in ncs_pathway . carbon_paths : cp = Path ( cb_path ) # Similarly, if the given carbon path does not exist then try # to use the default one in the ncs_carbon directory. if not cp . exists (): abs_carbon_path = f \" { base_dir } / { NCS_CARBON_SEGMENT } /\" f \" { cp . name } \" abs_carbon_path = str ( os . path . normpath ( abs_carbon_path )) abs_carbon_paths . append ( abs_carbon_path ) else : abs_carbon_paths . append ( cb_path ) ncs_pathway . carbon_paths = abs_carbon_paths # Remove then re-insert self . remove_ncs_pathway ( str ( ncs_pathway . uuid )) self . save_ncs_pathway ( ncs_pathway )","title":"update_ncs_pathway()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_ncs_pathways","text":"update_ncs_pathways () Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. Source code in src/cplus_plugin/conf.py 787 788 789 790 791 792 793 794 795 796 def update_ncs_pathways ( self ): \"\"\"Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. \"\"\" ncs_pathways = self . get_all_ncs_pathways () for ncs in ncs_pathways : self . update_ncs_pathway ( ncs )","title":"update_ncs_pathways()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.qgis_settings","text":"qgis_settings ( group_root , settings = None ) Context manager to help defining groups when creating QgsSettings. :yields: Instance of the created settings :ytype: QgsSettings Parameters: Name Type Description Default group_root str Name of the root group for the settings required settings QgsSettings QGIS settings to use None Source code in src/cplus_plugin/conf.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @contextlib . contextmanager def qgis_settings ( group_root : str , settings = None ): \"\"\"Context manager to help defining groups when creating QgsSettings. :param group_root: Name of the root group for the settings :type group_root: str :param settings: QGIS settings to use :type settings: QgsSettings :yields: Instance of the created settings :ytype: QgsSettings \"\"\" if settings is None : settings = QgsSettings () settings . beginGroup ( group_root ) try : yield settings finally : settings . endGroup ()","title":"qgis_settings()"},{"location":"developer/api/core/api_main/","text":"Main QGIS CPLUS Plugin Implementation. Source code in src/cplus_plugin/main.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , iface ): self . iface = iface self . plugin_dir = os . path . dirname ( __file__ ) locale = QgsSettings () . value ( \"locale/userLocale\" )[ 0 : 2 ] locale_path = os . path . join ( self . plugin_dir , \"i18n\" , \"CPLUS {} .qm\" . format ( locale )) if os . path . exists ( locale_path ): self . translator = QTranslator () self . translator . load ( locale_path ) QCoreApplication . installTranslator ( self . translator ) # Declare instance attributes self . actions = [] self . pluginIsActive = False self . menu = QMenu ( \"&CPLUS\" ) self . menu . setIcon ( QIcon ( ICON_PATH )) self . raster_menu = self . iface . rasterMenu () self . raster_menu . addMenu ( self . menu ) self . toolbar = self . iface . addToolBar ( \"Open CPLUS\" ) self . toolbar . setObjectName ( \"CPLUS\" ) self . toolButton = QToolButton () self . toolButton . setMenu ( QMenu ()) self . toolButton . setPopupMode ( QToolButton . MenuButtonPopup ) self . toolBtnAction = self . toolbar . addWidget ( self . toolButton ) self . actions . append ( self . toolBtnAction ) create_priority_layers () initialize_model_settings () # Initialize default report settings initialize_report_settings () self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . options_factory = None add_action add_action ( icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None ) Add a toolbar icon to the toolbar. Parameters: Name Type Description Default icon_path str Path to the icon for this action required text str Text that should be shown in menu items for this action required callback function Function to be called when the action is triggered required enabled_flag bool A flag indicating if the action should be enabled True add_to_menu bool Flag indicating whether the action should also be added to the menu True add_to_web_menu bool Flag indicating whether the action should also be added to the web menu True add_to_toolbar bool Flag indicating whether the action should also be added to the toolbar True set_as_default_action bool Flag indicating whether the action is the default action False status_tip str Optional text to show in a popup when mouse pointer hovers over the action None parent QWidget Parent widget for the new action None whats_this str Optional text to show in the status bar when the mouse pointer hovers over the action None Returns: Type Description QAction The action that was created Source code in src/cplus_plugin/main.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def add_action ( self , icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None , ): \"\"\"Add a toolbar icon to the toolbar. :param icon_path: Path to the icon for this action :type icon_path: str :param text: Text that should be shown in menu items for this action :type text: str :param callback: Function to be called when the action is triggered :type callback: function :param enabled_flag: A flag indicating if the action should be enabled :type enabled_flag: bool :param add_to_menu: Flag indicating whether the action should also be added to the menu :type add_to_menu: bool :param add_to_web_menu: Flag indicating whether the action should also be added to the web menu :type add_to_web_menu: bool :param add_to_toolbar: Flag indicating whether the action should also be added to the toolbar :type add_to_toolbar: bool :param set_as_default_action: Flag indicating whether the action is the default action :type set_as_default_action: bool :param status_tip: Optional text to show in a popup when mouse pointer hovers over the action :type status_tip: str :param parent: Parent widget for the new action :type parent: QWidget :param whats_this: Optional text to show in the status bar when the mouse pointer hovers over the action :type whats_this: str :returns: The action that was created :rtype: QAction \"\"\" icon = QIcon ( icon_path ) action = QAction ( icon , text , parent ) action . triggered . connect ( callback ) action . setEnabled ( enabled_flag ) if status_tip is not None : action . setStatusTip ( status_tip ) if whats_this is not None : action . setWhatsThis ( whats_this ) if add_to_menu : self . menu . addAction ( action ) # If we want to read this # if add_to_web_menu: # self.iface.addPluginToWebMenu(self.menu, action) if add_to_toolbar : self . toolButton . menu () . addAction ( action ) if set_as_default_action : self . toolButton . setDefaultAction ( action ) if add_to_menu : self . menu . addAction ( action ) self . actions . append ( action ) return action initGui initGui () Create the menu entries and toolbar icons inside the QGIS GUI. Source code in src/cplus_plugin/main.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def initGui ( self ): \"\"\"Create the menu entries and toolbar icons inside the QGIS GUI.\"\"\" self . add_action ( ICON_PATH , text = self . tr ( \"CPLUS\" ), callback = self . run , parent = self . iface . mainWindow (), set_as_default_action = True , ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"settings.svg\" ), text = self . tr ( \"Settings\" ), callback = self . run_settings , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Settings\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"mActionHelpContents_green.svg\" ), text = self . tr ( \"Help\" ), callback = self . open_help , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Help\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"info_green.svg\" ), text = self . tr ( \"About\" ), callback = self . open_about , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS About\" ), ) # Adds the settings to the QGIS options panel self . options_factory = CplusOptionsFactory () self . iface . registerOptionsWidgetFactory ( self . options_factory ) # Register custom layout items self . register_layout_items () # Register custom report variables when a layout is opened self . iface . layoutDesignerOpened . connect ( self . on_layout_designer_opened ) onClosePlugin onClosePlugin () Cleanup necessary items here when plugin widget is closed. Source code in src/cplus_plugin/main.py 267 268 269 def onClosePlugin ( self ): \"\"\"Cleanup necessary items here when plugin widget is closed.\"\"\" self . pluginIsActive = False on_layout_designer_opened on_layout_designer_opened ( designer ) Register custom report variables in a print layout only. Source code in src/cplus_plugin/main.py 299 300 301 302 303 304 def on_layout_designer_opened ( self , designer : QgsLayoutDesignerInterface ): \"\"\"Register custom report variables in a print layout only.\"\"\" layout_type = designer . masterLayout () . layoutType () if layout_type == QgsMasterLayoutInterface . PrintLayout : layout = designer . layout () report_manager . register_variables ( layout ) open_about open_about () Opens the about documentation for the plugin in a browser Source code in src/cplus_plugin/main.py 322 323 324 def open_about ( self ): \"\"\"Opens the about documentation for the plugin in a browser\"\"\" open_documentation ( ABOUT_DOCUMENTATION_SITE ) open_help open_help () Opens documentation home page for the plugin in a browser Source code in src/cplus_plugin/main.py 318 319 320 def open_help ( self ): \"\"\"Opens documentation home page for the plugin in a browser\"\"\" open_documentation ( DOCUMENTATION_SITE ) register_layout_items register_layout_items () Register custom layout items. Source code in src/cplus_plugin/main.py 306 307 308 309 310 311 312 313 314 315 316 def register_layout_items ( self ): \"\"\"Register custom layout items.\"\"\" # Register map layout item QgsApplication . layoutItemRegistry () . addLayoutItemType ( CplusMapRepeatItemLayoutItemMetadata () ) # Register map GUI metadata item_gui_registry = QgsGui . layoutItemGuiRegistry () map_item_gui_metadata = CplusMapLayoutItemGuiMetadata () item_gui_registry . addLayoutItemGuiMetadata ( map_item_gui_metadata ) run run () Creates the main widget for the plugin. Source code in src/cplus_plugin/main.py 282 283 284 285 286 287 288 289 290 291 292 293 def run ( self ): \"\"\"Creates the main widget for the plugin.\"\"\" if self . main_widget is None : self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . iface . addDockWidget ( Qt . RightDockWidgetArea , self . main_widget ) self . main_widget . show () if not self . pluginIsActive : self . pluginIsActive = True run_settings run_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/main.py 295 296 297 def run_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE ) tr tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message str String for translation required Returns: Type Description QString Translated version of the message Source code in src/cplus_plugin/main.py 124 125 126 127 128 129 130 131 132 133 134 135 def tr ( self , message ) -> str : \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation :type message: str :returns: Translated version of the message :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QCoreApplication . translate ( \"CPLUS\" , message ) unload unload () Removes the plugin menu item and icon from QGIS GUI. Source code in src/cplus_plugin/main.py 271 272 273 274 275 276 277 278 279 280 def unload ( self ): \"\"\"Removes the plugin menu item and icon from QGIS GUI.\"\"\" try : for action in self . actions : self . iface . removePluginMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removePluginWebMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removeToolBarIcon ( action ) except Exception as e : pass","title":"Main"},{"location":"developer/api/core/api_main/#main","text":"QGIS CPLUS Plugin Implementation. Source code in src/cplus_plugin/main.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , iface ): self . iface = iface self . plugin_dir = os . path . dirname ( __file__ ) locale = QgsSettings () . value ( \"locale/userLocale\" )[ 0 : 2 ] locale_path = os . path . join ( self . plugin_dir , \"i18n\" , \"CPLUS {} .qm\" . format ( locale )) if os . path . exists ( locale_path ): self . translator = QTranslator () self . translator . load ( locale_path ) QCoreApplication . installTranslator ( self . translator ) # Declare instance attributes self . actions = [] self . pluginIsActive = False self . menu = QMenu ( \"&CPLUS\" ) self . menu . setIcon ( QIcon ( ICON_PATH )) self . raster_menu = self . iface . rasterMenu () self . raster_menu . addMenu ( self . menu ) self . toolbar = self . iface . addToolBar ( \"Open CPLUS\" ) self . toolbar . setObjectName ( \"CPLUS\" ) self . toolButton = QToolButton () self . toolButton . setMenu ( QMenu ()) self . toolButton . setPopupMode ( QToolButton . MenuButtonPopup ) self . toolBtnAction = self . toolbar . addWidget ( self . toolButton ) self . actions . append ( self . toolBtnAction ) create_priority_layers () initialize_model_settings () # Initialize default report settings initialize_report_settings () self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . options_factory = None","title":"Main"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.add_action","text":"add_action ( icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None ) Add a toolbar icon to the toolbar. Parameters: Name Type Description Default icon_path str Path to the icon for this action required text str Text that should be shown in menu items for this action required callback function Function to be called when the action is triggered required enabled_flag bool A flag indicating if the action should be enabled True add_to_menu bool Flag indicating whether the action should also be added to the menu True add_to_web_menu bool Flag indicating whether the action should also be added to the web menu True add_to_toolbar bool Flag indicating whether the action should also be added to the toolbar True set_as_default_action bool Flag indicating whether the action is the default action False status_tip str Optional text to show in a popup when mouse pointer hovers over the action None parent QWidget Parent widget for the new action None whats_this str Optional text to show in the status bar when the mouse pointer hovers over the action None Returns: Type Description QAction The action that was created Source code in src/cplus_plugin/main.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def add_action ( self , icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None , ): \"\"\"Add a toolbar icon to the toolbar. :param icon_path: Path to the icon for this action :type icon_path: str :param text: Text that should be shown in menu items for this action :type text: str :param callback: Function to be called when the action is triggered :type callback: function :param enabled_flag: A flag indicating if the action should be enabled :type enabled_flag: bool :param add_to_menu: Flag indicating whether the action should also be added to the menu :type add_to_menu: bool :param add_to_web_menu: Flag indicating whether the action should also be added to the web menu :type add_to_web_menu: bool :param add_to_toolbar: Flag indicating whether the action should also be added to the toolbar :type add_to_toolbar: bool :param set_as_default_action: Flag indicating whether the action is the default action :type set_as_default_action: bool :param status_tip: Optional text to show in a popup when mouse pointer hovers over the action :type status_tip: str :param parent: Parent widget for the new action :type parent: QWidget :param whats_this: Optional text to show in the status bar when the mouse pointer hovers over the action :type whats_this: str :returns: The action that was created :rtype: QAction \"\"\" icon = QIcon ( icon_path ) action = QAction ( icon , text , parent ) action . triggered . connect ( callback ) action . setEnabled ( enabled_flag ) if status_tip is not None : action . setStatusTip ( status_tip ) if whats_this is not None : action . setWhatsThis ( whats_this ) if add_to_menu : self . menu . addAction ( action ) # If we want to read this # if add_to_web_menu: # self.iface.addPluginToWebMenu(self.menu, action) if add_to_toolbar : self . toolButton . menu () . addAction ( action ) if set_as_default_action : self . toolButton . setDefaultAction ( action ) if add_to_menu : self . menu . addAction ( action ) self . actions . append ( action ) return action","title":"add_action()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.initGui","text":"initGui () Create the menu entries and toolbar icons inside the QGIS GUI. Source code in src/cplus_plugin/main.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def initGui ( self ): \"\"\"Create the menu entries and toolbar icons inside the QGIS GUI.\"\"\" self . add_action ( ICON_PATH , text = self . tr ( \"CPLUS\" ), callback = self . run , parent = self . iface . mainWindow (), set_as_default_action = True , ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"settings.svg\" ), text = self . tr ( \"Settings\" ), callback = self . run_settings , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Settings\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"mActionHelpContents_green.svg\" ), text = self . tr ( \"Help\" ), callback = self . open_help , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Help\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"info_green.svg\" ), text = self . tr ( \"About\" ), callback = self . open_about , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS About\" ), ) # Adds the settings to the QGIS options panel self . options_factory = CplusOptionsFactory () self . iface . registerOptionsWidgetFactory ( self . options_factory ) # Register custom layout items self . register_layout_items () # Register custom report variables when a layout is opened self . iface . layoutDesignerOpened . connect ( self . on_layout_designer_opened )","title":"initGui()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.onClosePlugin","text":"onClosePlugin () Cleanup necessary items here when plugin widget is closed. Source code in src/cplus_plugin/main.py 267 268 269 def onClosePlugin ( self ): \"\"\"Cleanup necessary items here when plugin widget is closed.\"\"\" self . pluginIsActive = False","title":"onClosePlugin()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.on_layout_designer_opened","text":"on_layout_designer_opened ( designer ) Register custom report variables in a print layout only. Source code in src/cplus_plugin/main.py 299 300 301 302 303 304 def on_layout_designer_opened ( self , designer : QgsLayoutDesignerInterface ): \"\"\"Register custom report variables in a print layout only.\"\"\" layout_type = designer . masterLayout () . layoutType () if layout_type == QgsMasterLayoutInterface . PrintLayout : layout = designer . layout () report_manager . register_variables ( layout )","title":"on_layout_designer_opened()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.open_about","text":"open_about () Opens the about documentation for the plugin in a browser Source code in src/cplus_plugin/main.py 322 323 324 def open_about ( self ): \"\"\"Opens the about documentation for the plugin in a browser\"\"\" open_documentation ( ABOUT_DOCUMENTATION_SITE )","title":"open_about()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.open_help","text":"open_help () Opens documentation home page for the plugin in a browser Source code in src/cplus_plugin/main.py 318 319 320 def open_help ( self ): \"\"\"Opens documentation home page for the plugin in a browser\"\"\" open_documentation ( DOCUMENTATION_SITE )","title":"open_help()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.register_layout_items","text":"register_layout_items () Register custom layout items. Source code in src/cplus_plugin/main.py 306 307 308 309 310 311 312 313 314 315 316 def register_layout_items ( self ): \"\"\"Register custom layout items.\"\"\" # Register map layout item QgsApplication . layoutItemRegistry () . addLayoutItemType ( CplusMapRepeatItemLayoutItemMetadata () ) # Register map GUI metadata item_gui_registry = QgsGui . layoutItemGuiRegistry () map_item_gui_metadata = CplusMapLayoutItemGuiMetadata () item_gui_registry . addLayoutItemGuiMetadata ( map_item_gui_metadata )","title":"register_layout_items()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.run","text":"run () Creates the main widget for the plugin. Source code in src/cplus_plugin/main.py 282 283 284 285 286 287 288 289 290 291 292 293 def run ( self ): \"\"\"Creates the main widget for the plugin.\"\"\" if self . main_widget is None : self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . iface . addDockWidget ( Qt . RightDockWidgetArea , self . main_widget ) self . main_widget . show () if not self . pluginIsActive : self . pluginIsActive = True","title":"run()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.run_settings","text":"run_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/main.py 295 296 297 def run_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE )","title":"run_settings()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.tr","text":"tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message str String for translation required Returns: Type Description QString Translated version of the message Source code in src/cplus_plugin/main.py 124 125 126 127 128 129 130 131 132 133 134 135 def tr ( self , message ) -> str : \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation :type message: str :returns: Translated version of the message :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QCoreApplication . translate ( \"CPLUS\" , message )","title":"tr()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.unload","text":"unload () Removes the plugin menu item and icon from QGIS GUI. Source code in src/cplus_plugin/main.py 271 272 273 274 275 276 277 278 279 280 def unload ( self ): \"\"\"Removes the plugin menu item and icon from QGIS GUI.\"\"\" try : for action in self . actions : self . iface . removePluginMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removePluginWebMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removeToolBarIcon ( action ) except Exception as e : pass","title":"unload()"},{"location":"developer/api/core/api_pilot_extent/","text":"Pilot Extent Check Checks if a given extent is within the pilot area of interest. extent_within_pilot extent_within_pilot ( new_extent , source_crs = None ) Checks if the extent is within the pilot area. Parameters: Name Type Description Default new_extent QgsRectangle Extent to check if within the pilot area. required source_crs QgsCoordinateReferenceSystem Source coordinate reference system, if not specified then it will default to the project reference system. It reproject to WGS84 which is what is used for the pilot extent. None Returns: Type Description bool True if the current map canvas extent is within the pilot area, else False. Source code in src/cplus_plugin/lib/extent_check.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def extent_within_pilot ( new_extent : QgsRectangle , source_crs : QgsCoordinateReferenceSystem = None ) -> bool : \"\"\"Checks if the extent is within the pilot area. :param new_extent: Extent to check if within the pilot area. :type new_extent: QgsRectangle :param source_crs: Source coordinate reference system, if not specified then it will default to the project reference system. It reproject to WGS84 which is what is used for the pilot extent. :type source_crs: QgsCoordinateReferenceSystem :returns: True if the current map canvas extent is within the pilot area, else False. :rtype: bool \"\"\" if source_crs is None : source_crs = QgsProject . instance () . crs () extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] pilot_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) default_crs = QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) if default_crs != source_crs : coordinate_xform = QgsCoordinateTransform ( source_crs , default_crs , QgsProject . instance () ) new_extent = coordinate_xform . transformBoundingBox ( new_extent ) return pilot_extent . contains ( new_extent )","title":"Extents"},{"location":"developer/api/core/api_pilot_extent/#pilot-extent-check","text":"Checks if a given extent is within the pilot area of interest.","title":"Pilot Extent Check"},{"location":"developer/api/core/api_pilot_extent/#src.cplus_plugin.lib.extent_check.extent_within_pilot","text":"extent_within_pilot ( new_extent , source_crs = None ) Checks if the extent is within the pilot area. Parameters: Name Type Description Default new_extent QgsRectangle Extent to check if within the pilot area. required source_crs QgsCoordinateReferenceSystem Source coordinate reference system, if not specified then it will default to the project reference system. It reproject to WGS84 which is what is used for the pilot extent. None Returns: Type Description bool True if the current map canvas extent is within the pilot area, else False. Source code in src/cplus_plugin/lib/extent_check.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def extent_within_pilot ( new_extent : QgsRectangle , source_crs : QgsCoordinateReferenceSystem = None ) -> bool : \"\"\"Checks if the extent is within the pilot area. :param new_extent: Extent to check if within the pilot area. :type new_extent: QgsRectangle :param source_crs: Source coordinate reference system, if not specified then it will default to the project reference system. It reproject to WGS84 which is what is used for the pilot extent. :type source_crs: QgsCoordinateReferenceSystem :returns: True if the current map canvas extent is within the pilot area, else False. :rtype: bool \"\"\" if source_crs is None : source_crs = QgsProject . instance () . crs () extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] pilot_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) default_crs = QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) if default_crs != source_crs : coordinate_xform = QgsCoordinateTransform ( source_crs , default_crs , QgsProject . instance () ) new_extent = coordinate_xform . transformBoundingBox ( new_extent ) return pilot_extent . contains ( new_extent )","title":"extent_within_pilot()"},{"location":"developer/api/core/api_reports_generator/","text":"Report Generator CPLUS Report generator. ReportGenerator ReportGenerator ( context , feedback = None ) Generator for CPLUS reports. Source code in src/cplus_plugin/lib/reports/generator.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def __init__ ( self , context : ReportContext , feedback : QgsFeedback = None ): self . _context = context self . _feedback = context . feedback or feedback self . _error_messages : typing . List [ str ] = [] self . _error_occured = False self . _layout = None self . _project = None self . _variable_register = LayoutVariableRegister () self . _report_output_dir = \"\" self . _output_layout_path = \"\" self . _repeat_page = None self . _repeat_page_num = - 1 self . _repeat_item = None self . _reference_layer_group = None self . _scenario_layer = None self . _area_processing_feedback = None self . _implementation_models_area = {} self . _pixel_area_info = {} if self . _feedback : self . _feedback . canceled . connect ( self . _on_feedback_cancelled ) self . _area_calculation_progress_reference = 0 self . _area_calculation_step_increment = 0 context property context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator. feedback property feedback Returns the feedback object for process update and cancellation. Returns: Type Description QgsFeedback Feedback object or None if not specified. layout property layout Returns the layout object used to generate the report. Returns: Type Description QgsPrintLayout The layout object used to generate the report or None if the process was not successful. output_dir property output_dir Creates, if it does not exist, the output directory where the analysis reports will be saved. This is relative to the base directory and scenario output sub-folder. Returns: Type Description str Output directory where the analysis reports will be saved. output_layout_path property output_layout_path Absolute path to a temporary file containing the layout as a QPT file. When this object is used within a QgsTask, it is recommended to use this layout path to reconstruct the layout rather calling the layout attribute since it was created in a separate thread. Returns: Type Description str Path to the layout template file. repeat_page property repeat_page Returns the page item that will be repeated based on the number of implementation models in the scenario. A repeat page is a layout page item that contains the first instance of a CplusMapRepeatItem. Returns: Type Description QgsLayoutItemPage Page item containing a CplusMapRepeatItem or None if not found. duplicate_repeat_page duplicate_repeat_page ( position ) Duplicates the repeat page and adds it to the layout at the given position. Parameters: Name Type Description Default position int Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. required Returns: Type Description bool True if the page was successfully duplicated else False. Source code in src/cplus_plugin/lib/reports/generator.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def duplicate_repeat_page ( self , position : int ) -> bool : \"\"\"Duplicates the repeat page and adds it to the layout at the given position. :param position: Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. :type position: int :returns: True if the page was successfully duplicated else False. :rtype: bool \"\"\" if self . _repeat_page is None : return False if self . _layout is None : return False if self . _repeat_page_num == - 1 : tr_msg = \"Repeat page not found in page collection\" self . _error_messages . append ( tr_msg ) return False new_page = QgsLayoutItemPage ( self . _layout ) new_page . attemptResize ( self . _repeat_page . sizeWithUnits ()) new_page . setPageStyleSymbol ( self . _repeat_page . pageStyleSymbol () . clone ()) # Insert empty repeat page at the given position if position < self . _layout . pageCollection () . pageCount (): self . _layout . pageCollection () . insertPage ( new_page , position ) else : # Add at the end position = self . _layout . pageCollection () . pageCount () self . _layout . pageCollection () . addPage ( new_page ) doc = QtXml . QDomDocument () el = doc . createElement ( \"CopyItems\" ) ctx = QgsReadWriteContext () repeat_page_items = self . _layout . pageCollection () . itemsOnPage ( self . _repeat_page_num ) for item in repeat_page_items : item . writeXml ( el , doc , ctx ) doc . appendChild ( el ) # Clear element identifier references nodes = doc . elementsByTagName ( \"LayoutItem\" ) for n in range ( nodes . count ()): node = nodes . at ( n ) if node . isElement (): node . toElement () . removeAttribute ( \"uuid\" ) page_ref_point = self . _layout . pageCollection () . pagePositionToLayoutPosition ( position , QgsLayoutPoint ( 0 , 0 ) ) _ = self . _layout . addItemsFromXml ( el , doc , ctx , page_ref_point , True ) return True export_to_pdf export_to_pdf () Exports the layout to a PDF file in the output directory using the layout name as the file name. Returns: Type Description bool True if the layout was successfully exported else False. Source code in src/cplus_plugin/lib/reports/generator.py 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 def export_to_pdf ( self ) -> bool : \"\"\"Exports the layout to a PDF file in the output directory using the layout name as the file name. :returns: True if the layout was successfully exported else False. :rtype: bool \"\"\" if self . _layout is None or self . _project is None or not self . output_dir : return False exporter = QgsLayoutExporter ( self . _layout ) pdf_path = f \" { self . output_dir } / { self . _layout . name () } .pdf\" result = exporter . exportToPdf ( pdf_path , QgsLayoutExporter . PdfExportSettings ()) if result == QgsLayoutExporter . ExportResult . Success : return True else : tr_msg = tr ( \"Could not export layout to PDF\" ) self . _error_messages . append ( f \" { tr_msg } { pdf_path } .\" ) return False run run () Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 def run ( self ) -> ReportResult : \"\"\"Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. :returns: The result of the report generation process. :rtype: ReportResult \"\"\" try : return self . _run () except Exception as ex : # Last resort to capture general exceptions. exc_info = \"\" . join ( traceback . TracebackException . from_exception ( ex ) . format ()) self . _error_messages . append ( exc_info ) return self . _get_failed_result () set_label_font classmethod set_label_font ( label , size , bold = False , italic = False ) Set font properties of the given layout label item. Parameters: Name Type Description Default label QgsLayoutItemLabel Label item whose font properties will be updated. required size float Point size of the font. required bold bool True if font is to be bold, else False (default). False italic bool True if font is to be in italics, else False (default). False Source code in src/cplus_plugin/lib/reports/generator.py 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 @classmethod def set_label_font ( cls , label : QgsLayoutItemLabel , size : float , bold : bool = False , italic : bool = False , ): \"\"\"Set font properties of the given layout label item. :param label: Label item whose font properties will be updated. :type label: QgsLayoutItemLabel :param size: Point size of the font. :type size: int :param bold: True if font is to be bold, else False (default). :type bold: bool :param italic: True if font is to be in italics, else False (default). :type italic: bool \"\"\" font = get_report_font ( size , bold , italic ) version = Qgis . versionInt () # Text format size unit if version < 33000 : unit_type = QgsUnitTypes . RenderUnit . RenderPoints else : unit_type = Qgis . RenderUnit . Points # Label font setting option if version < 32400 : label . setFont ( font ) else : txt_format = QgsTextFormat () txt_format . setFont ( font ) txt_format . setSize ( size ) txt_format . setSizeUnit ( unit_type ) label . setTextFormat ( txt_format ) label . refresh () ReportGeneratorTask ReportGeneratorTask ( description , context ) Bases: QgsTask Proxy class for initiating the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 74 75 76 77 78 79 80 def __init__ ( self , description : str , context : ReportContext ): super () . __init__ ( description ) self . _context = context self . _result = None self . _generator = ReportGenerator ( self . _context , self . _context . feedback ) self . layout_manager = QgsProject . instance () . layoutManager () self . layout_manager . layoutAdded . connect ( self . _on_layout_added ) context property context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator. result property result Returns the result object which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process. cancel cancel () Cancel the report generation task. Source code in src/cplus_plugin/lib/reports/generator.py 101 102 103 104 105 106 def cancel ( self ): \"\"\"Cancel the report generation task.\"\"\" if self . _context . feedback : self . _context . feedback . cancel () super () . cancel () finished finished ( result ) If successful, add the layout to the project. Parameters: Name Type Description Default result bool Flag indicating if the result of the report generation process. True if successful, else False. required Source code in src/cplus_plugin/lib/reports/generator.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def finished ( self , result : bool ): \"\"\"If successful, add the layout to the project. :param result: Flag indicating if the result of the report generation process. True if successful, else False. :type result: bool \"\"\" if len ( self . _result . messages ) > 0 : log ( f \"Warnings and errors occurred when generating the \" f \"report for { self . _context . scenario . name } \" f \"scenario. See details below:\" , info = False , ) for err in self . _result . messages : err_msg = f \" { self . _context . scenario . name } - { err } \\n \" log ( err_msg , info = False ) if result : log ( f \"Successfully generated the report for \" f \" { self . _context . scenario . name } scenario.\" ) layout_path = self . _generator . output_layout_path if not layout_path : log ( \"Output layout could not be saved.\" , info = False ) return feedback = self . _context . feedback project = QgsProject . instance () layout = _load_layout_from_file ( layout_path , project ) if layout is None : log ( \"Could not load layout from file.\" , info = False ) return # Zoom the extents of map items in the layout then export to PDF self . _zoom_map_items_to_current_extents ( layout ) project . layoutManager () . addLayout ( layout ) if feedback is not None : feedback . setProgress ( 100 ) run run () Initiates the report generation process and returns a result indicating whether the process succeeded or failed. Returns: Type Description bool True if the report generation process succeeded or False it if failed. Source code in src/cplus_plugin/lib/reports/generator.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def run ( self ) -> bool : \"\"\"Initiates the report generation process and returns a result indicating whether the process succeeded or failed. :returns: True if the report generation process succeeded or False it if failed. :rtype: bool \"\"\" if self . isCanceled (): return False if self . _context . project_file : self . _result = self . _generator . run () else : msg = tr ( \"Unable to serialize current project for report generation.\" ) msgs : typing . List [ str ] = [ msg ] self . _result = ReportResult ( False , self . _context . scenario . uuid , \"\" , tuple ( msgs ) ) return self . _result . success","title":"Generator"},{"location":"developer/api/core/api_reports_generator/#report-generator","text":"CPLUS Report generator.","title":"Report Generator"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator","text":"ReportGenerator ( context , feedback = None ) Generator for CPLUS reports. Source code in src/cplus_plugin/lib/reports/generator.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def __init__ ( self , context : ReportContext , feedback : QgsFeedback = None ): self . _context = context self . _feedback = context . feedback or feedback self . _error_messages : typing . List [ str ] = [] self . _error_occured = False self . _layout = None self . _project = None self . _variable_register = LayoutVariableRegister () self . _report_output_dir = \"\" self . _output_layout_path = \"\" self . _repeat_page = None self . _repeat_page_num = - 1 self . _repeat_item = None self . _reference_layer_group = None self . _scenario_layer = None self . _area_processing_feedback = None self . _implementation_models_area = {} self . _pixel_area_info = {} if self . _feedback : self . _feedback . canceled . connect ( self . _on_feedback_cancelled ) self . _area_calculation_progress_reference = 0 self . _area_calculation_step_increment = 0","title":"ReportGenerator"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.context","text":"context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator.","title":"context"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.feedback","text":"feedback Returns the feedback object for process update and cancellation. Returns: Type Description QgsFeedback Feedback object or None if not specified.","title":"feedback"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.layout","text":"layout Returns the layout object used to generate the report. Returns: Type Description QgsPrintLayout The layout object used to generate the report or None if the process was not successful.","title":"layout"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.output_dir","text":"output_dir Creates, if it does not exist, the output directory where the analysis reports will be saved. This is relative to the base directory and scenario output sub-folder. Returns: Type Description str Output directory where the analysis reports will be saved.","title":"output_dir"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.output_layout_path","text":"output_layout_path Absolute path to a temporary file containing the layout as a QPT file. When this object is used within a QgsTask, it is recommended to use this layout path to reconstruct the layout rather calling the layout attribute since it was created in a separate thread. Returns: Type Description str Path to the layout template file.","title":"output_layout_path"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.repeat_page","text":"repeat_page Returns the page item that will be repeated based on the number of implementation models in the scenario. A repeat page is a layout page item that contains the first instance of a CplusMapRepeatItem. Returns: Type Description QgsLayoutItemPage Page item containing a CplusMapRepeatItem or None if not found.","title":"repeat_page"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.duplicate_repeat_page","text":"duplicate_repeat_page ( position ) Duplicates the repeat page and adds it to the layout at the given position. Parameters: Name Type Description Default position int Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. required Returns: Type Description bool True if the page was successfully duplicated else False. Source code in src/cplus_plugin/lib/reports/generator.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def duplicate_repeat_page ( self , position : int ) -> bool : \"\"\"Duplicates the repeat page and adds it to the layout at the given position. :param position: Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. :type position: int :returns: True if the page was successfully duplicated else False. :rtype: bool \"\"\" if self . _repeat_page is None : return False if self . _layout is None : return False if self . _repeat_page_num == - 1 : tr_msg = \"Repeat page not found in page collection\" self . _error_messages . append ( tr_msg ) return False new_page = QgsLayoutItemPage ( self . _layout ) new_page . attemptResize ( self . _repeat_page . sizeWithUnits ()) new_page . setPageStyleSymbol ( self . _repeat_page . pageStyleSymbol () . clone ()) # Insert empty repeat page at the given position if position < self . _layout . pageCollection () . pageCount (): self . _layout . pageCollection () . insertPage ( new_page , position ) else : # Add at the end position = self . _layout . pageCollection () . pageCount () self . _layout . pageCollection () . addPage ( new_page ) doc = QtXml . QDomDocument () el = doc . createElement ( \"CopyItems\" ) ctx = QgsReadWriteContext () repeat_page_items = self . _layout . pageCollection () . itemsOnPage ( self . _repeat_page_num ) for item in repeat_page_items : item . writeXml ( el , doc , ctx ) doc . appendChild ( el ) # Clear element identifier references nodes = doc . elementsByTagName ( \"LayoutItem\" ) for n in range ( nodes . count ()): node = nodes . at ( n ) if node . isElement (): node . toElement () . removeAttribute ( \"uuid\" ) page_ref_point = self . _layout . pageCollection () . pagePositionToLayoutPosition ( position , QgsLayoutPoint ( 0 , 0 ) ) _ = self . _layout . addItemsFromXml ( el , doc , ctx , page_ref_point , True ) return True","title":"duplicate_repeat_page()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.export_to_pdf","text":"export_to_pdf () Exports the layout to a PDF file in the output directory using the layout name as the file name. Returns: Type Description bool True if the layout was successfully exported else False. Source code in src/cplus_plugin/lib/reports/generator.py 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 def export_to_pdf ( self ) -> bool : \"\"\"Exports the layout to a PDF file in the output directory using the layout name as the file name. :returns: True if the layout was successfully exported else False. :rtype: bool \"\"\" if self . _layout is None or self . _project is None or not self . output_dir : return False exporter = QgsLayoutExporter ( self . _layout ) pdf_path = f \" { self . output_dir } / { self . _layout . name () } .pdf\" result = exporter . exportToPdf ( pdf_path , QgsLayoutExporter . PdfExportSettings ()) if result == QgsLayoutExporter . ExportResult . Success : return True else : tr_msg = tr ( \"Could not export layout to PDF\" ) self . _error_messages . append ( f \" { tr_msg } { pdf_path } .\" ) return False","title":"export_to_pdf()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.run","text":"run () Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 def run ( self ) -> ReportResult : \"\"\"Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. :returns: The result of the report generation process. :rtype: ReportResult \"\"\" try : return self . _run () except Exception as ex : # Last resort to capture general exceptions. exc_info = \"\" . join ( traceback . TracebackException . from_exception ( ex ) . format ()) self . _error_messages . append ( exc_info ) return self . _get_failed_result ()","title":"run()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.set_label_font","text":"set_label_font ( label , size , bold = False , italic = False ) Set font properties of the given layout label item. Parameters: Name Type Description Default label QgsLayoutItemLabel Label item whose font properties will be updated. required size float Point size of the font. required bold bool True if font is to be bold, else False (default). False italic bool True if font is to be in italics, else False (default). False Source code in src/cplus_plugin/lib/reports/generator.py 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 @classmethod def set_label_font ( cls , label : QgsLayoutItemLabel , size : float , bold : bool = False , italic : bool = False , ): \"\"\"Set font properties of the given layout label item. :param label: Label item whose font properties will be updated. :type label: QgsLayoutItemLabel :param size: Point size of the font. :type size: int :param bold: True if font is to be bold, else False (default). :type bold: bool :param italic: True if font is to be in italics, else False (default). :type italic: bool \"\"\" font = get_report_font ( size , bold , italic ) version = Qgis . versionInt () # Text format size unit if version < 33000 : unit_type = QgsUnitTypes . RenderUnit . RenderPoints else : unit_type = Qgis . RenderUnit . Points # Label font setting option if version < 32400 : label . setFont ( font ) else : txt_format = QgsTextFormat () txt_format . setFont ( font ) txt_format . setSize ( size ) txt_format . setSizeUnit ( unit_type ) label . setTextFormat ( txt_format ) label . refresh ()","title":"set_label_font()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask","text":"ReportGeneratorTask ( description , context ) Bases: QgsTask Proxy class for initiating the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 74 75 76 77 78 79 80 def __init__ ( self , description : str , context : ReportContext ): super () . __init__ ( description ) self . _context = context self . _result = None self . _generator = ReportGenerator ( self . _context , self . _context . feedback ) self . layout_manager = QgsProject . instance () . layoutManager () self . layout_manager . layoutAdded . connect ( self . _on_layout_added )","title":"ReportGeneratorTask"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask.context","text":"context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator.","title":"context"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask.result","text":"result Returns the result object which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process.","title":"result"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask.cancel","text":"cancel () Cancel the report generation task. Source code in src/cplus_plugin/lib/reports/generator.py 101 102 103 104 105 106 def cancel ( self ): \"\"\"Cancel the report generation task.\"\"\" if self . _context . feedback : self . _context . feedback . cancel () super () . cancel ()","title":"cancel()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask.finished","text":"finished ( result ) If successful, add the layout to the project. Parameters: Name Type Description Default result bool Flag indicating if the result of the report generation process. True if successful, else False. required Source code in src/cplus_plugin/lib/reports/generator.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def finished ( self , result : bool ): \"\"\"If successful, add the layout to the project. :param result: Flag indicating if the result of the report generation process. True if successful, else False. :type result: bool \"\"\" if len ( self . _result . messages ) > 0 : log ( f \"Warnings and errors occurred when generating the \" f \"report for { self . _context . scenario . name } \" f \"scenario. See details below:\" , info = False , ) for err in self . _result . messages : err_msg = f \" { self . _context . scenario . name } - { err } \\n \" log ( err_msg , info = False ) if result : log ( f \"Successfully generated the report for \" f \" { self . _context . scenario . name } scenario.\" ) layout_path = self . _generator . output_layout_path if not layout_path : log ( \"Output layout could not be saved.\" , info = False ) return feedback = self . _context . feedback project = QgsProject . instance () layout = _load_layout_from_file ( layout_path , project ) if layout is None : log ( \"Could not load layout from file.\" , info = False ) return # Zoom the extents of map items in the layout then export to PDF self . _zoom_map_items_to_current_extents ( layout ) project . layoutManager () . addLayout ( layout ) if feedback is not None : feedback . setProgress ( 100 )","title":"finished()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask.run","text":"run () Initiates the report generation process and returns a result indicating whether the process succeeded or failed. Returns: Type Description bool True if the report generation process succeeded or False it if failed. Source code in src/cplus_plugin/lib/reports/generator.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def run ( self ) -> bool : \"\"\"Initiates the report generation process and returns a result indicating whether the process succeeded or failed. :returns: True if the report generation process succeeded or False it if failed. :rtype: bool \"\"\" if self . isCanceled (): return False if self . _context . project_file : self . _result = self . _generator . run () else : msg = tr ( \"Unable to serialize current project for report generation.\" ) msgs : typing . List [ str ] = [ msg ] self . _result = ReportResult ( False , self . _context . scenario . uuid , \"\" , tuple ( msgs ) ) return self . _result . success","title":"run()"},{"location":"developer/api/core/api_reports_layout_items/","text":"Layout Items Custom CPLUS layout items. CplusMapRepeatItem CplusMapRepeatItem ( * args , ** kwargs ) Bases: QgsLayoutItemShape Defines an outline area within a layout where map items containing NCS pathway or implementation model will be drawn. Source code in src/cplus_plugin/lib/reports/layout_items.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setShapeType ( QgsLayoutItemShape . Shape . Rectangle ) # We shall use a frame so that it can be turned off / on # using the item properties UI. The symbol is just a proxy. # Symbol properties symbol_props = { \"color\" : \"229,182,54,0\" , \"style\" : \"solid\" , \"outline_style\" : \"dash\" , \"line_color\" : \"132,192,68\" , \"outline_width\" : \"0\" , \"joinstyle\" : \"miter\" , } symbol = QgsFillSymbol . createSimple ( symbol_props ) self . setSymbol ( symbol ) self . _model_component_type = kwargs . pop ( \"model_component_type\" , ModelComponentType . UNKNOWN ) model_component_type property writable model_component_type Gets the model component type associated with this map item i.e. NCS pathway or implementation model. Returns: Type Description Enum Type of the model component. icon icon () Override for custom CPLUS map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 83 84 85 def icon ( self ) -> QtGui . QIcon : \"\"\"Override for custom CPLUS map item.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus.svg\" ) readPropertiesFromElement readPropertiesFromElement ( element , document , context ) Override reading of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 95 96 97 98 99 100 101 102 103 104 def readPropertiesFromElement ( self , element , document , context ): \"\"\"Override reading of item properties.\"\"\" status = super () . readPropertiesFromElement ( element , document , context ) if status : model_component_type = element . attribute ( \"modelComponentType\" , \"\" ) self . _model_component_type = ModelComponentType . from_string ( model_component_type ) return status type type () Return item's unique type identifier. Source code in src/cplus_plugin/lib/reports/layout_items.py 71 72 73 def type ( self ): \"\"\"Return item's unique type identifier.\"\"\" return CPLUS_MAP_REPEAT_ITEM_TYPE visibleName visibleName () Override for visible name of the item. Source code in src/cplus_plugin/lib/reports/layout_items.py 75 76 77 def visibleName ( self ) -> str : \"\"\"Override for visible name of the item.\"\"\" return tr ( \"CPLUS Map Repeat Area Item\" ) visiblePluralName visiblePluralName () Override for plural name of the items. Source code in src/cplus_plugin/lib/reports/layout_items.py 79 80 81 def visiblePluralName ( self ) -> str : \"\"\"Override for plural name of the items.\"\"\" return tr ( \"CPLUS Map Repeat Area Items\" ) writePropertiesToElement writePropertiesToElement ( el , document , context ) Override saving of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 87 88 89 90 91 92 93 def writePropertiesToElement ( self , el , document , context ): \"\"\"Override saving of item properties.\"\"\" status = super () . writePropertiesToElement ( el , document , context ) if status : el . setAttribute ( \"modelComponentType\" , self . _model_component_type . value ) return status CplusMapRepeatItemLayoutItemMetadata CplusMapRepeatItemLayoutItemMetadata () Bases: QgsLayoutItemAbstractMetadata Metadata info of the cplus map repeat item. Source code in src/cplus_plugin/lib/reports/layout_items.py 110 111 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , tr ( \"CPLUS Map Repeat Area Item\" )) createItem createItem ( layout ) Factory method that return the cplus map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 113 114 115 def createItem ( self , layout ) -> CplusMapRepeatItem : \"\"\"Factory method that return the cplus map item.\"\"\" return CplusMapRepeatItem ( layout )","title":"Layout items"},{"location":"developer/api/core/api_reports_layout_items/#layout-items","text":"Custom CPLUS layout items.","title":"Layout Items"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem","text":"CplusMapRepeatItem ( * args , ** kwargs ) Bases: QgsLayoutItemShape Defines an outline area within a layout where map items containing NCS pathway or implementation model will be drawn. Source code in src/cplus_plugin/lib/reports/layout_items.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setShapeType ( QgsLayoutItemShape . Shape . Rectangle ) # We shall use a frame so that it can be turned off / on # using the item properties UI. The symbol is just a proxy. # Symbol properties symbol_props = { \"color\" : \"229,182,54,0\" , \"style\" : \"solid\" , \"outline_style\" : \"dash\" , \"line_color\" : \"132,192,68\" , \"outline_width\" : \"0\" , \"joinstyle\" : \"miter\" , } symbol = QgsFillSymbol . createSimple ( symbol_props ) self . setSymbol ( symbol ) self . _model_component_type = kwargs . pop ( \"model_component_type\" , ModelComponentType . UNKNOWN )","title":"CplusMapRepeatItem"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.model_component_type","text":"model_component_type Gets the model component type associated with this map item i.e. NCS pathway or implementation model. Returns: Type Description Enum Type of the model component.","title":"model_component_type"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.icon","text":"icon () Override for custom CPLUS map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 83 84 85 def icon ( self ) -> QtGui . QIcon : \"\"\"Override for custom CPLUS map item.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus.svg\" )","title":"icon()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.readPropertiesFromElement","text":"readPropertiesFromElement ( element , document , context ) Override reading of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 95 96 97 98 99 100 101 102 103 104 def readPropertiesFromElement ( self , element , document , context ): \"\"\"Override reading of item properties.\"\"\" status = super () . readPropertiesFromElement ( element , document , context ) if status : model_component_type = element . attribute ( \"modelComponentType\" , \"\" ) self . _model_component_type = ModelComponentType . from_string ( model_component_type ) return status","title":"readPropertiesFromElement()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.type","text":"type () Return item's unique type identifier. Source code in src/cplus_plugin/lib/reports/layout_items.py 71 72 73 def type ( self ): \"\"\"Return item's unique type identifier.\"\"\" return CPLUS_MAP_REPEAT_ITEM_TYPE","title":"type()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.visibleName","text":"visibleName () Override for visible name of the item. Source code in src/cplus_plugin/lib/reports/layout_items.py 75 76 77 def visibleName ( self ) -> str : \"\"\"Override for visible name of the item.\"\"\" return tr ( \"CPLUS Map Repeat Area Item\" )","title":"visibleName()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.visiblePluralName","text":"visiblePluralName () Override for plural name of the items. Source code in src/cplus_plugin/lib/reports/layout_items.py 79 80 81 def visiblePluralName ( self ) -> str : \"\"\"Override for plural name of the items.\"\"\" return tr ( \"CPLUS Map Repeat Area Items\" )","title":"visiblePluralName()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.writePropertiesToElement","text":"writePropertiesToElement ( el , document , context ) Override saving of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 87 88 89 90 91 92 93 def writePropertiesToElement ( self , el , document , context ): \"\"\"Override saving of item properties.\"\"\" status = super () . writePropertiesToElement ( el , document , context ) if status : el . setAttribute ( \"modelComponentType\" , self . _model_component_type . value ) return status","title":"writePropertiesToElement()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItemLayoutItemMetadata","text":"CplusMapRepeatItemLayoutItemMetadata () Bases: QgsLayoutItemAbstractMetadata Metadata info of the cplus map repeat item. Source code in src/cplus_plugin/lib/reports/layout_items.py 110 111 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , tr ( \"CPLUS Map Repeat Area Item\" ))","title":"CplusMapRepeatItemLayoutItemMetadata"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItemLayoutItemMetadata.createItem","text":"createItem ( layout ) Factory method that return the cplus map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 113 114 115 def createItem ( self , layout ) -> CplusMapRepeatItem : \"\"\"Factory method that return the cplus map item.\"\"\" return CplusMapRepeatItem ( layout )","title":"createItem()"},{"location":"developer/api/core/api_reports_manager/","text":"Report Manager Registers custom report variables for layout design and handles report generation. ReportManager ReportManager ( parent = None ) Bases: QObject Registers custom report variables for layout design and handles report generation. Source code in src/cplus_plugin/lib/reports/manager.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . _variable_register = LayoutVariableRegister () self . report_name = tr ( \"Scenario Analysis Report\" ) # Task id (value) indexed by scenario id (key) self . _report_tasks = {} # Report results (value) indexed by scenario id (key) self . _report_results = {} self . task_manager = QgsApplication . instance () . taskManager () self . task_manager . statusChanged . connect ( self . on_task_status_changed ) self . root_output_dir = \"\" variable_register property variable_register Get the instance of the variable register used for the management of variables. Returns: Type Description LayoutVariableRegister The register for managing variables in report layout scope. create_report_context classmethod create_report_context ( scenario_result , feedback ) Creates the report context for use in the report generator task. Parameters: Name Type Description Default scenario_result ScenarioResult Result of the scenario analysis. required feedback QgsFeedback Feedback object for reporting back to the main application. required Returns: Type Description ReportContext A report context object containing the information for generating the report else None if it could not be created. Source code in src/cplus_plugin/lib/reports/manager.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 @classmethod def create_report_context ( cls , scenario_result : ScenarioResult , feedback : QgsFeedback ) -> typing . Union [ ReportContext , None ]: \"\"\"Creates the report context for use in the report generator task. :param scenario_result: Result of the scenario analysis. :type scenario_result: ScenarioResult :param feedback: Feedback object for reporting back to the main application. :type feedback: QgsFeedback :returns: A report context object containing the information for generating the report else None if it could not be created. :rtype: ReportContext \"\"\" output_dir = os . path . normpath ( scenario_result . scenario_directory ) if not output_dir or not Path ( output_dir ) . exists (): log ( f \"Unable to generate the report. { output_dir } not found. \\n \" ) return None scenario_report_dir = os . path . normpath ( f \" { output_dir } /reports\" ) FileUtils . create_new_dir ( scenario_report_dir ) project_file_path = os . path . join ( scenario_report_dir , f \" { scenario_result . scenario . name } .qgz\" ) if os . path . exists ( project_file_path ): counter = 1 while True : project_file_path = os . path . join ( scenario_report_dir , f \" { scenario_result . scenario . name } _ { counter !s} .qgz\" , ) if not os . path . exists ( project_file_path ): break counter += 1 # Write project to file for use in the task since QgsProject # instances are not thread safe. storage_type = QgsProject . instance () . filePathStorage () QgsProject . instance () . setFilePathStorage ( Qgis . FilePathType . Absolute ) result = QgsProject . instance () . write ( project_file_path ) QgsProject . instance () . setFilePathStorage ( storage_type ) if not result : return None # Set base name for the layout and PDF file suffixed with a number # depending on the number of runs. layout_manager = QgsProject . instance () . layoutManager () counter = 1 context_name = \"\" while True : layout_name = f \" { scenario_result . scenario . name } { counter !s} \" matching_layout = layout_manager . layoutByName ( layout_name ) if matching_layout is None : context_name = layout_name break counter += 1 template_path = FileUtils . report_template_path () return ReportContext ( template_path , scenario_result . scenario , context_name , scenario_report_dir , project_file_path , feedback , scenario_result . output_layer_name , ) create_scenario_dir create_scenario_dir ( scenario ) Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. Parameters: Name Type Description Default scenario Scenario Reference scenario object. required Returns: Type Description str The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. Source code in src/cplus_plugin/lib/reports/manager.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def create_scenario_dir ( self , scenario : Scenario ) -> str : \"\"\"Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. :param scenario: Reference scenario object. :type scenario: Scenario :returns: The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. :rtype: str \"\"\" if not self . root_output_dir : return \"\" output_path = Path ( self . root_output_dir ) if not output_path . exists (): try : output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"outputs subdirectory in the base directory.\" ) log ( msg ) return \"\" scenario_path_str = f \" { self . root_output_dir } / { str ( scenario . uuid ) } \" scenario_output_path = Path ( scenario_path_str ) if not scenario_output_path . exists (): try : scenario_output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"scenario subdirectory in the outputs directory.\" ) log ( msg ) return \"\" return scenario_path_str generate generate ( scenario_result , feedback = None ) Initiates the report generation process using information resulting from the scenario analysis. Parameters: Name Type Description Default scenario_result ScenarioResult Contains details from the scenario analysis. required feedback QgsFeedback Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. None Returns: Type Description ReportSubmitStatus True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. Source code in src/cplus_plugin/lib/reports/manager.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def generate ( self , scenario_result : ScenarioResult , feedback : QgsFeedback = None ) -> ReportSubmitStatus : \"\"\"Initiates the report generation process using information resulting from the scenario analysis. :param scenario_result: Contains details from the scenario analysis. :type scenario_result: ScenarioResult :param feedback: Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. :type feedback: QgsFeedback :returns: True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. :rtype: ReportSubmitStatus \"\"\" scenario = scenario_result . scenario if not scenario_result . output_layer_name : log ( \"Layer name for output scenario is empty. Cannot generate reports.\" ) return ReportSubmitStatus ( False , None ) if feedback is None : feedback = QgsFeedback ( self ) ctx = self . create_report_context ( scenario_result , feedback ) if ctx is None : log ( \"Could not create report context. Check directory settings.\" ) return ReportSubmitStatus ( False , None ) scenario_id = str ( ctx . scenario . uuid ) if scenario_id in self . _report_tasks : return ReportSubmitStatus ( False , ctx . feedback ) msg_tr = tr ( \"Generating report for\" ) description = f \" { msg_tr } { ctx . scenario . name } \" report_task = ReportGeneratorTask ( description , ctx ) report_task_completed = partial ( self . report_task_completed , report_task ) report_task . taskCompleted . connect ( report_task_completed ) report_task . taskTerminated . connect ( report_task_completed ) task_id = self . task_manager . addTask ( report_task ) self . _report_tasks [ scenario_id ] = task_id return ReportSubmitStatus ( True , ctx . feedback ) on_task_status_changed on_task_status_changed ( task_id , status ) Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. Parameters: Name Type Description Default task_id int ID of the task. required status TaskStatus New task status. required Source code in src/cplus_plugin/lib/reports/manager.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def on_task_status_changed ( self , task_id : int , status : QgsTask . TaskStatus ): \"\"\"Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. :param task_id: ID of the task. :type task_id: int :param status: New task status. :type status: QgsTask.TaskStatus \"\"\" scenario_id = self . scenario_by_task_id ( task_id ) # Not related to CPLUS report or task if not scenario_id : return if status == QgsTask . TaskStatus . Running : self . generate_started . emit ( scenario_id ) elif status == QgsTask . TaskStatus . Complete : # Get result task = self . task_manager . task ( task_id ) result = task . result if result is not None : self . _report_results [ scenario_id ] = result # Remove task self . remove_report_task ( scenario_id ) self . generate_completed . emit ( scenario_id ) open_layout_designer classmethod open_layout_designer ( result ) Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. Source code in src/cplus_plugin/lib/reports/manager.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 @classmethod def open_layout_designer ( cls , result : ReportResult ) -> bool : \"\"\"Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. :rtype: bool \"\"\" if not result . success : return False layout = QgsProject . instance () . layoutManager () . layoutByName ( result . name ) if layout is None : return False iface . openLayoutDesigner ( layout ) return True register_variables register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/manager.py 69 70 71 72 73 74 75 76 77 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" self . _variable_register . register_variables ( layout ) remove_report_task remove_report_task ( scenario_id ) Remove report task associated with the given scenario. Parameters: Name Type Description Default scenario_id str Identified of the scenario whose report generation process is to be removed. required Returns: Type Description bool True if the task has been successfully removed else False if there is no associated task for the given scenario. Source code in src/cplus_plugin/lib/reports/manager.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def remove_report_task ( self , scenario_id : str ) -> bool : \"\"\"Remove report task associated with the given scenario. :param scenario_id: Identified of the scenario whose report generation process is to be removed. :type scenario_id: str :returns: True if the task has been successfully removed else False if there is no associated task for the given scenario. :rtype: bool \"\"\" if scenario_id not in self . _report_tasks : return False task_id = self . _report_tasks [ scenario_id ] task = self . task_manager . task ( task_id ) if task is None : return False if ( task . status () != QgsTask . TaskStatus . Complete or task . status () != QgsTask . TaskStatus . Terminated ): task . cancel () _ = self . _report_tasks . pop ( scenario_id ) return True report_result report_result ( scenario_id ) Gets the report result for the scenario with the given ID. Parameters: Name Type Description Default scenario_id str Identifier of the scenario whose report is to be retrieved. required Returns: Type Description ReportResult Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the success attribute. For scenarios that had not been submitted for report generation, a None object will be returned. Source code in src/cplus_plugin/lib/reports/manager.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def report_result ( self , scenario_id : str ) -> typing . Union [ ReportResult , None ]: \"\"\"Gets the report result for the scenario with the given ID. :param scenario_id: Identifier of the scenario whose report is to be retrieved. :type scenario_id: str :returns: Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the `success` attribute. For scenarios that had not been submitted for report generation, a None object will be returned. :rtype: ReportResult \"\"\" if scenario_id not in self . _report_results : return None return self . _report_results [ scenario_id ] scenario_by_task_id scenario_by_task_id ( task_id ) Gets the scenario identifier for the report generation t ask with the given ID. Parameters: Name Type Description Default task_id int ID of the task whose corresponding scenario is to be retrieved. required Returns: Type Description str Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. Source code in src/cplus_plugin/lib/reports/manager.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def scenario_by_task_id ( self , task_id : int ) -> str : \"\"\"Gets the scenario identifier for the report generation t ask with the given ID. :param task_id: ID of the task whose corresponding scenario is to be retrieved. :type task_id: int :returns: Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. :rtype: str \"\"\" scenario_ids = [ sid for sid , tid in self . _report_tasks . items () if tid == task_id ] if len ( scenario_ids ) == 0 : return \"\" return scenario_ids [ 0 ] view_pdf classmethod view_pdf ( result ) Opens the analysis in the host's default PDF viewer. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the PDF was successfully loaded, else False if the result from the generation process was False. Source code in src/cplus_plugin/lib/reports/manager.py 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 @classmethod def view_pdf ( cls , result : ReportResult ) -> bool : \"\"\"Opens the analysis in the host's default PDF viewer. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the PDF was successfully loaded, else False if the result from the generation process was False. :rtype: bool \"\"\" if not result . success : return False pdf_url = QtCore . QUrl . fromLocalFile ( result . pdf_path ) if pdf_url . isEmpty (): return False return QtGui . QDesktopServices . openUrl ( pdf_url )","title":"Manager"},{"location":"developer/api/core/api_reports_manager/#report-manager","text":"Registers custom report variables for layout design and handles report generation.","title":"Report Manager"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager","text":"ReportManager ( parent = None ) Bases: QObject Registers custom report variables for layout design and handles report generation. Source code in src/cplus_plugin/lib/reports/manager.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . _variable_register = LayoutVariableRegister () self . report_name = tr ( \"Scenario Analysis Report\" ) # Task id (value) indexed by scenario id (key) self . _report_tasks = {} # Report results (value) indexed by scenario id (key) self . _report_results = {} self . task_manager = QgsApplication . instance () . taskManager () self . task_manager . statusChanged . connect ( self . on_task_status_changed ) self . root_output_dir = \"\"","title":"ReportManager"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.variable_register","text":"variable_register Get the instance of the variable register used for the management of variables. Returns: Type Description LayoutVariableRegister The register for managing variables in report layout scope.","title":"variable_register"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.create_report_context","text":"create_report_context ( scenario_result , feedback ) Creates the report context for use in the report generator task. Parameters: Name Type Description Default scenario_result ScenarioResult Result of the scenario analysis. required feedback QgsFeedback Feedback object for reporting back to the main application. required Returns: Type Description ReportContext A report context object containing the information for generating the report else None if it could not be created. Source code in src/cplus_plugin/lib/reports/manager.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 @classmethod def create_report_context ( cls , scenario_result : ScenarioResult , feedback : QgsFeedback ) -> typing . Union [ ReportContext , None ]: \"\"\"Creates the report context for use in the report generator task. :param scenario_result: Result of the scenario analysis. :type scenario_result: ScenarioResult :param feedback: Feedback object for reporting back to the main application. :type feedback: QgsFeedback :returns: A report context object containing the information for generating the report else None if it could not be created. :rtype: ReportContext \"\"\" output_dir = os . path . normpath ( scenario_result . scenario_directory ) if not output_dir or not Path ( output_dir ) . exists (): log ( f \"Unable to generate the report. { output_dir } not found. \\n \" ) return None scenario_report_dir = os . path . normpath ( f \" { output_dir } /reports\" ) FileUtils . create_new_dir ( scenario_report_dir ) project_file_path = os . path . join ( scenario_report_dir , f \" { scenario_result . scenario . name } .qgz\" ) if os . path . exists ( project_file_path ): counter = 1 while True : project_file_path = os . path . join ( scenario_report_dir , f \" { scenario_result . scenario . name } _ { counter !s} .qgz\" , ) if not os . path . exists ( project_file_path ): break counter += 1 # Write project to file for use in the task since QgsProject # instances are not thread safe. storage_type = QgsProject . instance () . filePathStorage () QgsProject . instance () . setFilePathStorage ( Qgis . FilePathType . Absolute ) result = QgsProject . instance () . write ( project_file_path ) QgsProject . instance () . setFilePathStorage ( storage_type ) if not result : return None # Set base name for the layout and PDF file suffixed with a number # depending on the number of runs. layout_manager = QgsProject . instance () . layoutManager () counter = 1 context_name = \"\" while True : layout_name = f \" { scenario_result . scenario . name } { counter !s} \" matching_layout = layout_manager . layoutByName ( layout_name ) if matching_layout is None : context_name = layout_name break counter += 1 template_path = FileUtils . report_template_path () return ReportContext ( template_path , scenario_result . scenario , context_name , scenario_report_dir , project_file_path , feedback , scenario_result . output_layer_name , )","title":"create_report_context()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.create_scenario_dir","text":"create_scenario_dir ( scenario ) Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. Parameters: Name Type Description Default scenario Scenario Reference scenario object. required Returns: Type Description str The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. Source code in src/cplus_plugin/lib/reports/manager.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def create_scenario_dir ( self , scenario : Scenario ) -> str : \"\"\"Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. :param scenario: Reference scenario object. :type scenario: Scenario :returns: The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. :rtype: str \"\"\" if not self . root_output_dir : return \"\" output_path = Path ( self . root_output_dir ) if not output_path . exists (): try : output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"outputs subdirectory in the base directory.\" ) log ( msg ) return \"\" scenario_path_str = f \" { self . root_output_dir } / { str ( scenario . uuid ) } \" scenario_output_path = Path ( scenario_path_str ) if not scenario_output_path . exists (): try : scenario_output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"scenario subdirectory in the outputs directory.\" ) log ( msg ) return \"\" return scenario_path_str","title":"create_scenario_dir()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.generate","text":"generate ( scenario_result , feedback = None ) Initiates the report generation process using information resulting from the scenario analysis. Parameters: Name Type Description Default scenario_result ScenarioResult Contains details from the scenario analysis. required feedback QgsFeedback Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. None Returns: Type Description ReportSubmitStatus True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. Source code in src/cplus_plugin/lib/reports/manager.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def generate ( self , scenario_result : ScenarioResult , feedback : QgsFeedback = None ) -> ReportSubmitStatus : \"\"\"Initiates the report generation process using information resulting from the scenario analysis. :param scenario_result: Contains details from the scenario analysis. :type scenario_result: ScenarioResult :param feedback: Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. :type feedback: QgsFeedback :returns: True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. :rtype: ReportSubmitStatus \"\"\" scenario = scenario_result . scenario if not scenario_result . output_layer_name : log ( \"Layer name for output scenario is empty. Cannot generate reports.\" ) return ReportSubmitStatus ( False , None ) if feedback is None : feedback = QgsFeedback ( self ) ctx = self . create_report_context ( scenario_result , feedback ) if ctx is None : log ( \"Could not create report context. Check directory settings.\" ) return ReportSubmitStatus ( False , None ) scenario_id = str ( ctx . scenario . uuid ) if scenario_id in self . _report_tasks : return ReportSubmitStatus ( False , ctx . feedback ) msg_tr = tr ( \"Generating report for\" ) description = f \" { msg_tr } { ctx . scenario . name } \" report_task = ReportGeneratorTask ( description , ctx ) report_task_completed = partial ( self . report_task_completed , report_task ) report_task . taskCompleted . connect ( report_task_completed ) report_task . taskTerminated . connect ( report_task_completed ) task_id = self . task_manager . addTask ( report_task ) self . _report_tasks [ scenario_id ] = task_id return ReportSubmitStatus ( True , ctx . feedback )","title":"generate()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.on_task_status_changed","text":"on_task_status_changed ( task_id , status ) Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. Parameters: Name Type Description Default task_id int ID of the task. required status TaskStatus New task status. required Source code in src/cplus_plugin/lib/reports/manager.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def on_task_status_changed ( self , task_id : int , status : QgsTask . TaskStatus ): \"\"\"Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. :param task_id: ID of the task. :type task_id: int :param status: New task status. :type status: QgsTask.TaskStatus \"\"\" scenario_id = self . scenario_by_task_id ( task_id ) # Not related to CPLUS report or task if not scenario_id : return if status == QgsTask . TaskStatus . Running : self . generate_started . emit ( scenario_id ) elif status == QgsTask . TaskStatus . Complete : # Get result task = self . task_manager . task ( task_id ) result = task . result if result is not None : self . _report_results [ scenario_id ] = result # Remove task self . remove_report_task ( scenario_id ) self . generate_completed . emit ( scenario_id )","title":"on_task_status_changed()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.open_layout_designer","text":"open_layout_designer ( result ) Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. Source code in src/cplus_plugin/lib/reports/manager.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 @classmethod def open_layout_designer ( cls , result : ReportResult ) -> bool : \"\"\"Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. :rtype: bool \"\"\" if not result . success : return False layout = QgsProject . instance () . layoutManager () . layoutByName ( result . name ) if layout is None : return False iface . openLayoutDesigner ( layout ) return True","title":"open_layout_designer()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.register_variables","text":"register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/manager.py 69 70 71 72 73 74 75 76 77 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" self . _variable_register . register_variables ( layout )","title":"register_variables()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.remove_report_task","text":"remove_report_task ( scenario_id ) Remove report task associated with the given scenario. Parameters: Name Type Description Default scenario_id str Identified of the scenario whose report generation process is to be removed. required Returns: Type Description bool True if the task has been successfully removed else False if there is no associated task for the given scenario. Source code in src/cplus_plugin/lib/reports/manager.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def remove_report_task ( self , scenario_id : str ) -> bool : \"\"\"Remove report task associated with the given scenario. :param scenario_id: Identified of the scenario whose report generation process is to be removed. :type scenario_id: str :returns: True if the task has been successfully removed else False if there is no associated task for the given scenario. :rtype: bool \"\"\" if scenario_id not in self . _report_tasks : return False task_id = self . _report_tasks [ scenario_id ] task = self . task_manager . task ( task_id ) if task is None : return False if ( task . status () != QgsTask . TaskStatus . Complete or task . status () != QgsTask . TaskStatus . Terminated ): task . cancel () _ = self . _report_tasks . pop ( scenario_id ) return True","title":"remove_report_task()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.report_result","text":"report_result ( scenario_id ) Gets the report result for the scenario with the given ID. Parameters: Name Type Description Default scenario_id str Identifier of the scenario whose report is to be retrieved. required Returns: Type Description ReportResult Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the success attribute. For scenarios that had not been submitted for report generation, a None object will be returned. Source code in src/cplus_plugin/lib/reports/manager.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def report_result ( self , scenario_id : str ) -> typing . Union [ ReportResult , None ]: \"\"\"Gets the report result for the scenario with the given ID. :param scenario_id: Identifier of the scenario whose report is to be retrieved. :type scenario_id: str :returns: Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the `success` attribute. For scenarios that had not been submitted for report generation, a None object will be returned. :rtype: ReportResult \"\"\" if scenario_id not in self . _report_results : return None return self . _report_results [ scenario_id ]","title":"report_result()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.scenario_by_task_id","text":"scenario_by_task_id ( task_id ) Gets the scenario identifier for the report generation t ask with the given ID. Parameters: Name Type Description Default task_id int ID of the task whose corresponding scenario is to be retrieved. required Returns: Type Description str Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. Source code in src/cplus_plugin/lib/reports/manager.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def scenario_by_task_id ( self , task_id : int ) -> str : \"\"\"Gets the scenario identifier for the report generation t ask with the given ID. :param task_id: ID of the task whose corresponding scenario is to be retrieved. :type task_id: int :returns: Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. :rtype: str \"\"\" scenario_ids = [ sid for sid , tid in self . _report_tasks . items () if tid == task_id ] if len ( scenario_ids ) == 0 : return \"\" return scenario_ids [ 0 ]","title":"scenario_by_task_id()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.view_pdf","text":"view_pdf ( result ) Opens the analysis in the host's default PDF viewer. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the PDF was successfully loaded, else False if the result from the generation process was False. Source code in src/cplus_plugin/lib/reports/manager.py 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 @classmethod def view_pdf ( cls , result : ReportResult ) -> bool : \"\"\"Opens the analysis in the host's default PDF viewer. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the PDF was successfully loaded, else False if the result from the generation process was False. :rtype: bool \"\"\" if not result . success : return False pdf_url = QtCore . QUrl . fromLocalFile ( result . pdf_path ) if pdf_url . isEmpty (): return False return QtGui . QDesktopServices . openUrl ( pdf_url )","title":"view_pdf()"},{"location":"developer/api/core/api_reports_variables/","text":"Variable Register Manages custom variable data for report design and generation. CplusVariableInfo dataclass Contains information about a CPLUS variable within a layout scope. update_final_value update_final_value ( context ) Computes the final value of the variable to be used in the layout. Default implementation does nothing. Parameters: Name Type Description Default context ReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 28 29 30 31 32 33 34 35 36 37 38 def update_final_value ( self , context : ReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Default implementation does nothing. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" pass LayoutVariableRegister LayoutVariableRegister () Manages variables and their corresponding values for use in layout design and report generation. Source code in src/cplus_plugin/lib/reports/variables.py 131 132 133 def __init__ ( self ): self . _var_infos = {} self . _init_vars () var_name_init_values property var_name_init_values Creates a collection of variable names and their corresponding initial values. Returns: Type Description dict Collection of variable names and corresponding initial values. variable_names property variable_names Gets the names of the registered variables. Returns: Type Description list A collection of registered variable names. is_analysis_report is_analysis_report ( layout ) Checks whether the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to check whether its from a report generation process. required Returns: Type Description bool True if the layout is from a report generation process, else False. Source code in src/cplus_plugin/lib/reports/variables.py 272 273 274 275 276 277 278 279 280 281 282 283 284 def is_analysis_report ( self , layout : QgsPrintLayout ) -> bool : \"\"\"Checks whether the layout has been produced from a report generation process. :param layout: Layout to check whether its from a report generation process. :type layout: QgsPrintLayout :returns: True if the layout is from a report generation process, else False. :rtype: bool \"\"\" return layout . customProperty ( self . VAR_CPLUS_REPORT_PROPERTY , False ) register_variables register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/variables.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" # If layout from analysis process, do not register # the variables. if self . is_analysis_report ( layout ): return # Remove any duplicate cplus variable names and values var_names , var_values = self . remove_variables ( layout ) # Get cplus variable names and corresponding initial values var_name_init_values = self . var_name_init_values for var_name , init_value in var_name_init_values . items (): var_names . append ( var_name ) var_values . append ( init_value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values ) remove_var_name_in_collection classmethod remove_var_name_in_collection ( cplus_var_name , layout_var_names , layout_var_values ) Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. Source code in src/cplus_plugin/lib/reports/variables.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 @classmethod def remove_var_name_in_collection ( cls , cplus_var_name : str , layout_var_names : typing . List [ str ], layout_var_values : typing . List [ str ], ): \"\"\"Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. \"\"\" while cplus_var_name in layout_var_names : idx = layout_var_names . index ( cplus_var_name ) _ = layout_var_names . pop ( idx ) _ = layout_var_values . pop ( idx ) remove_variables remove_variables ( layout ) Removes duplicate variable names from the layout, this is done prior to registering new ones. Parameters: Name Type Description Default layout QgsPrintLayout Layout whose cplus variables are to be removed. required Returns: Type Description tuple Tuple only containing non-cplus variable names and corresponding values respectively. Source code in src/cplus_plugin/lib/reports/variables.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def remove_variables ( self , layout : QgsPrintLayout ) -> typing . Tuple [ typing . List , typing . List ]: \"\"\"Removes duplicate variable names from the layout, this is done prior to registering new ones. :param layout: Layout whose cplus variables are to be removed. :type layout: QgsPrintLayout :returns: Tuple only containing non-cplus variable names and corresponding values respectively. :rtype: tuple \"\"\" cplus_var_names = self . variable_names var_names = layout . customProperty ( self . VAR_NAMES_PROPERTY , list ()) var_values = layout . customProperty ( self . VAR_VALUES_PROPERTY , list ()) # Remove only cplus variable names and values for cvn in cplus_var_names : self . remove_var_name_in_collection ( cvn , var_names , var_values ) return var_names , var_values set_report_flag set_report_flag ( layout ) Set a flag indicating that the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to add the flag as a custom property. required Source code in src/cplus_plugin/lib/reports/variables.py 311 312 313 314 315 316 317 318 def set_report_flag ( self , layout : QgsPrintLayout ): \"\"\"Set a flag indicating that the layout has been produced from a report generation process. :param layout: Layout to add the flag as a custom property. :type layout: QgsPrintLayout \"\"\" layout . setCustomProperty ( self . VAR_CPLUS_REPORT_PROPERTY , True ) update_variables update_variables ( layout , context ) Update the values for the CPLUS variables in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object whose CPLUS variable values will be updated. required context ReportContext Context object containing the report information that will be used for computing the final value of the variable during the report generation process. required Source code in src/cplus_plugin/lib/reports/variables.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def update_variables ( self , layout : QgsPrintLayout , context : ReportContext ): \"\"\"Update the values for the CPLUS variables in the layout. :param layout: Layout object whose CPLUS variable values will be updated. :type layout: QgsPrintLayout :param context: Context object containing the report information that will be used for computing the final value of the variable during the report generation process. :type context: ReportContext \"\"\" exp_scope = QgsExpressionContextUtils . layoutScope ( layout ) var_names = exp_scope . variableNames () var_values = [] vn = list ( self . _var_infos . keys ()) for name in var_names : if name in self . _var_infos : var_info = self . _var_infos [ name ] var_info . update_final_value ( context ) var_values . append ( var_info . final_value ) else : if not exp_scope . hasVariable ( name ): continue value = exp_scope . variable ( name ) var_values . append ( value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values ) layout . refresh () ScenarioDescriptionVariableInfo dataclass Bases: CplusVariableInfo Metadata for a scenario description variable. update_final_value update_final_value ( context ) Set the scenario description. Source code in src/cplus_plugin/lib/reports/variables.py 116 117 118 def update_final_value ( self , context : ReportContext ): \"\"\"Set the scenario description.\"\"\" self . final_value = context . scenario . description ScenarioNameVariableInfo dataclass Bases: CplusVariableInfo Metadata for a scenario name variable. update_final_value update_final_value ( context ) Set the scenario name. Source code in src/cplus_plugin/lib/reports/variables.py 94 95 96 def update_final_value ( self , context : ReportContext ): \"\"\"Set the scenario name.\"\"\" self . final_value = context . scenario . name SettingsVariableInfo dataclass Bases: CplusVariableInfo Metadata for a settings-related variable. update_final_value update_final_value ( context ) Computes the final value of the variable to be used in the layout. Fetches the latest settings value. Parameters: Name Type Description Default context ReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 64 65 66 67 68 69 70 71 72 73 74 def update_final_value ( self , context : ReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Fetches the latest settings value. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" self . final_value = self . _get_setting_value () create_bulleted_text create_bulleted_text ( main_text , bulleted_items ) Returns string containing text and bulleted/dashed text below it. Parameters: Name Type Description Default main_text str Primary non-bulleted text. required bulleted_items List [ str ] List containing bulleted items that will be rendered below the main text. required Returns: Type Description str Text containing primary text with bulleted items below it. Source code in src/cplus_plugin/lib/reports/variables.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 def create_bulleted_text ( main_text : str , bulleted_items : typing . List [ str ]) -> str : \"\"\"Returns string containing text and bulleted/dashed text below it. :param main_text: Primary non-bulleted text. :type main_text: str :param bulleted_items: List containing bulleted items that will be rendered below the main text. :type bulleted_items: list :returns: Text containing primary text with bulleted items below it. :rtype: str \"\"\" bulleted_items = \" \\n - \" . join ( bulleted_items ) if not main_text : return f \"- { bulleted_items } \" return f \" { main_text } \\n - { bulleted_items } \"","title":"Variables"},{"location":"developer/api/core/api_reports_variables/#variable-register","text":"Manages custom variable data for report design and generation.","title":"Variable Register"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.CplusVariableInfo","text":"Contains information about a CPLUS variable within a layout scope.","title":"CplusVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.CplusVariableInfo.update_final_value","text":"update_final_value ( context ) Computes the final value of the variable to be used in the layout. Default implementation does nothing. Parameters: Name Type Description Default context ReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 28 29 30 31 32 33 34 35 36 37 38 def update_final_value ( self , context : ReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Default implementation does nothing. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" pass","title":"update_final_value()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister","text":"LayoutVariableRegister () Manages variables and their corresponding values for use in layout design and report generation. Source code in src/cplus_plugin/lib/reports/variables.py 131 132 133 def __init__ ( self ): self . _var_infos = {} self . _init_vars ()","title":"LayoutVariableRegister"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.var_name_init_values","text":"var_name_init_values Creates a collection of variable names and their corresponding initial values. Returns: Type Description dict Collection of variable names and corresponding initial values.","title":"var_name_init_values"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.variable_names","text":"variable_names Gets the names of the registered variables. Returns: Type Description list A collection of registered variable names.","title":"variable_names"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.is_analysis_report","text":"is_analysis_report ( layout ) Checks whether the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to check whether its from a report generation process. required Returns: Type Description bool True if the layout is from a report generation process, else False. Source code in src/cplus_plugin/lib/reports/variables.py 272 273 274 275 276 277 278 279 280 281 282 283 284 def is_analysis_report ( self , layout : QgsPrintLayout ) -> bool : \"\"\"Checks whether the layout has been produced from a report generation process. :param layout: Layout to check whether its from a report generation process. :type layout: QgsPrintLayout :returns: True if the layout is from a report generation process, else False. :rtype: bool \"\"\" return layout . customProperty ( self . VAR_CPLUS_REPORT_PROPERTY , False )","title":"is_analysis_report()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.register_variables","text":"register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/variables.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" # If layout from analysis process, do not register # the variables. if self . is_analysis_report ( layout ): return # Remove any duplicate cplus variable names and values var_names , var_values = self . remove_variables ( layout ) # Get cplus variable names and corresponding initial values var_name_init_values = self . var_name_init_values for var_name , init_value in var_name_init_values . items (): var_names . append ( var_name ) var_values . append ( init_value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values )","title":"register_variables()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.remove_var_name_in_collection","text":"remove_var_name_in_collection ( cplus_var_name , layout_var_names , layout_var_values ) Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. Source code in src/cplus_plugin/lib/reports/variables.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 @classmethod def remove_var_name_in_collection ( cls , cplus_var_name : str , layout_var_names : typing . List [ str ], layout_var_values : typing . List [ str ], ): \"\"\"Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. \"\"\" while cplus_var_name in layout_var_names : idx = layout_var_names . index ( cplus_var_name ) _ = layout_var_names . pop ( idx ) _ = layout_var_values . pop ( idx )","title":"remove_var_name_in_collection()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.remove_variables","text":"remove_variables ( layout ) Removes duplicate variable names from the layout, this is done prior to registering new ones. Parameters: Name Type Description Default layout QgsPrintLayout Layout whose cplus variables are to be removed. required Returns: Type Description tuple Tuple only containing non-cplus variable names and corresponding values respectively. Source code in src/cplus_plugin/lib/reports/variables.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def remove_variables ( self , layout : QgsPrintLayout ) -> typing . Tuple [ typing . List , typing . List ]: \"\"\"Removes duplicate variable names from the layout, this is done prior to registering new ones. :param layout: Layout whose cplus variables are to be removed. :type layout: QgsPrintLayout :returns: Tuple only containing non-cplus variable names and corresponding values respectively. :rtype: tuple \"\"\" cplus_var_names = self . variable_names var_names = layout . customProperty ( self . VAR_NAMES_PROPERTY , list ()) var_values = layout . customProperty ( self . VAR_VALUES_PROPERTY , list ()) # Remove only cplus variable names and values for cvn in cplus_var_names : self . remove_var_name_in_collection ( cvn , var_names , var_values ) return var_names , var_values","title":"remove_variables()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.set_report_flag","text":"set_report_flag ( layout ) Set a flag indicating that the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to add the flag as a custom property. required Source code in src/cplus_plugin/lib/reports/variables.py 311 312 313 314 315 316 317 318 def set_report_flag ( self , layout : QgsPrintLayout ): \"\"\"Set a flag indicating that the layout has been produced from a report generation process. :param layout: Layout to add the flag as a custom property. :type layout: QgsPrintLayout \"\"\" layout . setCustomProperty ( self . VAR_CPLUS_REPORT_PROPERTY , True )","title":"set_report_flag()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.update_variables","text":"update_variables ( layout , context ) Update the values for the CPLUS variables in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object whose CPLUS variable values will be updated. required context ReportContext Context object containing the report information that will be used for computing the final value of the variable during the report generation process. required Source code in src/cplus_plugin/lib/reports/variables.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def update_variables ( self , layout : QgsPrintLayout , context : ReportContext ): \"\"\"Update the values for the CPLUS variables in the layout. :param layout: Layout object whose CPLUS variable values will be updated. :type layout: QgsPrintLayout :param context: Context object containing the report information that will be used for computing the final value of the variable during the report generation process. :type context: ReportContext \"\"\" exp_scope = QgsExpressionContextUtils . layoutScope ( layout ) var_names = exp_scope . variableNames () var_values = [] vn = list ( self . _var_infos . keys ()) for name in var_names : if name in self . _var_infos : var_info = self . _var_infos [ name ] var_info . update_final_value ( context ) var_values . append ( var_info . final_value ) else : if not exp_scope . hasVariable ( name ): continue value = exp_scope . variable ( name ) var_values . append ( value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values ) layout . refresh ()","title":"update_variables()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioDescriptionVariableInfo","text":"Bases: CplusVariableInfo Metadata for a scenario description variable.","title":"ScenarioDescriptionVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioDescriptionVariableInfo.update_final_value","text":"update_final_value ( context ) Set the scenario description. Source code in src/cplus_plugin/lib/reports/variables.py 116 117 118 def update_final_value ( self , context : ReportContext ): \"\"\"Set the scenario description.\"\"\" self . final_value = context . scenario . description","title":"update_final_value()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioNameVariableInfo","text":"Bases: CplusVariableInfo Metadata for a scenario name variable.","title":"ScenarioNameVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioNameVariableInfo.update_final_value","text":"update_final_value ( context ) Set the scenario name. Source code in src/cplus_plugin/lib/reports/variables.py 94 95 96 def update_final_value ( self , context : ReportContext ): \"\"\"Set the scenario name.\"\"\" self . final_value = context . scenario . name","title":"update_final_value()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.SettingsVariableInfo","text":"Bases: CplusVariableInfo Metadata for a settings-related variable.","title":"SettingsVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.SettingsVariableInfo.update_final_value","text":"update_final_value ( context ) Computes the final value of the variable to be used in the layout. Fetches the latest settings value. Parameters: Name Type Description Default context ReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 64 65 66 67 68 69 70 71 72 73 74 def update_final_value ( self , context : ReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Fetches the latest settings value. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" self . final_value = self . _get_setting_value ()","title":"update_final_value()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.create_bulleted_text","text":"create_bulleted_text ( main_text , bulleted_items ) Returns string containing text and bulleted/dashed text below it. Parameters: Name Type Description Default main_text str Primary non-bulleted text. required bulleted_items List [ str ] List containing bulleted items that will be rendered below the main text. required Returns: Type Description str Text containing primary text with bulleted items below it. Source code in src/cplus_plugin/lib/reports/variables.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 def create_bulleted_text ( main_text : str , bulleted_items : typing . List [ str ]) -> str : \"\"\"Returns string containing text and bulleted/dashed text below it. :param main_text: Primary non-bulleted text. :type main_text: str :param bulleted_items: List containing bulleted items that will be rendered below the main text. :type bulleted_items: list :returns: Text containing primary text with bulleted items below it. :rtype: str \"\"\" bulleted_items = \" \\n - \" . join ( bulleted_items ) if not main_text : return f \"- { bulleted_items } \" return f \" { main_text } \\n - { bulleted_items } \"","title":"create_bulleted_text()"},{"location":"developer/api/core/api_settings/","text":"Settings Plugin global settings. Covers the plugin global settings which a user can set and save. The settings will be saved using QgsSettings. Settings can be accessed via the QGIS options, a button on the docking widget, and from the toolbar menu. CplusOptionsFactory CplusOptionsFactory () Bases: QgsOptionsWidgetFactory Options factory initializes the CPLUS settings. Class which creates the widget requied for the CPLUS settings. QgsOptionsWidgetFactory is used to accomplish this. QGIS CPLUS Plugin Settings factory. Source code in src/cplus_plugin/settings.py 416 417 418 419 420 def __init__ ( self ) -> None : \"\"\"QGIS CPLUS Plugin Settings factory.\"\"\" super () . __init__ () self . setTitle ( OPTIONS_TITLE ) createWidget createWidget ( parent ) Creates a widget for CPLUS settings. Parameters: Name Type Description Default parent QWidget Parent widget required Returns: Type Description CplusSettings Widget to be used in the QGIS options Source code in src/cplus_plugin/settings.py 431 432 433 434 435 436 437 438 439 440 441 def createWidget ( self , parent : QWidget ) -> CplusSettings : \"\"\"Creates a widget for CPLUS settings. :param parent: Parent widget :type parent: QWidget :returns: Widget to be used in the QGIS options :rtype: CplusSettings \"\"\" return CplusSettings ( parent ) icon icon () Returns the icon which will be used for the CPLUS options tab. Returns: Type Description QIcon An icon object which contains the provided custom icon Source code in src/cplus_plugin/settings.py 422 423 424 425 426 427 428 429 def icon ( self ) -> QIcon : \"\"\"Returns the icon which will be used for the CPLUS options tab. :returns: An icon object which contains the provided custom icon :rtype: QIcon \"\"\" return QIcon ( ICON_PATH ) CplusSettings CplusSettings ( parent = None ) Bases: Ui_DlgSettings , QgsOptionsPageWidget QGIS CPLUS Plugin Settings dialog. Source code in src/cplus_plugin/settings.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def __init__ ( self , parent = None ) -> None : \"\"\"QGIS CPLUS Plugin Settings dialog.\"\"\" QgsOptionsPageWidget . __init__ ( self , parent ) self . setupUi ( self ) self . message_bar = qgis . gui . QgsMessageBar ( self ) self . layout () . insertWidget ( 0 , self . message_bar ) self . settings = qgis . core . QgsSettings () settings_manager . settings_updated [ str , object ] . connect ( self . on_settings_changed ) # Connections self . cb_custom_logo . stateChanged . connect ( self . logo_state_changed ) self . logo_file . fileChanged . connect ( self . logo_file_changed ) self . folder_data . fileChanged . connect ( self . base_dir_exists ) self . map_layer_file_widget . setStorageMode ( QgsFileWidget . StorageMode . GetFile ) self . map_layer_box . layerChanged . connect ( self . map_layer_changed ) self . resample_method_box . addItem ( tr ( \"Nearest Neighbour\" ), QgsAlignRaster . ResampleAlg . RA_NearestNeighbour ) self . resample_method_box . addItem ( tr ( \"Bilinear (2x2 Kernel)\" ), QgsAlignRaster . ResampleAlg . RA_Bilinear ) self . resample_method_box . addItem ( tr ( \"Cubic (4x4 Kernel)\" ), QgsAlignRaster . ResampleAlg . RA_Cubic ) self . resample_method_box . addItem ( tr ( \"Cubic B-Spline (4x4 Kernel)\" ), QgsAlignRaster . ResampleAlg . RA_CubicSpline ) self . resample_method_box . addItem ( tr ( \"Lanczos (6x6 Kernel)\" ), QgsAlignRaster . ResampleAlg . RA_Lanczos ) self . resample_method_box . addItem ( tr ( \"Average\" ), QgsAlignRaster . ResampleAlg . RA_Average ) self . resample_method_box . addItem ( tr ( \"Mode\" ), QgsAlignRaster . ResampleAlg . RA_Mode ) self . resample_method_box . addItem ( tr ( \"Maximum\" ), QgsAlignRaster . ResampleAlg . RA_Max ) self . resample_method_box . addItem ( tr ( \"Minimum\" ), QgsAlignRaster . ResampleAlg . RA_Min ) self . resample_method_box . addItem ( tr ( \"Median\" ), QgsAlignRaster . ResampleAlg . RA_Median ) self . resample_method_box . addItem ( tr ( \"First Quartile (Q1)\" ), QgsAlignRaster . ResampleAlg . RA_Q1 ) self . resample_method_box . addItem ( tr ( \"Third Quartile (Q3)\" ), QgsAlignRaster . ResampleAlg . RA_Q3 ) message_bar instance-attribute message_bar = qgis . gui . QgsMessageBar ( self ) CPLUS plugin settings class. Class which manages the CPLUS settings. Initilizes the UI, which can be accessed from the menu drop-down or the QGIS settings. apply apply () This is called on OK click in the QGIS options panel. Source code in src/cplus_plugin/settings.py 108 109 110 111 def apply ( self ) -> None : \"\"\"This is called on OK click in the QGIS options panel.\"\"\" self . save_settings () base_dir_exists base_dir_exists () Checks if the provided base directory exists. A warning messages is presented if the directory does not exist. Returns: Type Description bool Whether the base directory exists Source code in src/cplus_plugin/settings.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def base_dir_exists ( self ) -> bool : \"\"\"Checks if the provided base directory exists. A warning messages is presented if the directory does not exist. :returns: Whether the base directory exists :rtype: bool \"\"\" # Clears the error messages when doing next check self . message_bar . clearWidgets () folder_found = False base_dir_path = self . folder_data . filePath () if not os . path . exists ( base_dir_path ): # File not found self . message_bar . pushWarning ( \"CPLUS - Base directory not found: \" , base_dir_path ) else : folder_found = True return folder_found closeEvent closeEvent ( event ) When closing the setings. Parameters: Name Type Description Default event QShowEvent Event that has been triggered required Source code in src/cplus_plugin/settings.py 399 400 401 402 403 404 405 406 def closeEvent ( self , event : QShowEvent ) -> None : \"\"\"When closing the setings. :param event: Event that has been triggered :type event: QShowEvent \"\"\" super () . closeEvent ( event ) load_settings load_settings () Loads the settings and displays it in the options UI Source code in src/cplus_plugin/settings.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 def load_settings ( self ) -> None : \"\"\"Loads the settings and displays it in the options UI\"\"\" # Analysis configuration settings # Report settings organization = settings_manager . get_value ( Settings . REPORT_ORGANIZATION , default = \"\" ) self . txt_organization . setText ( organization ) email = settings_manager . get_value ( Settings . REPORT_CONTACT_EMAIL , default = \"\" ) self . txt_email . setText ( email ) website = settings_manager . get_value ( Settings . REPORT_WEBSITE , default = \"\" ) self . txt_website . setText ( website ) custom_logo = int ( settings_manager . get_value ( Settings . REPORT_CUSTOM_LOGO , default = True , ) ) self . cb_custom_logo . setCheckState ( custom_logo ) self . logo_file . setEnabled ( custom_logo ) custom_logo_dir = settings_manager . get_value ( Settings . REPORT_LOGO_DIR , default = DEFAULT_LOGO_PATH ) self . logo_file . setFilePath ( custom_logo_dir ) self . update_logo ( custom_logo , custom_logo_dir ) footer = settings_manager . get_value ( Settings . REPORT_FOOTER , default = \"\" ) self . txt_footer . setPlainText ( footer ) disclaimer = settings_manager . get_value ( Settings . REPORT_DISCLAIMER , default = \"\" ) self . txt_disclaimer . setPlainText ( disclaimer ) report_license = settings_manager . get_value ( Settings . REPORT_LICENSE , default = \"\" ) self . txt_license . setText ( report_license ) # Advanced settings base_dir = settings_manager . get_value ( Settings . BASE_DIR , default = \"\" ) self . folder_data . setFilePath ( base_dir ) self . base_dir_exists () # Carbon layers coefficient coefficient = settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) self . carbon_coefficient_box . setValue ( float ( coefficient )) # Pathway suitability index pathway_suitability_index = settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) self . suitability_index_box . setValue ( float ( pathway_suitability_index )) # Snapping settings self . snapping_group_box . setChecked ( settings_manager . get_value ( Settings . SNAPPING_ENABLED , default = False , setting_type = bool ) ) snap_layer_path = settings_manager . get_value ( Settings . SNAP_LAYER , default = \"\" ) self . map_layer_file_widget . setFilePath ( snap_layer_path ) self . rescale_values . setChecked ( settings_manager . get_value ( Settings . RESCALE_VALUES , default = False , setting_type = bool ) ) self . resample_method_box . setCurrentIndex ( int ( settings_manager . get_value ( Settings . RESAMPLING_METHOD , default = 0 )) ) logo_file_changed logo_file_changed () Called when the logo file directory changes. Will update the logo preview. Source code in src/cplus_plugin/settings.py 179 180 181 182 183 184 185 186 def logo_file_changed ( self ): \"\"\"Called when the logo file directory changes. Will update the logo preview. \"\"\" custom_logo = self . cb_custom_logo . checkState () custom_logo_path = self . logo_file . filePath () self . update_logo ( custom_logo , custom_logo_path ) logo_file_exists logo_file_exists () Checks if the provided logo directory exists. A warning messages is presented if the file cannot be found. Returns: Type Description bool Whether the logo file exists Source code in src/cplus_plugin/settings.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def logo_file_exists ( self ) -> bool : \"\"\"Checks if the provided logo directory exists. A warning messages is presented if the file cannot be found. :returns: Whether the logo file exists :rtype: bool \"\"\" # Clears the error messages when doing next check self . message_bar . clearWidgets () file_found = False custom_logo_path = self . logo_file . filePath () if not os . path . exists ( custom_logo_path ): # File not found self . message_bar . pushWarning ( \"CPLUS - Custom logo not found: \" , custom_logo_path ) else : file_found = True # File found return file_found logo_state_changed logo_state_changed () Called when the custom logo option is disabled or enabled. Will update the logo preview. Source code in src/cplus_plugin/settings.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def logo_state_changed ( self ) -> None : \"\"\"Called when the custom logo option is disabled or enabled. Will update the logo preview. \"\"\" custom_logo = self . cb_custom_logo . checkState () custom_logo_path = self . logo_file . filePath () # Enables/disables the file widget for the logo directory if custom_logo : self . logo_file . setEnabled ( True ) else : self . logo_file . setEnabled ( False ) self . update_logo ( custom_logo , custom_logo_path ) map_layer_changed map_layer_changed ( layer ) Sets the file path of the selected layer in file path input Parameters: Name Type Description Default layer QgsMapLayer Qgis map layer required Source code in src/cplus_plugin/settings.py 113 114 115 116 117 118 119 120 def map_layer_changed ( self , layer ): \"\"\"Sets the file path of the selected layer in file path input :param layer: Qgis map layer :type layer: QgsMapLayer \"\"\" if layer is not None : self . map_layer_file_widget . setFilePath ( layer . source ()) on_settings_changed on_settings_changed ( name , value ) Slot raised when settings has been changed. Parameters: Name Type Description Default name str Name of the setting that has changed. required value Any New value for the given settings name. required Source code in src/cplus_plugin/settings.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def on_settings_changed ( self , name : str , value : typing . Any ): \"\"\"Slot raised when settings has been changed. :param name: Name of the setting that has changed. :type name: str :param value: New value for the given settings name. :type value: Any \"\"\" # Create NCS pathway subdirectory if base directory has changed. if name == Settings . BASE_DIR . value : if not value : return FileUtils . create_ncs_pathways_dir ( value ) FileUtils . create_ncs_carbon_dir ( value ) FileUtils . create_pwls_dir ( value ) save_settings save_settings () Saves the settings. Also does error checking for settings (e.g if the custom logo exists). Will present the user with an error message if an issue is found. Source code in src/cplus_plugin/settings.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def save_settings ( self ) -> None : \"\"\"Saves the settings. Also does error checking for settings (e.g if the custom logo exists). Will present the user with an error message if an issue is found. \"\"\" # Analysis configuration # Report settings organization = self . txt_organization . text () settings_manager . set_value ( Settings . REPORT_ORGANIZATION , organization ) email = self . txt_email . text () settings_manager . set_value ( Settings . REPORT_CONTACT_EMAIL , email ) website = self . txt_website . text () settings_manager . set_value ( Settings . REPORT_WEBSITE , website ) custom_logo = self . cb_custom_logo . checkState () settings_manager . set_value ( Settings . REPORT_CUSTOM_LOGO , custom_logo ) # Checks if the logo file exists if custom logo is enabled if custom_logo : custom_logo_path = self . logo_file . filePath () settings_manager . set_value ( Settings . REPORT_LOGO_DIR , custom_logo_path ) if not os . path . exists ( custom_logo_path ): # File not found, disable custom logo settings_manager . set_value ( Settings . REPORT_CUSTOM_LOGO , False ) iface . messageBar () . pushWarning ( \"CPLUS - Custom logo not found, disabled: \" , custom_logo_path ) footer = self . txt_footer . toPlainText () settings_manager . set_value ( Settings . REPORT_FOOTER , footer ) disclaimer = self . txt_disclaimer . toPlainText () settings_manager . set_value ( Settings . REPORT_DISCLAIMER , disclaimer ) report_license = self . txt_license . text () settings_manager . set_value ( Settings . REPORT_LICENSE , report_license ) # Advanced settings base_dir_path = self . folder_data . filePath () settings_manager . set_value ( Settings . BASE_DIR , base_dir_path ) # Carbon layers coefficient saving coefficient = self . carbon_coefficient_box . value () settings_manager . set_value ( Settings . CARBON_COEFFICIENT , coefficient ) # Pathway suitability index pathway_suitability_index = self . suitability_index_box . value () settings_manager . set_value ( Settings . PATHWAY_SUITABILITY_INDEX , pathway_suitability_index ) # Snapping settings saving settings_manager . set_value ( Settings . SNAPPING_ENABLED , self . snapping_group_box . isChecked () ) snap_layer_path = self . map_layer_file_widget . filePath () settings_manager . set_value ( Settings . SNAP_LAYER , snap_layer_path ) settings_manager . set_value ( Settings . RESCALE_VALUES , self . rescale_values . isChecked () ) settings_manager . set_value ( Settings . RESAMPLING_METHOD , self . resample_method_box . currentIndex () ) # Checks if the provided base directory exists if not os . path . exists ( base_dir_path ): iface . messageBar () . pushCritical ( \"CPLUS - Base directory not found: \" , base_dir_path ) showEvent showEvent ( event ) Show event being called. This will display the plugin settings. The stored/saved settings will be loaded. Parameters: Name Type Description Default event QShowEvent Event that has been triggered required Source code in src/cplus_plugin/settings.py 388 389 390 391 392 393 394 395 396 397 def showEvent ( self , event : QShowEvent ) -> None : \"\"\"Show event being called. This will display the plugin settings. The stored/saved settings will be loaded. :param event: Event that has been triggered :type event: QShowEvent \"\"\" super () . showEvent ( event ) self . load_settings () update_logo update_logo ( custom_logo , logo_dir = DEFAULT_LOGO_PATH ) Updates the logo preview. If the logo is not found, the default logo will be used. Parameters: Name Type Description Default custom_logo bool If a custom logo should be used required logo_dir str The custom logo directory DEFAULT_LOGO_PATH Source code in src/cplus_plugin/settings.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def update_logo ( self , custom_logo , logo_dir = DEFAULT_LOGO_PATH ): \"\"\"Updates the logo preview. If the logo is not found, the default logo will be used. :param custom_logo: If a custom logo should be used :type custom_logo: bool :param logo_dir: The custom logo directory :type logo_dir: str \"\"\" logo_found = False if custom_logo : # If custom logo is active, check if the provided directory exists logo_found = self . logo_file_exists () if custom_logo and logo_found : # If custom logo is enabled and the logo file exists pixmap = QPixmap ( logo_dir ) else : # If custom logo is disabled. The default logo will also be used when the custom logo does not exist pixmap = QPixmap ( DEFAULT_LOGO_PATH ) self . lbl_logo_image . setPixmap ( pixmap )","title":"Settings"},{"location":"developer/api/core/api_settings/#settings","text":"Plugin global settings. Covers the plugin global settings which a user can set and save. The settings will be saved using QgsSettings. Settings can be accessed via the QGIS options, a button on the docking widget, and from the toolbar menu.","title":"Settings"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusOptionsFactory","text":"CplusOptionsFactory () Bases: QgsOptionsWidgetFactory Options factory initializes the CPLUS settings. Class which creates the widget requied for the CPLUS settings. QgsOptionsWidgetFactory is used to accomplish this. QGIS CPLUS Plugin Settings factory. Source code in src/cplus_plugin/settings.py 416 417 418 419 420 def __init__ ( self ) -> None : \"\"\"QGIS CPLUS Plugin Settings factory.\"\"\" super () . __init__ () self . setTitle ( OPTIONS_TITLE )","title":"CplusOptionsFactory"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusOptionsFactory.createWidget","text":"createWidget ( parent ) Creates a widget for CPLUS settings. Parameters: Name Type Description Default parent QWidget Parent widget required Returns: Type Description CplusSettings Widget to be used in the QGIS options Source code in src/cplus_plugin/settings.py 431 432 433 434 435 436 437 438 439 440 441 def createWidget ( self , parent : QWidget ) -> CplusSettings : \"\"\"Creates a widget for CPLUS settings. :param parent: Parent widget :type parent: QWidget :returns: Widget to be used in the QGIS options :rtype: CplusSettings \"\"\" return CplusSettings ( parent )","title":"createWidget()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusOptionsFactory.icon","text":"icon () Returns the icon which will be used for the CPLUS options tab. Returns: Type Description QIcon An icon object which contains the provided custom icon Source code in src/cplus_plugin/settings.py 422 423 424 425 426 427 428 429 def icon ( self ) -> QIcon : \"\"\"Returns the icon which will be used for the CPLUS options tab. :returns: An icon object which contains the provided custom icon :rtype: QIcon \"\"\" return QIcon ( ICON_PATH )","title":"icon()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings","text":"CplusSettings ( parent = None ) Bases: Ui_DlgSettings , QgsOptionsPageWidget QGIS CPLUS Plugin Settings dialog. Source code in src/cplus_plugin/settings.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def __init__ ( self , parent = None ) -> None : \"\"\"QGIS CPLUS Plugin Settings dialog.\"\"\" QgsOptionsPageWidget . __init__ ( self , parent ) self . setupUi ( self ) self . message_bar = qgis . gui . QgsMessageBar ( self ) self . layout () . insertWidget ( 0 , self . message_bar ) self . settings = qgis . core . QgsSettings () settings_manager . settings_updated [ str , object ] . connect ( self . on_settings_changed ) # Connections self . cb_custom_logo . stateChanged . connect ( self . logo_state_changed ) self . logo_file . fileChanged . connect ( self . logo_file_changed ) self . folder_data . fileChanged . connect ( self . base_dir_exists ) self . map_layer_file_widget . setStorageMode ( QgsFileWidget . StorageMode . GetFile ) self . map_layer_box . layerChanged . connect ( self . map_layer_changed ) self . resample_method_box . addItem ( tr ( \"Nearest Neighbour\" ), QgsAlignRaster . ResampleAlg . RA_NearestNeighbour ) self . resample_method_box . addItem ( tr ( \"Bilinear (2x2 Kernel)\" ), QgsAlignRaster . ResampleAlg . RA_Bilinear ) self . resample_method_box . addItem ( tr ( \"Cubic (4x4 Kernel)\" ), QgsAlignRaster . ResampleAlg . RA_Cubic ) self . resample_method_box . addItem ( tr ( \"Cubic B-Spline (4x4 Kernel)\" ), QgsAlignRaster . ResampleAlg . RA_CubicSpline ) self . resample_method_box . addItem ( tr ( \"Lanczos (6x6 Kernel)\" ), QgsAlignRaster . ResampleAlg . RA_Lanczos ) self . resample_method_box . addItem ( tr ( \"Average\" ), QgsAlignRaster . ResampleAlg . RA_Average ) self . resample_method_box . addItem ( tr ( \"Mode\" ), QgsAlignRaster . ResampleAlg . RA_Mode ) self . resample_method_box . addItem ( tr ( \"Maximum\" ), QgsAlignRaster . ResampleAlg . RA_Max ) self . resample_method_box . addItem ( tr ( \"Minimum\" ), QgsAlignRaster . ResampleAlg . RA_Min ) self . resample_method_box . addItem ( tr ( \"Median\" ), QgsAlignRaster . ResampleAlg . RA_Median ) self . resample_method_box . addItem ( tr ( \"First Quartile (Q1)\" ), QgsAlignRaster . ResampleAlg . RA_Q1 ) self . resample_method_box . addItem ( tr ( \"Third Quartile (Q3)\" ), QgsAlignRaster . ResampleAlg . RA_Q3 )","title":"CplusSettings"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.message_bar","text":"message_bar = qgis . gui . QgsMessageBar ( self ) CPLUS plugin settings class. Class which manages the CPLUS settings. Initilizes the UI, which can be accessed from the menu drop-down or the QGIS settings.","title":"message_bar"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.apply","text":"apply () This is called on OK click in the QGIS options panel. Source code in src/cplus_plugin/settings.py 108 109 110 111 def apply ( self ) -> None : \"\"\"This is called on OK click in the QGIS options panel.\"\"\" self . save_settings ()","title":"apply()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.base_dir_exists","text":"base_dir_exists () Checks if the provided base directory exists. A warning messages is presented if the directory does not exist. Returns: Type Description bool Whether the base directory exists Source code in src/cplus_plugin/settings.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def base_dir_exists ( self ) -> bool : \"\"\"Checks if the provided base directory exists. A warning messages is presented if the directory does not exist. :returns: Whether the base directory exists :rtype: bool \"\"\" # Clears the error messages when doing next check self . message_bar . clearWidgets () folder_found = False base_dir_path = self . folder_data . filePath () if not os . path . exists ( base_dir_path ): # File not found self . message_bar . pushWarning ( \"CPLUS - Base directory not found: \" , base_dir_path ) else : folder_found = True return folder_found","title":"base_dir_exists()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.closeEvent","text":"closeEvent ( event ) When closing the setings. Parameters: Name Type Description Default event QShowEvent Event that has been triggered required Source code in src/cplus_plugin/settings.py 399 400 401 402 403 404 405 406 def closeEvent ( self , event : QShowEvent ) -> None : \"\"\"When closing the setings. :param event: Event that has been triggered :type event: QShowEvent \"\"\" super () . closeEvent ( event )","title":"closeEvent()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.load_settings","text":"load_settings () Loads the settings and displays it in the options UI Source code in src/cplus_plugin/settings.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 def load_settings ( self ) -> None : \"\"\"Loads the settings and displays it in the options UI\"\"\" # Analysis configuration settings # Report settings organization = settings_manager . get_value ( Settings . REPORT_ORGANIZATION , default = \"\" ) self . txt_organization . setText ( organization ) email = settings_manager . get_value ( Settings . REPORT_CONTACT_EMAIL , default = \"\" ) self . txt_email . setText ( email ) website = settings_manager . get_value ( Settings . REPORT_WEBSITE , default = \"\" ) self . txt_website . setText ( website ) custom_logo = int ( settings_manager . get_value ( Settings . REPORT_CUSTOM_LOGO , default = True , ) ) self . cb_custom_logo . setCheckState ( custom_logo ) self . logo_file . setEnabled ( custom_logo ) custom_logo_dir = settings_manager . get_value ( Settings . REPORT_LOGO_DIR , default = DEFAULT_LOGO_PATH ) self . logo_file . setFilePath ( custom_logo_dir ) self . update_logo ( custom_logo , custom_logo_dir ) footer = settings_manager . get_value ( Settings . REPORT_FOOTER , default = \"\" ) self . txt_footer . setPlainText ( footer ) disclaimer = settings_manager . get_value ( Settings . REPORT_DISCLAIMER , default = \"\" ) self . txt_disclaimer . setPlainText ( disclaimer ) report_license = settings_manager . get_value ( Settings . REPORT_LICENSE , default = \"\" ) self . txt_license . setText ( report_license ) # Advanced settings base_dir = settings_manager . get_value ( Settings . BASE_DIR , default = \"\" ) self . folder_data . setFilePath ( base_dir ) self . base_dir_exists () # Carbon layers coefficient coefficient = settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) self . carbon_coefficient_box . setValue ( float ( coefficient )) # Pathway suitability index pathway_suitability_index = settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) self . suitability_index_box . setValue ( float ( pathway_suitability_index )) # Snapping settings self . snapping_group_box . setChecked ( settings_manager . get_value ( Settings . SNAPPING_ENABLED , default = False , setting_type = bool ) ) snap_layer_path = settings_manager . get_value ( Settings . SNAP_LAYER , default = \"\" ) self . map_layer_file_widget . setFilePath ( snap_layer_path ) self . rescale_values . setChecked ( settings_manager . get_value ( Settings . RESCALE_VALUES , default = False , setting_type = bool ) ) self . resample_method_box . setCurrentIndex ( int ( settings_manager . get_value ( Settings . RESAMPLING_METHOD , default = 0 )) )","title":"load_settings()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.logo_file_changed","text":"logo_file_changed () Called when the logo file directory changes. Will update the logo preview. Source code in src/cplus_plugin/settings.py 179 180 181 182 183 184 185 186 def logo_file_changed ( self ): \"\"\"Called when the logo file directory changes. Will update the logo preview. \"\"\" custom_logo = self . cb_custom_logo . checkState () custom_logo_path = self . logo_file . filePath () self . update_logo ( custom_logo , custom_logo_path )","title":"logo_file_changed()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.logo_file_exists","text":"logo_file_exists () Checks if the provided logo directory exists. A warning messages is presented if the file cannot be found. Returns: Type Description bool Whether the logo file exists Source code in src/cplus_plugin/settings.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def logo_file_exists ( self ) -> bool : \"\"\"Checks if the provided logo directory exists. A warning messages is presented if the file cannot be found. :returns: Whether the logo file exists :rtype: bool \"\"\" # Clears the error messages when doing next check self . message_bar . clearWidgets () file_found = False custom_logo_path = self . logo_file . filePath () if not os . path . exists ( custom_logo_path ): # File not found self . message_bar . pushWarning ( \"CPLUS - Custom logo not found: \" , custom_logo_path ) else : file_found = True # File found return file_found","title":"logo_file_exists()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.logo_state_changed","text":"logo_state_changed () Called when the custom logo option is disabled or enabled. Will update the logo preview. Source code in src/cplus_plugin/settings.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def logo_state_changed ( self ) -> None : \"\"\"Called when the custom logo option is disabled or enabled. Will update the logo preview. \"\"\" custom_logo = self . cb_custom_logo . checkState () custom_logo_path = self . logo_file . filePath () # Enables/disables the file widget for the logo directory if custom_logo : self . logo_file . setEnabled ( True ) else : self . logo_file . setEnabled ( False ) self . update_logo ( custom_logo , custom_logo_path )","title":"logo_state_changed()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.map_layer_changed","text":"map_layer_changed ( layer ) Sets the file path of the selected layer in file path input Parameters: Name Type Description Default layer QgsMapLayer Qgis map layer required Source code in src/cplus_plugin/settings.py 113 114 115 116 117 118 119 120 def map_layer_changed ( self , layer ): \"\"\"Sets the file path of the selected layer in file path input :param layer: Qgis map layer :type layer: QgsMapLayer \"\"\" if layer is not None : self . map_layer_file_widget . setFilePath ( layer . source ())","title":"map_layer_changed()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.on_settings_changed","text":"on_settings_changed ( name , value ) Slot raised when settings has been changed. Parameters: Name Type Description Default name str Name of the setting that has changed. required value Any New value for the given settings name. required Source code in src/cplus_plugin/settings.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def on_settings_changed ( self , name : str , value : typing . Any ): \"\"\"Slot raised when settings has been changed. :param name: Name of the setting that has changed. :type name: str :param value: New value for the given settings name. :type value: Any \"\"\" # Create NCS pathway subdirectory if base directory has changed. if name == Settings . BASE_DIR . value : if not value : return FileUtils . create_ncs_pathways_dir ( value ) FileUtils . create_ncs_carbon_dir ( value ) FileUtils . create_pwls_dir ( value )","title":"on_settings_changed()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.save_settings","text":"save_settings () Saves the settings. Also does error checking for settings (e.g if the custom logo exists). Will present the user with an error message if an issue is found. Source code in src/cplus_plugin/settings.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def save_settings ( self ) -> None : \"\"\"Saves the settings. Also does error checking for settings (e.g if the custom logo exists). Will present the user with an error message if an issue is found. \"\"\" # Analysis configuration # Report settings organization = self . txt_organization . text () settings_manager . set_value ( Settings . REPORT_ORGANIZATION , organization ) email = self . txt_email . text () settings_manager . set_value ( Settings . REPORT_CONTACT_EMAIL , email ) website = self . txt_website . text () settings_manager . set_value ( Settings . REPORT_WEBSITE , website ) custom_logo = self . cb_custom_logo . checkState () settings_manager . set_value ( Settings . REPORT_CUSTOM_LOGO , custom_logo ) # Checks if the logo file exists if custom logo is enabled if custom_logo : custom_logo_path = self . logo_file . filePath () settings_manager . set_value ( Settings . REPORT_LOGO_DIR , custom_logo_path ) if not os . path . exists ( custom_logo_path ): # File not found, disable custom logo settings_manager . set_value ( Settings . REPORT_CUSTOM_LOGO , False ) iface . messageBar () . pushWarning ( \"CPLUS - Custom logo not found, disabled: \" , custom_logo_path ) footer = self . txt_footer . toPlainText () settings_manager . set_value ( Settings . REPORT_FOOTER , footer ) disclaimer = self . txt_disclaimer . toPlainText () settings_manager . set_value ( Settings . REPORT_DISCLAIMER , disclaimer ) report_license = self . txt_license . text () settings_manager . set_value ( Settings . REPORT_LICENSE , report_license ) # Advanced settings base_dir_path = self . folder_data . filePath () settings_manager . set_value ( Settings . BASE_DIR , base_dir_path ) # Carbon layers coefficient saving coefficient = self . carbon_coefficient_box . value () settings_manager . set_value ( Settings . CARBON_COEFFICIENT , coefficient ) # Pathway suitability index pathway_suitability_index = self . suitability_index_box . value () settings_manager . set_value ( Settings . PATHWAY_SUITABILITY_INDEX , pathway_suitability_index ) # Snapping settings saving settings_manager . set_value ( Settings . SNAPPING_ENABLED , self . snapping_group_box . isChecked () ) snap_layer_path = self . map_layer_file_widget . filePath () settings_manager . set_value ( Settings . SNAP_LAYER , snap_layer_path ) settings_manager . set_value ( Settings . RESCALE_VALUES , self . rescale_values . isChecked () ) settings_manager . set_value ( Settings . RESAMPLING_METHOD , self . resample_method_box . currentIndex () ) # Checks if the provided base directory exists if not os . path . exists ( base_dir_path ): iface . messageBar () . pushCritical ( \"CPLUS - Base directory not found: \" , base_dir_path )","title":"save_settings()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.showEvent","text":"showEvent ( event ) Show event being called. This will display the plugin settings. The stored/saved settings will be loaded. Parameters: Name Type Description Default event QShowEvent Event that has been triggered required Source code in src/cplus_plugin/settings.py 388 389 390 391 392 393 394 395 396 397 def showEvent ( self , event : QShowEvent ) -> None : \"\"\"Show event being called. This will display the plugin settings. The stored/saved settings will be loaded. :param event: Event that has been triggered :type event: QShowEvent \"\"\" super () . showEvent ( event ) self . load_settings ()","title":"showEvent()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.update_logo","text":"update_logo ( custom_logo , logo_dir = DEFAULT_LOGO_PATH ) Updates the logo preview. If the logo is not found, the default logo will be used. Parameters: Name Type Description Default custom_logo bool If a custom logo should be used required logo_dir str The custom logo directory DEFAULT_LOGO_PATH Source code in src/cplus_plugin/settings.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def update_logo ( self , custom_logo , logo_dir = DEFAULT_LOGO_PATH ): \"\"\"Updates the logo preview. If the logo is not found, the default logo will be used. :param custom_logo: If a custom logo should be used :type custom_logo: bool :param logo_dir: The custom logo directory :type logo_dir: str \"\"\" logo_found = False if custom_logo : # If custom logo is active, check if the provided directory exists logo_found = self . logo_file_exists () if custom_logo and logo_found : # If custom logo is enabled and the logo file exists pixmap = QPixmap ( logo_dir ) else : # If custom logo is disabled. The default logo will also be used when the custom logo does not exist pixmap = QPixmap ( DEFAULT_LOGO_PATH ) self . lbl_logo_image . setPixmap ( pixmap )","title":"update_logo()"},{"location":"developer/api/core/api_tasks/","text":"Processing Tasks ScenarioAnalysisTask ScenarioAnalysisTask ( analysis_scenario_name , analysis_scenario_description , analysis_implementation_models , analysis_priority_layers_groups , analysis_extent , scenario ) Bases: QgsTask Prepares and runs the scenario analysis Source code in src/cplus_plugin/tasks.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def __init__ ( self , analysis_scenario_name , analysis_scenario_description , analysis_implementation_models , analysis_priority_layers_groups , analysis_extent , scenario , ): super () . __init__ () self . analysis_scenario_name = analysis_scenario_name self . analysis_scenario_description = analysis_scenario_description self . analysis_implementation_models = analysis_implementation_models self . analysis_priority_layers_groups = analysis_priority_layers_groups self . analysis_extent = analysis_extent self . analysis_extent_string = None self . analysis_weighted_ims = [] self . scenario_result = None self . scenario_directory = None self . success = True self . output = None self . error = None self . status_message = None self . info_message = None self . processing_cancelled = False self . feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () self . scenario = scenario align_extent align_extent ( raster_layer , target_extent ) Snaps the passed extent to the models pathway layer pixel bounds Parameters: Name Type Description Default raster_layer QgsRasterLayer The target layer that the passed extent will be aligned with required extent QgsRectangle Spatial extent that will be used a target extent when doing alignment. required Source code in src/cplus_plugin/tasks.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def align_extent ( self , raster_layer , target_extent ): \"\"\"Snaps the passed extent to the models pathway layer pixel bounds :param raster_layer: The target layer that the passed extent will be aligned with :type raster_layer: QgsRasterLayer :param extent: Spatial extent that will be used a target extent when doing alignment. :type extent: QgsRectangle \"\"\" try : raster_extent = raster_layer . extent () x_res = raster_layer . rasterUnitsPerPixelX () y_res = raster_layer . rasterUnitsPerPixelY () left = raster_extent . xMinimum () + x_res * math . floor ( ( target_extent . xMinimum () - raster_extent . xMinimum ()) / x_res ) right = raster_extent . xMinimum () + x_res * math . ceil ( ( target_extent . xMaximum () - raster_extent . xMinimum ()) / x_res ) bottom = raster_extent . yMinimum () + y_res * math . floor ( ( target_extent . yMinimum () - raster_extent . yMinimum ()) / y_res ) top = raster_extent . yMaximum () - y_res * math . floor ( ( raster_extent . yMaximum () - target_extent . yMaximum ()) / y_res ) return QgsRectangle ( left , bottom , right , top ) except Exception as e : log ( tr ( f \"Problem snapping area of \" f \"interest extent, using the original extent,\" f \" { str ( e ) } \" ) ) return target_extent finished finished ( result ) Calls the handler responsible for doing post analysis workflow. Parameters: Name Type Description Default result bool Whether the run() operation finished successfully required Source code in src/cplus_plugin/tasks.py 226 227 228 229 230 231 232 233 234 235 def finished ( self , result : bool ): \"\"\"Calls the handler responsible for doing post analysis workflow. :param result: Whether the run() operation finished successfully :type result: bool \"\"\" if result : log ( \"Finished from the main task \\n \" ) else : log ( f \"Error from task scenario task { self . error } \" ) replace_nodata replace_nodata ( layer_path , output_path , nodata_value ) Adds nodata value info into the layer available in the passed layer_path and save the layer in the passed output_path path. The addition will replace any current nodata value available in the input layer. Parameters: Name Type Description Default layer_path str Input layer path required output_path str Output layer path required nodata_value Nodata value to be used required Returns: Type Description bool If the process was successful Source code in src/cplus_plugin/tasks.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def replace_nodata ( self , layer_path , output_path , nodata_value ): \"\"\"Adds nodata value info into the layer available in the passed layer_path and save the layer in the passed output_path path. The addition will replace any current nodata value available in the input layer. :param layer_path: Input layer path :type layer_path: str :param output_path: Output layer path :type output_path: str :param nodata_value: Nodata value to be used :type output_path: int :returns: If the process was successful :rtype: bool \"\"\" self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) alg_params = { \"COPY_SUBDATASETS\" : False , \"DATA_TYPE\" : 6 , # Float32 \"EXTRA\" : \"\" , \"INPUT\" : layer_path , \"NODATA\" : None , \"OPTIONS\" : \"\" , \"TARGET_CRS\" : None , \"OUTPUT\" : QgsProcessing . TEMPORARY_OUTPUT , } translate_output = processing . run ( \"gdal:translate\" , alg_params , context = self . processing_context , feedback = self . feedback , is_child_algorithm = True , ) alg_params = { \"DATA_TYPE\" : 0 , # Use Input Layer Data Type \"EXTRA\" : \"\" , \"INPUT\" : translate_output [ \"OUTPUT\" ], \"MULTITHREADING\" : False , \"NODATA\" : - 9999 , \"OPTIONS\" : \"\" , \"RESAMPLING\" : 0 , # Nearest Neighbour \"SOURCE_CRS\" : None , \"TARGET_CRS\" : None , \"TARGET_EXTENT\" : None , \"TARGET_EXTENT_CRS\" : None , \"TARGET_RESOLUTION\" : None , \"OUTPUT\" : output_path , } outputs = processing . run ( \"gdal:warpreproject\" , alg_params , context = self . processing_context , feedback = self . feedback , is_child_algorithm = True , ) return outputs is not None run run () Runs the main scenario analysis task operations Source code in src/cplus_plugin/tasks.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def run ( self ): \"\"\"Runs the main scenario analysis task operations\"\"\" base_dir = settings_manager . get_value ( Settings . BASE_DIR ) self . scenario_directory = os . path . join ( f \" { base_dir } \" , f 'scenario_ { datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' , ) FileUtils . create_new_dir ( self . scenario_directory ) selected_pathway = None pathway_found = False for model in self . analysis_implementation_models : if pathway_found : break for pathway in model . pathways : if pathway is not None : pathway_found = True selected_pathway = pathway break target_layer = QgsRasterLayer ( selected_pathway . path , selected_pathway . name ) dest_crs = ( target_layer . crs () if selected_pathway and selected_pathway . path else QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) ) processing_extent = QgsRectangle ( float ( self . analysis_extent . bbox [ 0 ]), float ( self . analysis_extent . bbox [ 2 ]), float ( self . analysis_extent . bbox [ 1 ]), float ( self . analysis_extent . bbox [ 3 ]), ) snapped_extent = self . align_extent ( target_layer , processing_extent ) extent_string = ( f \" { snapped_extent . xMinimum () } , { snapped_extent . xMaximum () } ,\" f \" { snapped_extent . yMinimum () } , { snapped_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) log ( f \"Original area of interest extent: { processing_extent . asWktPolygon () } \\n \" ) log ( f \"Snapped area of interest extent { snapped_extent . asWktPolygon () } \\n \" ) # Run pathways layers snapping using a specified reference layer snapping_enabled = settings_manager . get_value ( Settings . SNAPPING_ENABLED , default = False , setting_type = bool ) reference_layer = settings_manager . get_value ( Settings . SNAP_LAYER , default = \"\" ) reference_layer_path = Path ( reference_layer ) if ( snapping_enabled and os . path . exists ( reference_layer ) and reference_layer_path . is_file () ): self . snap_analysis_data ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) # Preparing all the pathways by adding them together with # their carbon layers before creating # their respective models. self . run_pathways_analysis ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) # Normalizing all the models pathways using the carbon coefficient and # the pathway suitability index self . run_pathways_normalization ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) # Creating models from the normalized pathways self . run_models_analysis ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) # After creating models, we normalize them using the same coefficients # used in normalizing their respective pathways. self . run_models_normalization ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) # Weighting the models with their corresponding priority weighting layers weighted_models , result = self . run_models_weighting ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) self . analysis_weighted_ims = weighted_models self . scenario . weighted_models = weighted_models # Post weighting analysis self . run_models_cleaning ( weighted_models , extent_string ) # The highest position tool analysis self . run_highest_position_analysis () return True run_highest_position_analysis run_highest_position_analysis () Runs the highest position analysis which is last step in scenario analysis. Uses the models set by the current ongoing analysis. Source code in src/cplus_plugin/tasks.py 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 def run_highest_position_analysis ( self ): \"\"\"Runs the highest position analysis which is last step in scenario analysis. Uses the models set by the current ongoing analysis. \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return passed_extent_box = self . analysis_extent . bbox passed_extent = QgsRectangle ( passed_extent_box [ 0 ], passed_extent_box [ 2 ], passed_extent_box [ 1 ], passed_extent_box [ 3 ], ) self . scenario_result = ScenarioResult ( scenario = self . scenario , scenario_directory = self . scenario_directory ) try : layers = {} self . set_status_message ( tr ( \"Calculating the highest position\" )) for model in self . analysis_weighted_ims : if model . path is not None and model . path is not \"\" : raster_layer = QgsRasterLayer ( model . path , model . name ) layers [ model . name ] = ( raster_layer if raster_layer is not None else None ) else : for pathway in model . pathways : layers [ model . name ] = QgsRasterLayer ( pathway . path ) source_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) dest_crs = list ( layers . values ())[ 0 ] . crs () if len ( layers ) > 0 else source_crs extent_string = ( f \" { passed_extent . xMinimum () } , { passed_extent . xMaximum () } ,\" f \" { passed_extent . yMinimum () } , { passed_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) output_file = os . path . join ( self . scenario_directory , f \" { SCENARIO_OUTPUT_FILE_NAME } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) # Preparing the input rasters for the highest position # analysis in a correct order models_names = [ model . name for model in self . analysis_weighted_ims ] all_models = sorted ( self . analysis_weighted_ims , key = lambda model_instance : model_instance . style_pixel_value , ) for index , model in enumerate ( all_models ): model . style_pixel_value = index + 1 all_models_names = [ model . name for model in all_models ] sources = [] for model_name in all_models_names : if model_name in models_names : sources . append ( layers [ model_name ] . source ()) log ( f \"Layers sources { [ Path ( source ) . stem for source in sources ] } \" ) alg_params = { \"IGNORE_NODATA\" : True , \"INPUT_RASTERS\" : sources , \"EXTENT\" : extent_string , \"OUTPUT_NODATA_VALUE\" : - 9999 , \"REFERENCE_LAYER\" : list ( layers . values ())[ 0 ] if len ( layers ) >= 1 else None , \"OUTPUT\" : output_file , } log ( f \"Used parameters for highest position analysis { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False self . output = processing . run ( \"native:highestpositioninrasterstack\" , alg_params , context = self . processing_context , feedback = self . feedback , ) except Exception as err : log ( tr ( \"An error occurred when running task for \" 'scenario analysis, error message \" {} \"' . format ( str ( err )) ) ) self . error = err self . cancel () return False return True run_models_analysis run_models_analysis ( models , priority_layers_groups , extent ) Runs the required model analysis on the passed implementation models. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent SpatialExtent selected extent from user required Source code in src/cplus_plugin/tasks.py 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 def run_models_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the required model analysis on the passed implementation models. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: SpatialExtent \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Creating implementation models layers from pathways\" ) ) try : for model in models : ims_directory = os . path . join ( self . scenario_directory , \"implementation_models\" ) FileUtils . create_new_dir ( ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) layers = [] if not model . pathways and ( model . path is None and model . path is \"\" ): self . set_info_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) return False output_file = os . path . join ( ims_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) # Due to the implementation models base class # model only one of the following blocks will be executed, # the implementation model either contain a path or # pathways if model . path is not None and model . path is not \"\" : layers = [ model . path ] for pathway in model . pathways : layers . append ( pathway . path ) # Actual processing calculation alg_params = { \"IGNORE_NODATA\" : True , \"INPUT\" : layers , \"EXTENT\" : extent , \"OUTPUT_NODATA_VALUE\" : - 9999 , \"REFERENCE_LAYER\" : layers [ 0 ] if len ( layers ) > 0 else None , \"STATISTIC\" : 0 , # Sum \"OUTPUT\" : output_file , } log ( f \"Used parameters for \" f \"implementation models generation: { alg_params } \\n \" ) feedback = QgsProcessingFeedback () feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"native:cellstatistics\" , alg_params , context = self . processing_context , feedback = self . feedback , ) model . path = results [ \"OUTPUT\" ] except Exception as e : log ( f \"Problem creating models layers, { e } \" ) self . error = e self . cancel () return False return True run_models_cleaning run_models_cleaning ( models , extent = None ) Cleans the weighted implementation models replacing zero values with no-data as they are not statistical meaningful for the scenario analysis. Parameters: Name Type Description Default extent str Selected extent from user None Source code in src/cplus_plugin/tasks.py 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 def run_models_cleaning ( self , models , extent = None ): \"\"\"Cleans the weighted implementation models replacing zero values with no-data as they are not statistical meaningful for the scenario analysis. :param extent: Selected extent from user :type extent: str \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Updating weighted implementation models values\" )) try : for model in models : if model . path is None or model . path is \"\" : self . set_info_message ( tr ( f \"Problem when running models updates, \" f \"there is no map layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"Problem when running models updates, \" f \"there is no map layer for the model { model . name } \" ) return False layers = [ model . path ] file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( self . scenario_directory , \"weighted_ims\" ) output_file = os . path . join ( output_file , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } _cleaned.tif\" ) # Actual processing calculation # The aim is to convert pixels values to no data, that is why we are # using the sum operation with only one layer. alg_params = { \"IGNORE_NODATA\" : True , \"INPUT\" : layers , \"EXTENT\" : extent , \"OUTPUT_NODATA_VALUE\" : 0 , \"REFERENCE_LAYER\" : layers [ 0 ] if len ( layers ) > 0 else None , \"STATISTIC\" : 0 , # Sum \"OUTPUT\" : output_file , } log ( f \"Used parameters for \" f \"updates on the weighted implementation models: { alg_params } \\n \" ) feedback = QgsProcessingFeedback () feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"native:cellstatistics\" , alg_params , context = self . processing_context , feedback = self . feedback , ) model . path = results [ \"OUTPUT\" ] except Exception as e : log ( f \"Problem cleaning implementation models, { e } \" ) self . error = e self . cancel () return False return True run_models_normalization run_models_normalization ( models , priority_layers_groups , extent ) Runs the normalization analysis on the models layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Model = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the analyzed implementation models required priority_layers_groups dict Used priority layers groups and their values required extent str Selected area of interest extent required Source code in src/cplus_plugin/tasks.py 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 def run_models_normalization ( self , models , priority_layers_groups , extent ): \"\"\"Runs the normalization analysis on the models layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Model = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. :param models: List of the analyzed implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: Selected area of interest extent :type extent: str \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Normalization of the implementation models\" )) try : for model in models : if model . path is None or model . path is \"\" : if not self . processing_cancelled : self . set_info_message ( tr ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ) else : # If the user cancelled the processing self . set_info_message ( tr ( f \"Processing has been cancelled by the user.\" ), level = Qgis . Critical , ) log ( f \"Processing has been cancelled by the user.\" ) return False layers = [] normalized_ims_directory = os . path . join ( self . scenario_directory , \"normalized_ims\" ) FileUtils . create_new_dir ( normalized_ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( normalized_ims_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) model_layer = QgsRasterLayer ( model . path , model . name ) provider = model_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue log ( f \"Found minimum { min_value } and \" f \"maximum { max_value } for model { model . name } \\n \" ) layer_name = Path ( model . path ) . stem layers . append ( model . path ) carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) normalization_index = carbon_coefficient + suitability_index if normalization_index > 0 : expression = ( f \" { normalization_index } * \" f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) else : expression = ( f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for normalization of the models: { alg_params } \\n \" ) feedback = QgsProcessingFeedback () feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) model . path = results [ \"OUTPUT\" ] except Exception as e : log ( f \"Problem normalizing models layers, { e } \\n \" ) self . error = e self . cancel () return False return True run_models_weighting run_models_weighting ( models , priority_layers_groups , extent ) Runs weighting analysis on the passed implementation models using the corresponding models weighting analysis. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent str selected extent from user required Source code in src/cplus_plugin/tasks.py 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 def run_models_weighting ( self , models , priority_layers_groups , extent ): \"\"\"Runs weighting analysis on the passed implementation models using the corresponding models weighting analysis. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: str \"\"\" if self . processing_cancelled : return [], False self . set_status_message ( tr ( f \"Weighting implementation models\" )) weighted_models = [] try : for original_model in models : model = clone_implementation_model ( original_model ) if model . path is None or model . path is \"\" : self . set_info_message ( tr ( f \"Problem when running models weighting, \" f \"there is no map layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ) return [], False basenames = [] layers = [] layers . append ( model . path ) basenames . append ( f '\" { Path ( model . path ) . stem } @1\"' ) if not any ( priority_layers_groups ): log ( f \"There are no defined priority layers in groups,\" f \" skipping models weighting step.\" ) self . run_models_cleaning ( extent ) return if model . priority_layers is None or model . priority_layers is []: log ( f \"There are no associated \" f \"priority weighting layers for model { model . name } \" ) continue settings_model = settings_manager . get_implementation_model ( str ( model . uuid ) ) for layer in settings_model . priority_layers : if layer is None : continue settings_layer = settings_manager . get_priority_layer ( layer . get ( \"uuid\" ) ) if settings_layer is None : continue pwl = settings_layer . get ( \"path\" ) missing_pwl_message = ( f \"Path { pwl } for priority \" f \"weighting layer { layer . get ( 'name' ) } \" f \"doesn't exist, skipping the layer \" f \"from the model { model . name } weighting.\" ) if pwl is None : log ( missing_pwl_message ) continue pwl_path = Path ( pwl ) if not pwl_path . exists (): log ( missing_pwl_message ) continue path_basename = pwl_path . stem for priority_layer in settings_manager . get_priority_layers (): if priority_layer . get ( \"name\" ) == layer . get ( \"name\" ): for group in priority_layer . get ( \"groups\" , []): value = group . get ( \"value\" ) coefficient = float ( value ) if coefficient > 0 : if pwl not in layers : layers . append ( pwl ) basenames . append ( f '( { coefficient } *\" { path_basename } @1\")' ) if basenames is []: return [], True weighted_ims_directory = os . path . join ( self . scenario_directory , \"weighted_ims\" ) FileUtils . create_new_dir ( weighted_ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( weighted_ims_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) expression = \" + \" . join ( basenames ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \" Used parameters for calculating weighting models { alg_params } \\n \" ) feedback = QgsProcessingFeedback () feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return [], False results = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) model . path = results [ \"OUTPUT\" ] weighted_models . append ( model ) except Exception as e : log ( f \"Problem weighting implementation models, { e } \\n \" ) self . error = e self . cancel () return None , False return weighted_models , True run_pathways_analysis run_pathways_analysis ( models , priority_layers_groups , extent ) Runs the required model pathways analysis on the passed implementation models. The analysis involves adding the pathways carbon layers into the pathway layer. If the pathway layer has more than one carbon layer, the resulting weighted pathway will contain the sum of the pathway layer values with the average of the pathway carbon layers values. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent SpatialExtent The selected extent from user required Source code in src/cplus_plugin/tasks.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 def run_pathways_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the required model pathways analysis on the passed implementation models. The analysis involves adding the pathways carbon layers into the pathway layer. If the pathway layer has more than one carbon layer, the resulting weighted pathway will contain the sum of the pathway layer values with the average of the pathway carbon layers values. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: The selected extent from user :type extent: SpatialExtent \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Adding models pathways with carbon layers\" )) pathways = [] models_paths = [] try : for model in models : if not model . pathways and ( model . path is None or model . path is \"\" ): self . set_info_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) return False for pathway in model . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) if model . path is not None and model . path is not \"\" : models_paths . append ( model . path ) if not pathways and len ( models_paths ) > 0 : self . run_pathways_normalization ( models , priority_layers_groups , extent ) return suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) for pathway in pathways : basenames = [] layers = [] path_basename = Path ( pathway . path ) . stem layers . append ( pathway . path ) file_name = clean_filename ( pathway . name . replace ( \" \" , \"_\" )) if suitability_index > 0 : basenames . append ( f ' { suitability_index } * \" { path_basename } @1\"' ) else : basenames . append ( f '\" { path_basename } @1\"' ) carbon_names = [] if len ( pathway . carbon_paths ) <= 0 : continue new_carbon_directory = os . path . join ( self . scenario_directory , \"pathways_carbon_layers\" ) FileUtils . create_new_dir ( new_carbon_directory ) output_file = os . path . join ( new_carbon_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) for carbon_path in pathway . carbon_paths : carbon_full_path = Path ( carbon_path ) if not carbon_full_path . exists (): continue layers . append ( carbon_path ) carbon_names . append ( f '\" { carbon_full_path . stem } @1\"' ) if len ( carbon_names ) == 1 and carbon_coefficient > 0 : basenames . append ( f \" { carbon_coefficient } * ( { carbon_names [ 0 ] } )\" ) # Setting up calculation to use carbon layers average when # a pathway has more than one carbon layer. if len ( carbon_names ) > 1 and carbon_coefficient > 0 : basenames . append ( f \" { carbon_coefficient } * (\" f '( { \" + \" . join ( carbon_names ) } ) / ' f \" { len ( pathway . carbon_paths ) } )\" ) expression = \" + \" . join ( basenames ) if carbon_coefficient <= 0 and suitability_index <= 0 : self . run_pathways_normalization ( models , priority_layers_groups , extent ) return # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for combining pathways\" f \" and carbon layers generation: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) # self.replace_nodata(results[\"OUTPUT\"], output_file, -9999) pathway . path = output_file except Exception as e : log ( f \"Problem running pathway analysis, { e } \" ) self . error = e self . cancel () return True run_pathways_normalization run_pathways_normalization ( models , priority_layers_groups , extent ) Runs the normalization on the models pathways layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Pathway = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the analyzed implementation models required priority_layers_groups dict Used priority layers groups and their values required extent str selected extent from user required Source code in src/cplus_plugin/tasks.py 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 def run_pathways_normalization ( self , models , priority_layers_groups , extent ): \"\"\"Runs the normalization on the models pathways layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Pathway = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. :param models: List of the analyzed implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: str \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Normalization of pathways\" )) pathways = [] models_paths = [] try : for model in models : if not model . pathways and ( model . path is None or model . path is \"\" ): self . set_info_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) return False for pathway in model . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) if model . path is not None and model . path is not \"\" : models_paths . append ( model . path ) if not pathways and len ( models_paths ) > 0 : self . run_models_analysis ( models , priority_layers_groups , extent ) return carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) normalization_index = carbon_coefficient + suitability_index for pathway in pathways : layers = [] normalized_pathways_directory = os . path . join ( self . scenario_directory , \"normalized_pathways\" ) FileUtils . create_new_dir ( normalized_pathways_directory ) file_name = clean_filename ( pathway . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( normalized_pathways_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) provider = pathway_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue layer_name = Path ( pathway . path ) . stem layers . append ( pathway . path ) log ( f \"Found minimum { min_value } and \" f \"maximum { max_value } for pathway \" f \" \\n \" ) if max_value < min_value : raise Exception ( tr ( f \"Pathway contains \" f \"invalid minimum and maxmum band values\" ) ) if normalization_index > 0 : expression = ( f \" { normalization_index } * \" f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) else : expression = ( f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for normalization of the pathways: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) # self.replace_nodata(results[\"OUTPUT\"], output_file, -9999) pathway . path = results [ \"OUTPUT\" ] except Exception as e : log ( f \"Problem normalizing pathways layers, { e } \\n \" ) self . error = e self . cancel () return False return True snap_analysis_data snap_analysis_data ( models , priority_layers_groups , extent ) Snaps the passed models pathways, carbon layers and priority layers to align with the reference layer set on the settings manager. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent list The selected extent from user required Source code in src/cplus_plugin/tasks.py 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 def snap_analysis_data ( self , models , priority_layers_groups , extent ): \"\"\"Snaps the passed models pathways, carbon layers and priority layers to align with the reference layer set on the settings manager. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: The selected extent from user :type extent: list \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Snapping the selected models pathways, \" \"carbon layers and priority layers\" ) ) pathways = [] try : for model in models : if not model . pathways and ( model . path is None or model . path is \"\" ): self . set_info_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) return False for pathway in model . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) reference_layer_path = settings_manager . get_value ( Settings . SNAP_LAYER ) rescale_values = settings_manager . get_value ( Settings . RESCALE_VALUES , default = False , setting_type = bool ) resampling_method = settings_manager . get_value ( Settings . RESAMPLING_METHOD , default = 0 ) if pathways is not None and len ( pathways ) > 0 : snapped_pathways_directory = os . path . join ( self . scenario_directory , \"pathways\" ) FileUtils . create_new_dir ( snapped_pathways_directory ) for pathway in pathways : pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) nodata_value = pathway_layer . dataProvider () . sourceNoDataValue ( 1 ) if self . processing_cancelled : return False # carbon layer snapping log ( f \"Snapping carbon layers from { pathway . name } pathway\" ) if ( pathway . carbon_paths is not None and len ( pathway . carbon_paths ) > 0 ): snapped_carbon_directory = os . path . join ( self . scenario_directory , \"carbon_layers\" ) FileUtils . create_new_dir ( snapped_carbon_directory ) snapped_carbon_paths = [] for carbon_path in pathway . carbon_paths : carbon_layer = QgsRasterLayer ( carbon_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) nodata_value_carbon = ( carbon_layer . dataProvider () . sourceNoDataValue ( 1 ) ) carbon_output_path = self . snap_layer ( carbon_path , reference_layer_path , extent , snapped_carbon_directory , rescale_values , resampling_method , nodata_value_carbon , ) if carbon_output_path : snapped_carbon_paths . append ( carbon_output_path ) else : snapped_carbon_paths . append ( carbon_path ) pathway . carbon_paths = snapped_carbon_paths log ( f \"Snapping { pathway . name } pathway layer \\n \" ) # Pathway snapping output_path = self . snap_layer ( pathway . path , reference_layer_path , extent , snapped_pathways_directory , rescale_values , resampling_method , nodata_value , ) if output_path : pathway . path = output_path for model in models : log ( f \"Snapping { len ( model . priority_layers ) } \" f \"priority weighting layers from model { model . name } with layers \\n \" ) if model . priority_layers is not None and len ( model . priority_layers ) > 0 : snapped_priority_directory = os . path . join ( self . scenario_directory , \"priority_layers\" ) FileUtils . create_new_dir ( snapped_priority_directory ) priority_layers = [] for priority_layer in model . priority_layers : if priority_layer is None : continue priority_layer_settings = settings_manager . get_priority_layer ( priority_layer . get ( \"uuid\" ) ) if priority_layer_settings is None : continue priority_layer_path = priority_layer_settings . get ( \"path\" ) if not Path ( priority_layer_path ) . exists (): priority_layers . append ( priority_layer ) continue layer = QgsRasterLayer ( priority_layer_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) nodata_value_priority = layer . dataProvider () . sourceNoDataValue ( 1 ) priority_output_path = self . snap_layer ( priority_layer_path , reference_layer_path , extent , snapped_priority_directory , rescale_values , resampling_method , nodata_value_priority , ) if priority_output_path : priority_layer [ \"path\" ] = priority_output_path priority_layers . append ( priority_layer ) model . priority_layers = priority_layers except Exception as e : log ( f \"Problem snapping layers, { e } \\n \" ) self . error = e self . cancel () return False return True snap_layer snap_layer ( input_path , reference_path , extent , directory , rescale_values , resampling_method , nodata_value ) Snaps the passed input layer using the reference layer and updates the snap output no data value to be the same as the original input layer no data value. Parameters: Name Type Description Default input_path str Input layer source required reference_path str Reference layer source required extent list Clip extent required directory str Absolute path of the output directory for the snapped layers required rescale_values bool Whether to rescale pixel values required resample_method QgsAlignRaster.ResampleAlg Method to use when resampling required nodata_value float Original no data value of the input layer required Source code in src/cplus_plugin/tasks.py 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 def snap_layer ( self , input_path , reference_path , extent , directory , rescale_values , resampling_method , nodata_value , ): \"\"\"Snaps the passed input layer using the reference layer and updates the snap output no data value to be the same as the original input layer no data value. :param input_path: Input layer source :type input_path: str :param reference_path: Reference layer source :type reference_path: str :param extent: Clip extent :type extent: list :param directory: Absolute path of the output directory for the snapped layers :type directory: str :param rescale_values: Whether to rescale pixel values :type rescale_values: bool :param resample_method: Method to use when resampling :type resample_method: QgsAlignRaster.ResampleAlg :param nodata_value: Original no data value of the input layer :type nodata_value: float \"\"\" input_result_path , reference_result_path = align_rasters ( input_path , reference_path , extent , directory , rescale_values , resampling_method , ) if input_result_path is not None : result_path = Path ( input_result_path ) directory = result_path . parent name = result_path . stem output_path = os . path . join ( directory , f \" { name } _final.tif\" ) self . replace_nodata ( input_result_path , output_path , nodata_value ) return output_path update_progress update_progress ( value ) Sets the value of the task progress Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/tasks.py 249 250 251 252 253 254 255 256 257 258 259 def update_progress ( self , value ): \"\"\"Sets the value of the task progress :param value: Value to be set on the progress bar :type value: float \"\"\" if not self . processing_cancelled : self . set_custom_progress ( value ) else : self . feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext ()","title":"Processing"},{"location":"developer/api/core/api_tasks/#processing-tasks","text":"","title":"Processing Tasks"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask","text":"ScenarioAnalysisTask ( analysis_scenario_name , analysis_scenario_description , analysis_implementation_models , analysis_priority_layers_groups , analysis_extent , scenario ) Bases: QgsTask Prepares and runs the scenario analysis Source code in src/cplus_plugin/tasks.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def __init__ ( self , analysis_scenario_name , analysis_scenario_description , analysis_implementation_models , analysis_priority_layers_groups , analysis_extent , scenario , ): super () . __init__ () self . analysis_scenario_name = analysis_scenario_name self . analysis_scenario_description = analysis_scenario_description self . analysis_implementation_models = analysis_implementation_models self . analysis_priority_layers_groups = analysis_priority_layers_groups self . analysis_extent = analysis_extent self . analysis_extent_string = None self . analysis_weighted_ims = [] self . scenario_result = None self . scenario_directory = None self . success = True self . output = None self . error = None self . status_message = None self . info_message = None self . processing_cancelled = False self . feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () self . scenario = scenario","title":"ScenarioAnalysisTask"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.align_extent","text":"align_extent ( raster_layer , target_extent ) Snaps the passed extent to the models pathway layer pixel bounds Parameters: Name Type Description Default raster_layer QgsRasterLayer The target layer that the passed extent will be aligned with required extent QgsRectangle Spatial extent that will be used a target extent when doing alignment. required Source code in src/cplus_plugin/tasks.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def align_extent ( self , raster_layer , target_extent ): \"\"\"Snaps the passed extent to the models pathway layer pixel bounds :param raster_layer: The target layer that the passed extent will be aligned with :type raster_layer: QgsRasterLayer :param extent: Spatial extent that will be used a target extent when doing alignment. :type extent: QgsRectangle \"\"\" try : raster_extent = raster_layer . extent () x_res = raster_layer . rasterUnitsPerPixelX () y_res = raster_layer . rasterUnitsPerPixelY () left = raster_extent . xMinimum () + x_res * math . floor ( ( target_extent . xMinimum () - raster_extent . xMinimum ()) / x_res ) right = raster_extent . xMinimum () + x_res * math . ceil ( ( target_extent . xMaximum () - raster_extent . xMinimum ()) / x_res ) bottom = raster_extent . yMinimum () + y_res * math . floor ( ( target_extent . yMinimum () - raster_extent . yMinimum ()) / y_res ) top = raster_extent . yMaximum () - y_res * math . floor ( ( raster_extent . yMaximum () - target_extent . yMaximum ()) / y_res ) return QgsRectangle ( left , bottom , right , top ) except Exception as e : log ( tr ( f \"Problem snapping area of \" f \"interest extent, using the original extent,\" f \" { str ( e ) } \" ) ) return target_extent","title":"align_extent()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.finished","text":"finished ( result ) Calls the handler responsible for doing post analysis workflow. Parameters: Name Type Description Default result bool Whether the run() operation finished successfully required Source code in src/cplus_plugin/tasks.py 226 227 228 229 230 231 232 233 234 235 def finished ( self , result : bool ): \"\"\"Calls the handler responsible for doing post analysis workflow. :param result: Whether the run() operation finished successfully :type result: bool \"\"\" if result : log ( \"Finished from the main task \\n \" ) else : log ( f \"Error from task scenario task { self . error } \" )","title":"finished()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.replace_nodata","text":"replace_nodata ( layer_path , output_path , nodata_value ) Adds nodata value info into the layer available in the passed layer_path and save the layer in the passed output_path path. The addition will replace any current nodata value available in the input layer. Parameters: Name Type Description Default layer_path str Input layer path required output_path str Output layer path required nodata_value Nodata value to be used required Returns: Type Description bool If the process was successful Source code in src/cplus_plugin/tasks.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def replace_nodata ( self , layer_path , output_path , nodata_value ): \"\"\"Adds nodata value info into the layer available in the passed layer_path and save the layer in the passed output_path path. The addition will replace any current nodata value available in the input layer. :param layer_path: Input layer path :type layer_path: str :param output_path: Output layer path :type output_path: str :param nodata_value: Nodata value to be used :type output_path: int :returns: If the process was successful :rtype: bool \"\"\" self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) alg_params = { \"COPY_SUBDATASETS\" : False , \"DATA_TYPE\" : 6 , # Float32 \"EXTRA\" : \"\" , \"INPUT\" : layer_path , \"NODATA\" : None , \"OPTIONS\" : \"\" , \"TARGET_CRS\" : None , \"OUTPUT\" : QgsProcessing . TEMPORARY_OUTPUT , } translate_output = processing . run ( \"gdal:translate\" , alg_params , context = self . processing_context , feedback = self . feedback , is_child_algorithm = True , ) alg_params = { \"DATA_TYPE\" : 0 , # Use Input Layer Data Type \"EXTRA\" : \"\" , \"INPUT\" : translate_output [ \"OUTPUT\" ], \"MULTITHREADING\" : False , \"NODATA\" : - 9999 , \"OPTIONS\" : \"\" , \"RESAMPLING\" : 0 , # Nearest Neighbour \"SOURCE_CRS\" : None , \"TARGET_CRS\" : None , \"TARGET_EXTENT\" : None , \"TARGET_EXTENT_CRS\" : None , \"TARGET_RESOLUTION\" : None , \"OUTPUT\" : output_path , } outputs = processing . run ( \"gdal:warpreproject\" , alg_params , context = self . processing_context , feedback = self . feedback , is_child_algorithm = True , ) return outputs is not None","title":"replace_nodata()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run","text":"run () Runs the main scenario analysis task operations Source code in src/cplus_plugin/tasks.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def run ( self ): \"\"\"Runs the main scenario analysis task operations\"\"\" base_dir = settings_manager . get_value ( Settings . BASE_DIR ) self . scenario_directory = os . path . join ( f \" { base_dir } \" , f 'scenario_ { datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' , ) FileUtils . create_new_dir ( self . scenario_directory ) selected_pathway = None pathway_found = False for model in self . analysis_implementation_models : if pathway_found : break for pathway in model . pathways : if pathway is not None : pathway_found = True selected_pathway = pathway break target_layer = QgsRasterLayer ( selected_pathway . path , selected_pathway . name ) dest_crs = ( target_layer . crs () if selected_pathway and selected_pathway . path else QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) ) processing_extent = QgsRectangle ( float ( self . analysis_extent . bbox [ 0 ]), float ( self . analysis_extent . bbox [ 2 ]), float ( self . analysis_extent . bbox [ 1 ]), float ( self . analysis_extent . bbox [ 3 ]), ) snapped_extent = self . align_extent ( target_layer , processing_extent ) extent_string = ( f \" { snapped_extent . xMinimum () } , { snapped_extent . xMaximum () } ,\" f \" { snapped_extent . yMinimum () } , { snapped_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) log ( f \"Original area of interest extent: { processing_extent . asWktPolygon () } \\n \" ) log ( f \"Snapped area of interest extent { snapped_extent . asWktPolygon () } \\n \" ) # Run pathways layers snapping using a specified reference layer snapping_enabled = settings_manager . get_value ( Settings . SNAPPING_ENABLED , default = False , setting_type = bool ) reference_layer = settings_manager . get_value ( Settings . SNAP_LAYER , default = \"\" ) reference_layer_path = Path ( reference_layer ) if ( snapping_enabled and os . path . exists ( reference_layer ) and reference_layer_path . is_file () ): self . snap_analysis_data ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) # Preparing all the pathways by adding them together with # their carbon layers before creating # their respective models. self . run_pathways_analysis ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) # Normalizing all the models pathways using the carbon coefficient and # the pathway suitability index self . run_pathways_normalization ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) # Creating models from the normalized pathways self . run_models_analysis ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) # After creating models, we normalize them using the same coefficients # used in normalizing their respective pathways. self . run_models_normalization ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) # Weighting the models with their corresponding priority weighting layers weighted_models , result = self . run_models_weighting ( self . analysis_implementation_models , self . analysis_priority_layers_groups , extent_string , ) self . analysis_weighted_ims = weighted_models self . scenario . weighted_models = weighted_models # Post weighting analysis self . run_models_cleaning ( weighted_models , extent_string ) # The highest position tool analysis self . run_highest_position_analysis () return True","title":"run()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_highest_position_analysis","text":"run_highest_position_analysis () Runs the highest position analysis which is last step in scenario analysis. Uses the models set by the current ongoing analysis. Source code in src/cplus_plugin/tasks.py 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 def run_highest_position_analysis ( self ): \"\"\"Runs the highest position analysis which is last step in scenario analysis. Uses the models set by the current ongoing analysis. \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return passed_extent_box = self . analysis_extent . bbox passed_extent = QgsRectangle ( passed_extent_box [ 0 ], passed_extent_box [ 2 ], passed_extent_box [ 1 ], passed_extent_box [ 3 ], ) self . scenario_result = ScenarioResult ( scenario = self . scenario , scenario_directory = self . scenario_directory ) try : layers = {} self . set_status_message ( tr ( \"Calculating the highest position\" )) for model in self . analysis_weighted_ims : if model . path is not None and model . path is not \"\" : raster_layer = QgsRasterLayer ( model . path , model . name ) layers [ model . name ] = ( raster_layer if raster_layer is not None else None ) else : for pathway in model . pathways : layers [ model . name ] = QgsRasterLayer ( pathway . path ) source_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) dest_crs = list ( layers . values ())[ 0 ] . crs () if len ( layers ) > 0 else source_crs extent_string = ( f \" { passed_extent . xMinimum () } , { passed_extent . xMaximum () } ,\" f \" { passed_extent . yMinimum () } , { passed_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) output_file = os . path . join ( self . scenario_directory , f \" { SCENARIO_OUTPUT_FILE_NAME } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) # Preparing the input rasters for the highest position # analysis in a correct order models_names = [ model . name for model in self . analysis_weighted_ims ] all_models = sorted ( self . analysis_weighted_ims , key = lambda model_instance : model_instance . style_pixel_value , ) for index , model in enumerate ( all_models ): model . style_pixel_value = index + 1 all_models_names = [ model . name for model in all_models ] sources = [] for model_name in all_models_names : if model_name in models_names : sources . append ( layers [ model_name ] . source ()) log ( f \"Layers sources { [ Path ( source ) . stem for source in sources ] } \" ) alg_params = { \"IGNORE_NODATA\" : True , \"INPUT_RASTERS\" : sources , \"EXTENT\" : extent_string , \"OUTPUT_NODATA_VALUE\" : - 9999 , \"REFERENCE_LAYER\" : list ( layers . values ())[ 0 ] if len ( layers ) >= 1 else None , \"OUTPUT\" : output_file , } log ( f \"Used parameters for highest position analysis { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False self . output = processing . run ( \"native:highestpositioninrasterstack\" , alg_params , context = self . processing_context , feedback = self . feedback , ) except Exception as err : log ( tr ( \"An error occurred when running task for \" 'scenario analysis, error message \" {} \"' . format ( str ( err )) ) ) self . error = err self . cancel () return False return True","title":"run_highest_position_analysis()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_models_analysis","text":"run_models_analysis ( models , priority_layers_groups , extent ) Runs the required model analysis on the passed implementation models. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent SpatialExtent selected extent from user required Source code in src/cplus_plugin/tasks.py 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 def run_models_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the required model analysis on the passed implementation models. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: SpatialExtent \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Creating implementation models layers from pathways\" ) ) try : for model in models : ims_directory = os . path . join ( self . scenario_directory , \"implementation_models\" ) FileUtils . create_new_dir ( ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) layers = [] if not model . pathways and ( model . path is None and model . path is \"\" ): self . set_info_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) return False output_file = os . path . join ( ims_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) # Due to the implementation models base class # model only one of the following blocks will be executed, # the implementation model either contain a path or # pathways if model . path is not None and model . path is not \"\" : layers = [ model . path ] for pathway in model . pathways : layers . append ( pathway . path ) # Actual processing calculation alg_params = { \"IGNORE_NODATA\" : True , \"INPUT\" : layers , \"EXTENT\" : extent , \"OUTPUT_NODATA_VALUE\" : - 9999 , \"REFERENCE_LAYER\" : layers [ 0 ] if len ( layers ) > 0 else None , \"STATISTIC\" : 0 , # Sum \"OUTPUT\" : output_file , } log ( f \"Used parameters for \" f \"implementation models generation: { alg_params } \\n \" ) feedback = QgsProcessingFeedback () feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"native:cellstatistics\" , alg_params , context = self . processing_context , feedback = self . feedback , ) model . path = results [ \"OUTPUT\" ] except Exception as e : log ( f \"Problem creating models layers, { e } \" ) self . error = e self . cancel () return False return True","title":"run_models_analysis()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_models_cleaning","text":"run_models_cleaning ( models , extent = None ) Cleans the weighted implementation models replacing zero values with no-data as they are not statistical meaningful for the scenario analysis. Parameters: Name Type Description Default extent str Selected extent from user None Source code in src/cplus_plugin/tasks.py 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 def run_models_cleaning ( self , models , extent = None ): \"\"\"Cleans the weighted implementation models replacing zero values with no-data as they are not statistical meaningful for the scenario analysis. :param extent: Selected extent from user :type extent: str \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Updating weighted implementation models values\" )) try : for model in models : if model . path is None or model . path is \"\" : self . set_info_message ( tr ( f \"Problem when running models updates, \" f \"there is no map layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"Problem when running models updates, \" f \"there is no map layer for the model { model . name } \" ) return False layers = [ model . path ] file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( self . scenario_directory , \"weighted_ims\" ) output_file = os . path . join ( output_file , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } _cleaned.tif\" ) # Actual processing calculation # The aim is to convert pixels values to no data, that is why we are # using the sum operation with only one layer. alg_params = { \"IGNORE_NODATA\" : True , \"INPUT\" : layers , \"EXTENT\" : extent , \"OUTPUT_NODATA_VALUE\" : 0 , \"REFERENCE_LAYER\" : layers [ 0 ] if len ( layers ) > 0 else None , \"STATISTIC\" : 0 , # Sum \"OUTPUT\" : output_file , } log ( f \"Used parameters for \" f \"updates on the weighted implementation models: { alg_params } \\n \" ) feedback = QgsProcessingFeedback () feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"native:cellstatistics\" , alg_params , context = self . processing_context , feedback = self . feedback , ) model . path = results [ \"OUTPUT\" ] except Exception as e : log ( f \"Problem cleaning implementation models, { e } \" ) self . error = e self . cancel () return False return True","title":"run_models_cleaning()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_models_normalization","text":"run_models_normalization ( models , priority_layers_groups , extent ) Runs the normalization analysis on the models layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Model = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the analyzed implementation models required priority_layers_groups dict Used priority layers groups and their values required extent str Selected area of interest extent required Source code in src/cplus_plugin/tasks.py 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 def run_models_normalization ( self , models , priority_layers_groups , extent ): \"\"\"Runs the normalization analysis on the models layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Model = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. :param models: List of the analyzed implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: Selected area of interest extent :type extent: str \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Normalization of the implementation models\" )) try : for model in models : if model . path is None or model . path is \"\" : if not self . processing_cancelled : self . set_info_message ( tr ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ) else : # If the user cancelled the processing self . set_info_message ( tr ( f \"Processing has been cancelled by the user.\" ), level = Qgis . Critical , ) log ( f \"Processing has been cancelled by the user.\" ) return False layers = [] normalized_ims_directory = os . path . join ( self . scenario_directory , \"normalized_ims\" ) FileUtils . create_new_dir ( normalized_ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( normalized_ims_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) model_layer = QgsRasterLayer ( model . path , model . name ) provider = model_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue log ( f \"Found minimum { min_value } and \" f \"maximum { max_value } for model { model . name } \\n \" ) layer_name = Path ( model . path ) . stem layers . append ( model . path ) carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) normalization_index = carbon_coefficient + suitability_index if normalization_index > 0 : expression = ( f \" { normalization_index } * \" f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) else : expression = ( f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for normalization of the models: { alg_params } \\n \" ) feedback = QgsProcessingFeedback () feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) model . path = results [ \"OUTPUT\" ] except Exception as e : log ( f \"Problem normalizing models layers, { e } \\n \" ) self . error = e self . cancel () return False return True","title":"run_models_normalization()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_models_weighting","text":"run_models_weighting ( models , priority_layers_groups , extent ) Runs weighting analysis on the passed implementation models using the corresponding models weighting analysis. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent str selected extent from user required Source code in src/cplus_plugin/tasks.py 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 def run_models_weighting ( self , models , priority_layers_groups , extent ): \"\"\"Runs weighting analysis on the passed implementation models using the corresponding models weighting analysis. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: str \"\"\" if self . processing_cancelled : return [], False self . set_status_message ( tr ( f \"Weighting implementation models\" )) weighted_models = [] try : for original_model in models : model = clone_implementation_model ( original_model ) if model . path is None or model . path is \"\" : self . set_info_message ( tr ( f \"Problem when running models weighting, \" f \"there is no map layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ) return [], False basenames = [] layers = [] layers . append ( model . path ) basenames . append ( f '\" { Path ( model . path ) . stem } @1\"' ) if not any ( priority_layers_groups ): log ( f \"There are no defined priority layers in groups,\" f \" skipping models weighting step.\" ) self . run_models_cleaning ( extent ) return if model . priority_layers is None or model . priority_layers is []: log ( f \"There are no associated \" f \"priority weighting layers for model { model . name } \" ) continue settings_model = settings_manager . get_implementation_model ( str ( model . uuid ) ) for layer in settings_model . priority_layers : if layer is None : continue settings_layer = settings_manager . get_priority_layer ( layer . get ( \"uuid\" ) ) if settings_layer is None : continue pwl = settings_layer . get ( \"path\" ) missing_pwl_message = ( f \"Path { pwl } for priority \" f \"weighting layer { layer . get ( 'name' ) } \" f \"doesn't exist, skipping the layer \" f \"from the model { model . name } weighting.\" ) if pwl is None : log ( missing_pwl_message ) continue pwl_path = Path ( pwl ) if not pwl_path . exists (): log ( missing_pwl_message ) continue path_basename = pwl_path . stem for priority_layer in settings_manager . get_priority_layers (): if priority_layer . get ( \"name\" ) == layer . get ( \"name\" ): for group in priority_layer . get ( \"groups\" , []): value = group . get ( \"value\" ) coefficient = float ( value ) if coefficient > 0 : if pwl not in layers : layers . append ( pwl ) basenames . append ( f '( { coefficient } *\" { path_basename } @1\")' ) if basenames is []: return [], True weighted_ims_directory = os . path . join ( self . scenario_directory , \"weighted_ims\" ) FileUtils . create_new_dir ( weighted_ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( weighted_ims_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) expression = \" + \" . join ( basenames ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \" Used parameters for calculating weighting models { alg_params } \\n \" ) feedback = QgsProcessingFeedback () feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return [], False results = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) model . path = results [ \"OUTPUT\" ] weighted_models . append ( model ) except Exception as e : log ( f \"Problem weighting implementation models, { e } \\n \" ) self . error = e self . cancel () return None , False return weighted_models , True","title":"run_models_weighting()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_pathways_analysis","text":"run_pathways_analysis ( models , priority_layers_groups , extent ) Runs the required model pathways analysis on the passed implementation models. The analysis involves adding the pathways carbon layers into the pathway layer. If the pathway layer has more than one carbon layer, the resulting weighted pathway will contain the sum of the pathway layer values with the average of the pathway carbon layers values. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent SpatialExtent The selected extent from user required Source code in src/cplus_plugin/tasks.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 def run_pathways_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the required model pathways analysis on the passed implementation models. The analysis involves adding the pathways carbon layers into the pathway layer. If the pathway layer has more than one carbon layer, the resulting weighted pathway will contain the sum of the pathway layer values with the average of the pathway carbon layers values. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: The selected extent from user :type extent: SpatialExtent \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Adding models pathways with carbon layers\" )) pathways = [] models_paths = [] try : for model in models : if not model . pathways and ( model . path is None or model . path is \"\" ): self . set_info_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) return False for pathway in model . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) if model . path is not None and model . path is not \"\" : models_paths . append ( model . path ) if not pathways and len ( models_paths ) > 0 : self . run_pathways_normalization ( models , priority_layers_groups , extent ) return suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) for pathway in pathways : basenames = [] layers = [] path_basename = Path ( pathway . path ) . stem layers . append ( pathway . path ) file_name = clean_filename ( pathway . name . replace ( \" \" , \"_\" )) if suitability_index > 0 : basenames . append ( f ' { suitability_index } * \" { path_basename } @1\"' ) else : basenames . append ( f '\" { path_basename } @1\"' ) carbon_names = [] if len ( pathway . carbon_paths ) <= 0 : continue new_carbon_directory = os . path . join ( self . scenario_directory , \"pathways_carbon_layers\" ) FileUtils . create_new_dir ( new_carbon_directory ) output_file = os . path . join ( new_carbon_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) for carbon_path in pathway . carbon_paths : carbon_full_path = Path ( carbon_path ) if not carbon_full_path . exists (): continue layers . append ( carbon_path ) carbon_names . append ( f '\" { carbon_full_path . stem } @1\"' ) if len ( carbon_names ) == 1 and carbon_coefficient > 0 : basenames . append ( f \" { carbon_coefficient } * ( { carbon_names [ 0 ] } )\" ) # Setting up calculation to use carbon layers average when # a pathway has more than one carbon layer. if len ( carbon_names ) > 1 and carbon_coefficient > 0 : basenames . append ( f \" { carbon_coefficient } * (\" f '( { \" + \" . join ( carbon_names ) } ) / ' f \" { len ( pathway . carbon_paths ) } )\" ) expression = \" + \" . join ( basenames ) if carbon_coefficient <= 0 and suitability_index <= 0 : self . run_pathways_normalization ( models , priority_layers_groups , extent ) return # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for combining pathways\" f \" and carbon layers generation: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) # self.replace_nodata(results[\"OUTPUT\"], output_file, -9999) pathway . path = output_file except Exception as e : log ( f \"Problem running pathway analysis, { e } \" ) self . error = e self . cancel () return True","title":"run_pathways_analysis()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_pathways_normalization","text":"run_pathways_normalization ( models , priority_layers_groups , extent ) Runs the normalization on the models pathways layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Pathway = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the analyzed implementation models required priority_layers_groups dict Used priority layers groups and their values required extent str selected extent from user required Source code in src/cplus_plugin/tasks.py 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 def run_pathways_normalization ( self , models , priority_layers_groups , extent ): \"\"\"Runs the normalization on the models pathways layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Pathway = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. :param models: List of the analyzed implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: str \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Normalization of pathways\" )) pathways = [] models_paths = [] try : for model in models : if not model . pathways and ( model . path is None or model . path is \"\" ): self . set_info_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) return False for pathway in model . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) if model . path is not None and model . path is not \"\" : models_paths . append ( model . path ) if not pathways and len ( models_paths ) > 0 : self . run_models_analysis ( models , priority_layers_groups , extent ) return carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) normalization_index = carbon_coefficient + suitability_index for pathway in pathways : layers = [] normalized_pathways_directory = os . path . join ( self . scenario_directory , \"normalized_pathways\" ) FileUtils . create_new_dir ( normalized_pathways_directory ) file_name = clean_filename ( pathway . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( normalized_pathways_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) provider = pathway_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue layer_name = Path ( pathway . path ) . stem layers . append ( pathway . path ) log ( f \"Found minimum { min_value } and \" f \"maximum { max_value } for pathway \" f \" \\n \" ) if max_value < min_value : raise Exception ( tr ( f \"Pathway contains \" f \"invalid minimum and maxmum band values\" ) ) if normalization_index > 0 : expression = ( f \" { normalization_index } * \" f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) else : expression = ( f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for normalization of the pathways: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) # self.replace_nodata(results[\"OUTPUT\"], output_file, -9999) pathway . path = results [ \"OUTPUT\" ] except Exception as e : log ( f \"Problem normalizing pathways layers, { e } \\n \" ) self . error = e self . cancel () return False return True","title":"run_pathways_normalization()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.snap_analysis_data","text":"snap_analysis_data ( models , priority_layers_groups , extent ) Snaps the passed models pathways, carbon layers and priority layers to align with the reference layer set on the settings manager. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent list The selected extent from user required Source code in src/cplus_plugin/tasks.py 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 def snap_analysis_data ( self , models , priority_layers_groups , extent ): \"\"\"Snaps the passed models pathways, carbon layers and priority layers to align with the reference layer set on the settings manager. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: The selected extent from user :type extent: list \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Snapping the selected models pathways, \" \"carbon layers and priority layers\" ) ) pathways = [] try : for model in models : if not model . pathways and ( model . path is None or model . path is \"\" ): self . set_info_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) return False for pathway in model . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) reference_layer_path = settings_manager . get_value ( Settings . SNAP_LAYER ) rescale_values = settings_manager . get_value ( Settings . RESCALE_VALUES , default = False , setting_type = bool ) resampling_method = settings_manager . get_value ( Settings . RESAMPLING_METHOD , default = 0 ) if pathways is not None and len ( pathways ) > 0 : snapped_pathways_directory = os . path . join ( self . scenario_directory , \"pathways\" ) FileUtils . create_new_dir ( snapped_pathways_directory ) for pathway in pathways : pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) nodata_value = pathway_layer . dataProvider () . sourceNoDataValue ( 1 ) if self . processing_cancelled : return False # carbon layer snapping log ( f \"Snapping carbon layers from { pathway . name } pathway\" ) if ( pathway . carbon_paths is not None and len ( pathway . carbon_paths ) > 0 ): snapped_carbon_directory = os . path . join ( self . scenario_directory , \"carbon_layers\" ) FileUtils . create_new_dir ( snapped_carbon_directory ) snapped_carbon_paths = [] for carbon_path in pathway . carbon_paths : carbon_layer = QgsRasterLayer ( carbon_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) nodata_value_carbon = ( carbon_layer . dataProvider () . sourceNoDataValue ( 1 ) ) carbon_output_path = self . snap_layer ( carbon_path , reference_layer_path , extent , snapped_carbon_directory , rescale_values , resampling_method , nodata_value_carbon , ) if carbon_output_path : snapped_carbon_paths . append ( carbon_output_path ) else : snapped_carbon_paths . append ( carbon_path ) pathway . carbon_paths = snapped_carbon_paths log ( f \"Snapping { pathway . name } pathway layer \\n \" ) # Pathway snapping output_path = self . snap_layer ( pathway . path , reference_layer_path , extent , snapped_pathways_directory , rescale_values , resampling_method , nodata_value , ) if output_path : pathway . path = output_path for model in models : log ( f \"Snapping { len ( model . priority_layers ) } \" f \"priority weighting layers from model { model . name } with layers \\n \" ) if model . priority_layers is not None and len ( model . priority_layers ) > 0 : snapped_priority_directory = os . path . join ( self . scenario_directory , \"priority_layers\" ) FileUtils . create_new_dir ( snapped_priority_directory ) priority_layers = [] for priority_layer in model . priority_layers : if priority_layer is None : continue priority_layer_settings = settings_manager . get_priority_layer ( priority_layer . get ( \"uuid\" ) ) if priority_layer_settings is None : continue priority_layer_path = priority_layer_settings . get ( \"path\" ) if not Path ( priority_layer_path ) . exists (): priority_layers . append ( priority_layer ) continue layer = QgsRasterLayer ( priority_layer_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) nodata_value_priority = layer . dataProvider () . sourceNoDataValue ( 1 ) priority_output_path = self . snap_layer ( priority_layer_path , reference_layer_path , extent , snapped_priority_directory , rescale_values , resampling_method , nodata_value_priority , ) if priority_output_path : priority_layer [ \"path\" ] = priority_output_path priority_layers . append ( priority_layer ) model . priority_layers = priority_layers except Exception as e : log ( f \"Problem snapping layers, { e } \\n \" ) self . error = e self . cancel () return False return True","title":"snap_analysis_data()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.snap_layer","text":"snap_layer ( input_path , reference_path , extent , directory , rescale_values , resampling_method , nodata_value ) Snaps the passed input layer using the reference layer and updates the snap output no data value to be the same as the original input layer no data value. Parameters: Name Type Description Default input_path str Input layer source required reference_path str Reference layer source required extent list Clip extent required directory str Absolute path of the output directory for the snapped layers required rescale_values bool Whether to rescale pixel values required resample_method QgsAlignRaster.ResampleAlg Method to use when resampling required nodata_value float Original no data value of the input layer required Source code in src/cplus_plugin/tasks.py 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 def snap_layer ( self , input_path , reference_path , extent , directory , rescale_values , resampling_method , nodata_value , ): \"\"\"Snaps the passed input layer using the reference layer and updates the snap output no data value to be the same as the original input layer no data value. :param input_path: Input layer source :type input_path: str :param reference_path: Reference layer source :type reference_path: str :param extent: Clip extent :type extent: list :param directory: Absolute path of the output directory for the snapped layers :type directory: str :param rescale_values: Whether to rescale pixel values :type rescale_values: bool :param resample_method: Method to use when resampling :type resample_method: QgsAlignRaster.ResampleAlg :param nodata_value: Original no data value of the input layer :type nodata_value: float \"\"\" input_result_path , reference_result_path = align_rasters ( input_path , reference_path , extent , directory , rescale_values , resampling_method , ) if input_result_path is not None : result_path = Path ( input_result_path ) directory = result_path . parent name = result_path . stem output_path = os . path . join ( directory , f \" { name } _final.tif\" ) self . replace_nodata ( input_result_path , output_path , nodata_value ) return output_path","title":"snap_layer()"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.update_progress","text":"update_progress ( value ) Sets the value of the task progress Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/tasks.py 249 250 251 252 253 254 255 256 257 258 259 def update_progress ( self , value ): \"\"\"Sets the value of the task progress :param value: Value to be set on the progress bar :type value: float \"\"\" if not self . processing_cancelled : self . set_custom_progress ( value ) else : self . feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext ()","title":"update_progress()"},{"location":"developer/api/core/api_utils/","text":"Utilities Plugin utilities FileUtils Provides functionality for commonly used file-related operations. create_ncs_carbon_dir staticmethod create_ncs_carbon_dir ( base_dir ) Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 414 415 416 417 418 419 420 421 422 423 424 @staticmethod def create_ncs_carbon_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_carbon_dir = f \" { base_dir } / { NCS_CARBON_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS carbon subdirectory.\" ) FileUtils . create_new_dir ( ncs_carbon_dir , message ) create_ncs_pathways_dir staticmethod create_ncs_pathways_dir ( base_dir ) Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 400 401 402 403 404 405 406 407 408 409 410 411 412 @staticmethod def create_ncs_pathways_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_pathway_dir = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS pathways subdirectory.\" ) FileUtils . create_new_dir ( ncs_pathway_dir , message ) create_new_dir staticmethod create_new_dir ( directory , log_message = '' ) Creates new file directory if it doesn't exist Source code in src/cplus_plugin/utils.py 439 440 441 442 443 444 445 446 447 @staticmethod def create_new_dir ( directory : str , log_message : str = \"\" ): \"\"\"Creates new file directory if it doesn't exist\"\"\" p = Path ( directory ) if not p . exists (): try : p . mkdir () except ( FileNotFoundError , OSError ): log ( log_message ) create_new_file staticmethod create_new_file ( file_path , log_message = '' ) Creates new file Source code in src/cplus_plugin/utils.py 449 450 451 452 453 454 455 456 457 458 @staticmethod def create_new_file ( file_path : str , log_message : str = \"\" ): \"\"\"Creates new file\"\"\" p = Path ( file_path ) if not p . exists (): try : p . touch ( exist_ok = True ) except FileNotFoundError : log ( log_message ) create_pwls_dir create_pwls_dir ( base_dir ) Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 426 427 428 429 430 431 432 433 434 435 436 437 def create_pwls_dir ( base_dir : str ): \"\"\"Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return pwl_dir = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } \" message = tr ( \"Missing parent directory when creating priority weighting layers subdirectory.\" ) FileUtils . create_new_dir ( pwl_dir , message ) get_icon staticmethod get_icon ( file_name ) Creates an icon based on the icon name in the 'icons' folder. Parameters: Name Type Description Default file_name str File name which should include the extension. required Returns: Type Description QtGui.QIcon Icon object matching the file name. Source code in src/cplus_plugin/utils.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 @staticmethod def get_icon ( file_name : str ) -> QtGui . QIcon : \"\"\"Creates an icon based on the icon name in the 'icons' folder. :param file_name: File name which should include the extension. :type file_name: str :returns: Icon object matching the file name. :rtype: QtGui.QIcon \"\"\" icon_path = os . path . normpath ( f \" { FileUtils . plugin_dir () } /icons/ { file_name } \" ) if not os . path . exists ( icon_path ): return QtGui . QIcon () return QtGui . QIcon ( icon_path ) plugin_dir staticmethod plugin_dir () Returns the root directory of the plugin. Returns: Type Description str Root directory of the plugin. Source code in src/cplus_plugin/utils.py 354 355 356 357 358 359 360 361 @staticmethod def plugin_dir () -> str : \"\"\"Returns the root directory of the plugin. :returns: Root directory of the plugin. :rtype: str \"\"\" return os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ))) report_template_path staticmethod report_template_path ( file_name = None ) Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. Parameters: Name Type Description Default file_name str Template file name including the extension. If none is specified then it will use main.qpt as the default template name. None Returns: Type Description str The absolute path to the template file with the given name. Source code in src/cplus_plugin/utils.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 @staticmethod def report_template_path ( file_name = None ) -> str : \"\"\"Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. :param file_name: Template file name including the extension. If none is specified then it will use `main.qpt` as the default template name. :type file_name: str :returns: The absolute path to the template file with the given name. :rtype: str \"\"\" if file_name is None : file_name = TEMPLATE_NAME absolute_path = f \" { FileUtils . plugin_dir () } /data/reports/ { file_name } \" return os . path . normpath ( absolute_path ) align_rasters align_rasters ( input_raster_source , reference_raster_source , extent = None , output_dir = None , rescale_values = False , resample_method = 0 ) Based from work on https://github.com/inasafe/inasafe/pull/2070 Aligns the passed raster files source and save the results into new files. Parameters: Name Type Description Default input_raster_source str Input layer source required reference_raster_source str Reference layer source required extent list Clip extent None output_dir str Absolute path of the output directory for the snapped layers None rescale_values bool Whether to rescale pixel values False resample_method QgsAlignRaster.ResampleAlg Method to use when resampling 0 Source code in src/cplus_plugin/utils.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def align_rasters ( input_raster_source , reference_raster_source , extent = None , output_dir = None , rescale_values = False , resample_method = 0 , ): \"\"\" Based from work on https://github.com/inasafe/inasafe/pull/2070 Aligns the passed raster files source and save the results into new files. :param input_raster_source: Input layer source :type input_raster_source: str :param reference_raster_source: Reference layer source :type reference_raster_source: str :param extent: Clip extent :type extent: list :param output_dir: Absolute path of the output directory for the snapped layers :type output_dir: str :param rescale_values: Whether to rescale pixel values :type rescale_values: bool :param resample_method: Method to use when resampling :type resample_method: QgsAlignRaster.ResampleAlg \"\"\" try : snap_directory = os . path . join ( output_dir , \"snap_layers\" ) FileUtils . create_new_dir ( snap_directory ) input_path = Path ( input_raster_source ) input_layer_output = os . path . join ( f \" { snap_directory } \" , f \" { input_path . stem } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) FileUtils . create_new_file ( input_layer_output ) align = QgsAlignRaster () lst = [ QgsAlignRaster . Item ( input_raster_source , input_layer_output ), ] resample_method_value = QgsAlignRaster . ResampleAlg . RA_NearestNeighbour try : resample_method_value = QgsAlignRaster . ResampleAlg ( int ( resample_method )) except Exception as e : log ( f \"Problem creating a resample value when snapping, { e } \" ) if rescale_values : lst [ 0 ] . rescaleValues = rescale_values lst [ 0 ] . resample_method = resample_method_value align . setRasters ( lst ) align . setParametersFromRaster ( reference_raster_source ) layer = QgsRasterLayer ( input_raster_source , \"input_layer\" ) extent = transform_extent ( layer . extent (), QgsCoordinateReferenceSystem ( layer . crs ()), QgsCoordinateReferenceSystem ( align . destinationCrs ()), ) align . setClipExtent ( extent ) log ( f \"Snapping clip extent { layer . extent () . asWktPolygon () } \\n \" ) if not align . run (): log ( f \"Problem during snapping for { input_raster_source } and \" f \" { reference_raster_source } , { align . errorMessage () } \" ) raise Exception ( align . errorMessage ()) except Exception as e : log ( f \"Problem occured when snapping, { str ( e ) } .\" f \" Update snap settings and re-run the analysis\" ) return None , None log ( f \"Finished snapping\" f \" original layer - { input_raster_source } ,\" f \"snapped output - { input_layer_output } \\n \" ) return input_layer_output , None calculate_raster_value_area calculate_raster_value_area ( layer , band_number = 1 , feedback = None ) Calculates the area of value pixels for the given band in a raster layer. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. Parameters: Name Type Description Default layer QgsRasterLayer Input layer whose area for value pixels is to be calculated. required band_number int Band number to compute area, default is band one. 1 feedback QgsProcessingFeedback Feedback object for progress during area calculation. None Returns: Type Description float A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. Source code in src/cplus_plugin/utils.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def calculate_raster_value_area ( layer : QgsRasterLayer , band_number : int = 1 , feedback : QgsProcessingFeedback = None ) -> dict : \"\"\"Calculates the area of value pixels for the given band in a raster layer. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. :param layer: Input layer whose area for value pixels is to be calculated. :type layer: QgsRasterLayer :param band_number: Band number to compute area, default is band one. :type band_number: int :param feedback: Feedback object for progress during area calculation. :type feedback: QgsProcessingFeedback :returns: A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. :rtype: float \"\"\" if not layer . isValid (): log ( \"Invalid layer for raster area calculation.\" , info = False ) return {} algorithm_name = \"native:rasterlayeruniquevaluesreport\" params = { \"INPUT\" : layer , \"BAND\" : band_number , \"OUTPUT_TABLE\" : \"TEMPORARY_OUTPUT\" , \"OUTPUT_HTML_FILE\" : QgsProcessing . TEMPORARY_OUTPUT , } algorithm_result = processing . run ( algorithm_name , params , feedback = feedback ) # Get number of pixels with values total_pixel_count = algorithm_result [ \"TOTAL_PIXEL_COUNT\" ] if total_pixel_count == 0 : log ( \"Input layer for raster area calculation is empty.\" , info = False ) return {} output_table = algorithm_result [ \"OUTPUT_TABLE\" ] if output_table is None : log ( \"Unique values raster table could not be retrieved.\" , info = False ) return {} area_calc = QgsDistanceArea () crs = layer . crs () area_calc . setSourceCrs ( crs , QgsCoordinateTransformContext ()) if crs is not None : # Use ellipsoid calculation if available area_calc . setEllipsoid ( crs . ellipsoidAcronym ()) version = Qgis . versionInt () if version < 33000 : unit_type = QgsUnitTypes . AreaUnit . AreaHectares else : unit_type = Qgis . AreaUnit . Hectares pixel_areas = {} features = output_table . getFeatures () for f in features : pixel_value = f . attribute ( 0 ) area = f . attribute ( 2 ) pixel_value_area = area_calc . convertAreaMeasurement ( area , unit_type ) pixel_areas [ pixel_value ] = pixel_value_area return pixel_areas clean_filename clean_filename ( filename ) Creates a safe filename by removing operating system invalid filename characters. Parameters: Name Type Description Default filename str File name required Source code in src/cplus_plugin/utils.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def clean_filename ( filename ): \"\"\"Creates a safe filename by removing operating system invalid filename characters. :param filename: File name :type filename: str :returns A clean file name :rtype str \"\"\" characters = \" %:/,\\[]<>*?\" for character in characters : if character in filename : filename = filename . replace ( character , \"_\" ) return filename get_plugin_version get_plugin_version () Returns the current plugin version as saved in the metadata.txt plugin file. Returns: Type Description str Plugin version Source code in src/cplus_plugin/utils.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def get_plugin_version () -> [ str , None ]: \"\"\"Returns the current plugin version as saved in the metadata.txt plugin file. :returns version: Plugin version :rtype version: str \"\"\" metadata_file = Path ( __file__ ) . parent . resolve () / \"metadata.txt\" with open ( metadata_file , \"r\" ) as f : for line in f . readlines (): if line . startswith ( \"version\" ): version = line . strip () . split ( \"=\" )[ 1 ] return version return None get_report_font get_report_font ( size = 11.0 , bold = False , italic = False ) Uses the default font family name to create a font for use in the report. Parameters: Name Type Description Default size float The font point size, default is 11. 11.0 bold bool True for bold font else False which is the default. False italic bool True for font to be in italics else False which is the default. False Returns: Type Description QtGui.QFont Font to use in a report. Source code in src/cplus_plugin/utils.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def get_report_font ( size = 11.0 , bold = False , italic = False ) -> QtGui . QFont : \"\"\"Uses the default font family name to create a font for use in the report. :param size: The font point size, default is 11. :type size: float :param bold: True for bold font else False which is the default. :type bold: bool :param italic: True for font to be in italics else False which is the default. :type italic: bool :returns: Font to use in a report. :rtype: QtGui.QFont \"\"\" font_weight = 50 if bold is True : font_weight = 75 return QtGui . QFont ( REPORT_FONT_NAME , int ( size ), font_weight , italic ) log log ( message , name = 'qgis_cplus' , info = True , notify = True ) Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. Parameters: Name Type Description Default message str The log message required name str Name of te log instance, qgis_cplus is the default 'qgis_cplus' info bool Whether the message is about info or a warning True notify bool Whether to notify user about the log True Source code in src/cplus_plugin/utils.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def log ( message : str , name : str = \"qgis_cplus\" , info : bool = True , notify : bool = True , ): \"\"\"Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. :param message: The log message :type message: str :param name: Name of te log instance, qgis_cplus is the default :type message: str :param info: Whether the message is about info or a warning :type info: bool :param notify: Whether to notify user about the log :type notify: bool \"\"\" level = Qgis . Info if info else Qgis . Warning QgsMessageLog . logMessage ( message , name , level = level , notifyUser = notify , ) open_documentation open_documentation ( url = None ) Opens documentation website in the default browser Parameters: Name Type Description Default url str URL link to documentation site (e.g. gh pages site) None Source code in src/cplus_plugin/utils.py 85 86 87 88 89 90 91 92 93 94 def open_documentation ( url = None ): \"\"\"Opens documentation website in the default browser :param url: URL link to documentation site (e.g. gh pages site) :type url: str \"\"\" url = DOCUMENTATION_SITE if url is None else url result = QtGui . QDesktopServices . openUrl ( QtCore . QUrl ( url )) return result tr tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message str, QString String for translation. required Returns: Type Description QString Translated version of message. Source code in src/cplus_plugin/utils.py 39 40 41 42 43 44 45 46 47 48 49 50 def tr ( message ): \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation. :type message: str, QString :returns: Translated version of message. :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QtCore . QCoreApplication . translate ( \"QgisCplus\" , message ) transform_extent transform_extent ( extent , source_crs , dest_crs ) Transforms the passed extent into the destination crs :param extent: Target extent Parameters: Name Type Description Default source_crs QgsCoordinateReferenceSystem Source CRS of the passed extent required dest_crs QgsCoordinateReferenceSystem Destination CRS required Source code in src/cplus_plugin/utils.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 def transform_extent ( extent , source_crs , dest_crs ): \"\"\"Transforms the passed extent into the destination crs :param extent: Target extent :type extent: QgsRectangle :param source_crs: Source CRS of the passed extent :type source_crs: QgsCoordinateReferenceSystem :param dest_crs: Destination CRS :type dest_crs: QgsCoordinateReferenceSystem \"\"\" transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance ()) transformed_extent = transform . transformBoundingBox ( extent ) return transformed_extent","title":"Utilities"},{"location":"developer/api/core/api_utils/#utilities","text":"Plugin utilities","title":"Utilities"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils","text":"Provides functionality for commonly used file-related operations.","title":"FileUtils"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_ncs_carbon_dir","text":"create_ncs_carbon_dir ( base_dir ) Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 414 415 416 417 418 419 420 421 422 423 424 @staticmethod def create_ncs_carbon_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_carbon_dir = f \" { base_dir } / { NCS_CARBON_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS carbon subdirectory.\" ) FileUtils . create_new_dir ( ncs_carbon_dir , message )","title":"create_ncs_carbon_dir()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_ncs_pathways_dir","text":"create_ncs_pathways_dir ( base_dir ) Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 400 401 402 403 404 405 406 407 408 409 410 411 412 @staticmethod def create_ncs_pathways_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_pathway_dir = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS pathways subdirectory.\" ) FileUtils . create_new_dir ( ncs_pathway_dir , message )","title":"create_ncs_pathways_dir()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_new_dir","text":"create_new_dir ( directory , log_message = '' ) Creates new file directory if it doesn't exist Source code in src/cplus_plugin/utils.py 439 440 441 442 443 444 445 446 447 @staticmethod def create_new_dir ( directory : str , log_message : str = \"\" ): \"\"\"Creates new file directory if it doesn't exist\"\"\" p = Path ( directory ) if not p . exists (): try : p . mkdir () except ( FileNotFoundError , OSError ): log ( log_message )","title":"create_new_dir()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_new_file","text":"create_new_file ( file_path , log_message = '' ) Creates new file Source code in src/cplus_plugin/utils.py 449 450 451 452 453 454 455 456 457 458 @staticmethod def create_new_file ( file_path : str , log_message : str = \"\" ): \"\"\"Creates new file\"\"\" p = Path ( file_path ) if not p . exists (): try : p . touch ( exist_ok = True ) except FileNotFoundError : log ( log_message )","title":"create_new_file()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_pwls_dir","text":"create_pwls_dir ( base_dir ) Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 426 427 428 429 430 431 432 433 434 435 436 437 def create_pwls_dir ( base_dir : str ): \"\"\"Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return pwl_dir = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } \" message = tr ( \"Missing parent directory when creating priority weighting layers subdirectory.\" ) FileUtils . create_new_dir ( pwl_dir , message )","title":"create_pwls_dir()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.get_icon","text":"get_icon ( file_name ) Creates an icon based on the icon name in the 'icons' folder. Parameters: Name Type Description Default file_name str File name which should include the extension. required Returns: Type Description QtGui.QIcon Icon object matching the file name. Source code in src/cplus_plugin/utils.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 @staticmethod def get_icon ( file_name : str ) -> QtGui . QIcon : \"\"\"Creates an icon based on the icon name in the 'icons' folder. :param file_name: File name which should include the extension. :type file_name: str :returns: Icon object matching the file name. :rtype: QtGui.QIcon \"\"\" icon_path = os . path . normpath ( f \" { FileUtils . plugin_dir () } /icons/ { file_name } \" ) if not os . path . exists ( icon_path ): return QtGui . QIcon () return QtGui . QIcon ( icon_path )","title":"get_icon()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.plugin_dir","text":"plugin_dir () Returns the root directory of the plugin. Returns: Type Description str Root directory of the plugin. Source code in src/cplus_plugin/utils.py 354 355 356 357 358 359 360 361 @staticmethod def plugin_dir () -> str : \"\"\"Returns the root directory of the plugin. :returns: Root directory of the plugin. :rtype: str \"\"\" return os . path . join ( os . path . dirname ( os . path . realpath ( __file__ )))","title":"plugin_dir()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.report_template_path","text":"report_template_path ( file_name = None ) Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. Parameters: Name Type Description Default file_name str Template file name including the extension. If none is specified then it will use main.qpt as the default template name. None Returns: Type Description str The absolute path to the template file with the given name. Source code in src/cplus_plugin/utils.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 @staticmethod def report_template_path ( file_name = None ) -> str : \"\"\"Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. :param file_name: Template file name including the extension. If none is specified then it will use `main.qpt` as the default template name. :type file_name: str :returns: The absolute path to the template file with the given name. :rtype: str \"\"\" if file_name is None : file_name = TEMPLATE_NAME absolute_path = f \" { FileUtils . plugin_dir () } /data/reports/ { file_name } \" return os . path . normpath ( absolute_path )","title":"report_template_path()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.align_rasters","text":"align_rasters ( input_raster_source , reference_raster_source , extent = None , output_dir = None , rescale_values = False , resample_method = 0 ) Based from work on https://github.com/inasafe/inasafe/pull/2070 Aligns the passed raster files source and save the results into new files. Parameters: Name Type Description Default input_raster_source str Input layer source required reference_raster_source str Reference layer source required extent list Clip extent None output_dir str Absolute path of the output directory for the snapped layers None rescale_values bool Whether to rescale pixel values False resample_method QgsAlignRaster.ResampleAlg Method to use when resampling 0 Source code in src/cplus_plugin/utils.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def align_rasters ( input_raster_source , reference_raster_source , extent = None , output_dir = None , rescale_values = False , resample_method = 0 , ): \"\"\" Based from work on https://github.com/inasafe/inasafe/pull/2070 Aligns the passed raster files source and save the results into new files. :param input_raster_source: Input layer source :type input_raster_source: str :param reference_raster_source: Reference layer source :type reference_raster_source: str :param extent: Clip extent :type extent: list :param output_dir: Absolute path of the output directory for the snapped layers :type output_dir: str :param rescale_values: Whether to rescale pixel values :type rescale_values: bool :param resample_method: Method to use when resampling :type resample_method: QgsAlignRaster.ResampleAlg \"\"\" try : snap_directory = os . path . join ( output_dir , \"snap_layers\" ) FileUtils . create_new_dir ( snap_directory ) input_path = Path ( input_raster_source ) input_layer_output = os . path . join ( f \" { snap_directory } \" , f \" { input_path . stem } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) FileUtils . create_new_file ( input_layer_output ) align = QgsAlignRaster () lst = [ QgsAlignRaster . Item ( input_raster_source , input_layer_output ), ] resample_method_value = QgsAlignRaster . ResampleAlg . RA_NearestNeighbour try : resample_method_value = QgsAlignRaster . ResampleAlg ( int ( resample_method )) except Exception as e : log ( f \"Problem creating a resample value when snapping, { e } \" ) if rescale_values : lst [ 0 ] . rescaleValues = rescale_values lst [ 0 ] . resample_method = resample_method_value align . setRasters ( lst ) align . setParametersFromRaster ( reference_raster_source ) layer = QgsRasterLayer ( input_raster_source , \"input_layer\" ) extent = transform_extent ( layer . extent (), QgsCoordinateReferenceSystem ( layer . crs ()), QgsCoordinateReferenceSystem ( align . destinationCrs ()), ) align . setClipExtent ( extent ) log ( f \"Snapping clip extent { layer . extent () . asWktPolygon () } \\n \" ) if not align . run (): log ( f \"Problem during snapping for { input_raster_source } and \" f \" { reference_raster_source } , { align . errorMessage () } \" ) raise Exception ( align . errorMessage ()) except Exception as e : log ( f \"Problem occured when snapping, { str ( e ) } .\" f \" Update snap settings and re-run the analysis\" ) return None , None log ( f \"Finished snapping\" f \" original layer - { input_raster_source } ,\" f \"snapped output - { input_layer_output } \\n \" ) return input_layer_output , None","title":"align_rasters()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.calculate_raster_value_area","text":"calculate_raster_value_area ( layer , band_number = 1 , feedback = None ) Calculates the area of value pixels for the given band in a raster layer. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. Parameters: Name Type Description Default layer QgsRasterLayer Input layer whose area for value pixels is to be calculated. required band_number int Band number to compute area, default is band one. 1 feedback QgsProcessingFeedback Feedback object for progress during area calculation. None Returns: Type Description float A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. Source code in src/cplus_plugin/utils.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def calculate_raster_value_area ( layer : QgsRasterLayer , band_number : int = 1 , feedback : QgsProcessingFeedback = None ) -> dict : \"\"\"Calculates the area of value pixels for the given band in a raster layer. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. :param layer: Input layer whose area for value pixels is to be calculated. :type layer: QgsRasterLayer :param band_number: Band number to compute area, default is band one. :type band_number: int :param feedback: Feedback object for progress during area calculation. :type feedback: QgsProcessingFeedback :returns: A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. :rtype: float \"\"\" if not layer . isValid (): log ( \"Invalid layer for raster area calculation.\" , info = False ) return {} algorithm_name = \"native:rasterlayeruniquevaluesreport\" params = { \"INPUT\" : layer , \"BAND\" : band_number , \"OUTPUT_TABLE\" : \"TEMPORARY_OUTPUT\" , \"OUTPUT_HTML_FILE\" : QgsProcessing . TEMPORARY_OUTPUT , } algorithm_result = processing . run ( algorithm_name , params , feedback = feedback ) # Get number of pixels with values total_pixel_count = algorithm_result [ \"TOTAL_PIXEL_COUNT\" ] if total_pixel_count == 0 : log ( \"Input layer for raster area calculation is empty.\" , info = False ) return {} output_table = algorithm_result [ \"OUTPUT_TABLE\" ] if output_table is None : log ( \"Unique values raster table could not be retrieved.\" , info = False ) return {} area_calc = QgsDistanceArea () crs = layer . crs () area_calc . setSourceCrs ( crs , QgsCoordinateTransformContext ()) if crs is not None : # Use ellipsoid calculation if available area_calc . setEllipsoid ( crs . ellipsoidAcronym ()) version = Qgis . versionInt () if version < 33000 : unit_type = QgsUnitTypes . AreaUnit . AreaHectares else : unit_type = Qgis . AreaUnit . Hectares pixel_areas = {} features = output_table . getFeatures () for f in features : pixel_value = f . attribute ( 0 ) area = f . attribute ( 2 ) pixel_value_area = area_calc . convertAreaMeasurement ( area , unit_type ) pixel_areas [ pixel_value ] = pixel_value_area return pixel_areas","title":"calculate_raster_value_area()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.clean_filename","text":"clean_filename ( filename ) Creates a safe filename by removing operating system invalid filename characters. Parameters: Name Type Description Default filename str File name required Source code in src/cplus_plugin/utils.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def clean_filename ( filename ): \"\"\"Creates a safe filename by removing operating system invalid filename characters. :param filename: File name :type filename: str :returns A clean file name :rtype str \"\"\" characters = \" %:/,\\[]<>*?\" for character in characters : if character in filename : filename = filename . replace ( character , \"_\" ) return filename","title":"clean_filename()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.get_plugin_version","text":"get_plugin_version () Returns the current plugin version as saved in the metadata.txt plugin file. Returns: Type Description str Plugin version Source code in src/cplus_plugin/utils.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def get_plugin_version () -> [ str , None ]: \"\"\"Returns the current plugin version as saved in the metadata.txt plugin file. :returns version: Plugin version :rtype version: str \"\"\" metadata_file = Path ( __file__ ) . parent . resolve () / \"metadata.txt\" with open ( metadata_file , \"r\" ) as f : for line in f . readlines (): if line . startswith ( \"version\" ): version = line . strip () . split ( \"=\" )[ 1 ] return version return None","title":"get_plugin_version()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.get_report_font","text":"get_report_font ( size = 11.0 , bold = False , italic = False ) Uses the default font family name to create a font for use in the report. Parameters: Name Type Description Default size float The font point size, default is 11. 11.0 bold bool True for bold font else False which is the default. False italic bool True for font to be in italics else False which is the default. False Returns: Type Description QtGui.QFont Font to use in a report. Source code in src/cplus_plugin/utils.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def get_report_font ( size = 11.0 , bold = False , italic = False ) -> QtGui . QFont : \"\"\"Uses the default font family name to create a font for use in the report. :param size: The font point size, default is 11. :type size: float :param bold: True for bold font else False which is the default. :type bold: bool :param italic: True for font to be in italics else False which is the default. :type italic: bool :returns: Font to use in a report. :rtype: QtGui.QFont \"\"\" font_weight = 50 if bold is True : font_weight = 75 return QtGui . QFont ( REPORT_FONT_NAME , int ( size ), font_weight , italic )","title":"get_report_font()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.log","text":"log ( message , name = 'qgis_cplus' , info = True , notify = True ) Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. Parameters: Name Type Description Default message str The log message required name str Name of te log instance, qgis_cplus is the default 'qgis_cplus' info bool Whether the message is about info or a warning True notify bool Whether to notify user about the log True Source code in src/cplus_plugin/utils.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def log ( message : str , name : str = \"qgis_cplus\" , info : bool = True , notify : bool = True , ): \"\"\"Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. :param message: The log message :type message: str :param name: Name of te log instance, qgis_cplus is the default :type message: str :param info: Whether the message is about info or a warning :type info: bool :param notify: Whether to notify user about the log :type notify: bool \"\"\" level = Qgis . Info if info else Qgis . Warning QgsMessageLog . logMessage ( message , name , level = level , notifyUser = notify , )","title":"log()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.open_documentation","text":"open_documentation ( url = None ) Opens documentation website in the default browser Parameters: Name Type Description Default url str URL link to documentation site (e.g. gh pages site) None Source code in src/cplus_plugin/utils.py 85 86 87 88 89 90 91 92 93 94 def open_documentation ( url = None ): \"\"\"Opens documentation website in the default browser :param url: URL link to documentation site (e.g. gh pages site) :type url: str \"\"\" url = DOCUMENTATION_SITE if url is None else url result = QtGui . QDesktopServices . openUrl ( QtCore . QUrl ( url )) return result","title":"open_documentation()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.tr","text":"tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message str, QString String for translation. required Returns: Type Description QString Translated version of message. Source code in src/cplus_plugin/utils.py 39 40 41 42 43 44 45 46 47 48 49 50 def tr ( message ): \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation. :type message: str, QString :returns: Translated version of message. :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QtCore . QCoreApplication . translate ( \"QgisCplus\" , message )","title":"tr()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.transform_extent","text":"transform_extent ( extent , source_crs , dest_crs ) Transforms the passed extent into the destination crs :param extent: Target extent Parameters: Name Type Description Default source_crs QgsCoordinateReferenceSystem Source CRS of the passed extent required dest_crs QgsCoordinateReferenceSystem Destination CRS required Source code in src/cplus_plugin/utils.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 def transform_extent ( extent , source_crs , dest_crs ): \"\"\"Transforms the passed extent into the destination crs :param extent: Target extent :type extent: QgsRectangle :param source_crs: Source CRS of the passed extent :type source_crs: QgsCoordinateReferenceSystem :param dest_crs: Destination CRS :type dest_crs: QgsCoordinateReferenceSystem \"\"\" transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance ()) transformed_extent = transform . transformBoundingBox ( extent ) return transformed_extent","title":"transform_extent()"},{"location":"developer/api/gui/api_carbon_layer_model/","text":"Carbon Layer Model MVC model for carbon layer paths. CarbonLayerItem CarbonLayerItem ( layer_path ) Bases: QStandardItem Represents a single carbon layer path. Source code in src/cplus_plugin/gui/carbon_item_model.py 19 20 21 22 23 24 def __init__ ( self , layer_path : str ): super () . __init__ () self . _layer_path = layer_path self . _is_valid = True self . update ( self . _layer_path ) is_valid property is_valid Returns the validity status of the carbon layer path. The path could be invalid if it does not exist or if the corresponding map layer is invalid. Returns: Type Description bool True if valid, else False. layer_path property layer_path Returns the path to the carbon layer. Returns: Type Description str Path to the carbon layer. type type () Returns the type of the standard item. Returns: Type Description int Type identifier of the carbob item. Source code in src/cplus_plugin/gui/carbon_item_model.py 71 72 73 74 75 76 77 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the carbob item. :rtype: int \"\"\" return QtGui . QStandardItem . UserType + 5 update update ( layer_path ) Update the UI properties. Source code in src/cplus_plugin/gui/carbon_item_model.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def update ( self , layer_path : str ): \"\"\"Update the UI properties.\"\"\" self . _layer_path = str ( os . path . normpath ( layer_path )) p = Path ( self . _layer_path ) self . setText ( p . name ) self . setToolTip ( self . _layer_path ) # Check validity if p . exists (): layer = QgsRasterLayer ( layer_path ) if layer . isValid (): self . _is_valid = True self . setIcon ( QtGui . QIcon ()) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"Carbon layer is not invalid.\" )) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"File path is invalid.\" )) CarbonLayerModel CarbonLayerModel ( parent = None , carbon_paths = None ) Bases: QStandardItemModel View model for carbon layers. Source code in src/cplus_plugin/gui/carbon_item_model.py 83 84 85 86 87 88 89 90 91 def __init__ ( self , parent = None , carbon_paths : typing . Union [ typing . List [ str ], None ] = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) if carbon_paths is not None : for cp in carbon_paths : self . add_carbon_layer ( cp ) add_carbon_layer add_carbon_layer ( layer_path ) Adds a carbon layer to the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the carbon layer was successfully added, else False if there is an existing item with the same path. Source code in src/cplus_plugin/gui/carbon_item_model.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def add_carbon_layer ( self , layer_path : str ) -> bool : \"\"\"Adds a carbon layer to the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the carbon layer was successfully added, else False if there is an existing item with the same path. \"\"\" if self . contains_layer_path ( layer_path ): return False carbon_item = CarbonLayerItem ( layer_path ) self . appendRow ( carbon_item ) return True carbon_layer_index carbon_layer_index ( layer_path ) Get the model index for the given layer path. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description QtCore.QModelIndex The index corresponding to the given layer path else an invalid index if not found. Source code in src/cplus_plugin/gui/carbon_item_model.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def carbon_layer_index ( self , layer_path : str ) -> QtCore . QModelIndex : \"\"\"Get the model index for the given layer path. :param layer_path: Carbon layer path. :type layer_path: str :returns: The index corresponding to the given layer path else an invalid index if not found. :rtype: QtCore.QModelIndex \"\"\" norm_path = str ( os . path . normpath ( layer_path )) matching_index = None for r in range ( self . rowCount ()): index = self . index ( r , 0 ) if not index . isValid (): continue item = self . itemFromIndex ( index ) if item . layer_path == norm_path : matching_index = index break if matching_index is None : return QtCore . QModelIndex () return matching_index carbon_paths carbon_paths ( valid_only = False ) Gets all the carbon paths in the model. Parameters: Name Type Description Default valid_only bool Only return the carbon paths that are valid. False Returns: Type Description list A collection of carbon paths in the model. Source code in src/cplus_plugin/gui/carbon_item_model.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def carbon_paths ( self , valid_only : bool = False ) -> list : \"\"\"Gets all the carbon paths in the model. :param valid_only: Only return the carbon paths that are valid. :type valid_only: bool :returns: A collection of carbon paths in the model. :rtype: list \"\"\" carbon_paths = [] for r in range ( self . rowCount ()): index = self . index ( r , 0 ) item = self . itemFromIndex ( index ) if valid_only : if item . is_valid : carbon_paths . append ( item . layer_path ) else : carbon_paths . append ( item . layer_path ) return carbon_paths contains_layer_path contains_layer_path ( layer_path ) Checks if the specified layer path exists in the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the path exists, else False. Source code in src/cplus_plugin/gui/carbon_item_model.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def contains_layer_path ( self , layer_path : str ) -> bool : \"\"\"Checks if the specified layer path exists in the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path exists, else False. :rtype: bool \"\"\" carbon_idx = self . carbon_layer_index ( layer_path ) if carbon_idx . isValid (): return True return False update_carbon_path update_carbon_path ( index , layer_path ) Update the carbon path at the given position specified by the index. Parameters: Name Type Description Default index QModelIndex Location to modify the carbon path. required layer_path str Carbon layer path. required Returns: Type Description bool True if the path was successfully updated else False if there is no carbon item at the given location. Source code in src/cplus_plugin/gui/carbon_item_model.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def update_carbon_path ( self , index : QtCore . QModelIndex , layer_path : str ) -> bool : \"\"\"Update the carbon path at the given position specified by the index. :param index: Location to modify the carbon path. :type index: QtCore.QModelIndex :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path was successfully updated else False if there is no carbon item at the given location. :rtype: bool \"\"\" if not index . isValid (): return False item = self . itemFromIndex ( index ) if item is None : return False item . update ( layer_path ) return True","title":"Carbon item model"},{"location":"developer/api/gui/api_carbon_layer_model/#carbon-layer-model","text":"MVC model for carbon layer paths.","title":"Carbon Layer Model"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem","text":"CarbonLayerItem ( layer_path ) Bases: QStandardItem Represents a single carbon layer path. Source code in src/cplus_plugin/gui/carbon_item_model.py 19 20 21 22 23 24 def __init__ ( self , layer_path : str ): super () . __init__ () self . _layer_path = layer_path self . _is_valid = True self . update ( self . _layer_path )","title":"CarbonLayerItem"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.is_valid","text":"is_valid Returns the validity status of the carbon layer path. The path could be invalid if it does not exist or if the corresponding map layer is invalid. Returns: Type Description bool True if valid, else False.","title":"is_valid"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.layer_path","text":"layer_path Returns the path to the carbon layer. Returns: Type Description str Path to the carbon layer.","title":"layer_path"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the carbob item. Source code in src/cplus_plugin/gui/carbon_item_model.py 71 72 73 74 75 76 77 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the carbob item. :rtype: int \"\"\" return QtGui . QStandardItem . UserType + 5","title":"type()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.update","text":"update ( layer_path ) Update the UI properties. Source code in src/cplus_plugin/gui/carbon_item_model.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def update ( self , layer_path : str ): \"\"\"Update the UI properties.\"\"\" self . _layer_path = str ( os . path . normpath ( layer_path )) p = Path ( self . _layer_path ) self . setText ( p . name ) self . setToolTip ( self . _layer_path ) # Check validity if p . exists (): layer = QgsRasterLayer ( layer_path ) if layer . isValid (): self . _is_valid = True self . setIcon ( QtGui . QIcon ()) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"Carbon layer is not invalid.\" )) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"File path is invalid.\" ))","title":"update()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel","text":"CarbonLayerModel ( parent = None , carbon_paths = None ) Bases: QStandardItemModel View model for carbon layers. Source code in src/cplus_plugin/gui/carbon_item_model.py 83 84 85 86 87 88 89 90 91 def __init__ ( self , parent = None , carbon_paths : typing . Union [ typing . List [ str ], None ] = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) if carbon_paths is not None : for cp in carbon_paths : self . add_carbon_layer ( cp )","title":"CarbonLayerModel"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.add_carbon_layer","text":"add_carbon_layer ( layer_path ) Adds a carbon layer to the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the carbon layer was successfully added, else False if there is an existing item with the same path. Source code in src/cplus_plugin/gui/carbon_item_model.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def add_carbon_layer ( self , layer_path : str ) -> bool : \"\"\"Adds a carbon layer to the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the carbon layer was successfully added, else False if there is an existing item with the same path. \"\"\" if self . contains_layer_path ( layer_path ): return False carbon_item = CarbonLayerItem ( layer_path ) self . appendRow ( carbon_item ) return True","title":"add_carbon_layer()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.carbon_layer_index","text":"carbon_layer_index ( layer_path ) Get the model index for the given layer path. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description QtCore.QModelIndex The index corresponding to the given layer path else an invalid index if not found. Source code in src/cplus_plugin/gui/carbon_item_model.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def carbon_layer_index ( self , layer_path : str ) -> QtCore . QModelIndex : \"\"\"Get the model index for the given layer path. :param layer_path: Carbon layer path. :type layer_path: str :returns: The index corresponding to the given layer path else an invalid index if not found. :rtype: QtCore.QModelIndex \"\"\" norm_path = str ( os . path . normpath ( layer_path )) matching_index = None for r in range ( self . rowCount ()): index = self . index ( r , 0 ) if not index . isValid (): continue item = self . itemFromIndex ( index ) if item . layer_path == norm_path : matching_index = index break if matching_index is None : return QtCore . QModelIndex () return matching_index","title":"carbon_layer_index()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.carbon_paths","text":"carbon_paths ( valid_only = False ) Gets all the carbon paths in the model. Parameters: Name Type Description Default valid_only bool Only return the carbon paths that are valid. False Returns: Type Description list A collection of carbon paths in the model. Source code in src/cplus_plugin/gui/carbon_item_model.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def carbon_paths ( self , valid_only : bool = False ) -> list : \"\"\"Gets all the carbon paths in the model. :param valid_only: Only return the carbon paths that are valid. :type valid_only: bool :returns: A collection of carbon paths in the model. :rtype: list \"\"\" carbon_paths = [] for r in range ( self . rowCount ()): index = self . index ( r , 0 ) item = self . itemFromIndex ( index ) if valid_only : if item . is_valid : carbon_paths . append ( item . layer_path ) else : carbon_paths . append ( item . layer_path ) return carbon_paths","title":"carbon_paths()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.contains_layer_path","text":"contains_layer_path ( layer_path ) Checks if the specified layer path exists in the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the path exists, else False. Source code in src/cplus_plugin/gui/carbon_item_model.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def contains_layer_path ( self , layer_path : str ) -> bool : \"\"\"Checks if the specified layer path exists in the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path exists, else False. :rtype: bool \"\"\" carbon_idx = self . carbon_layer_index ( layer_path ) if carbon_idx . isValid (): return True return False","title":"contains_layer_path()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.update_carbon_path","text":"update_carbon_path ( index , layer_path ) Update the carbon path at the given position specified by the index. Parameters: Name Type Description Default index QModelIndex Location to modify the carbon path. required layer_path str Carbon layer path. required Returns: Type Description bool True if the path was successfully updated else False if there is no carbon item at the given location. Source code in src/cplus_plugin/gui/carbon_item_model.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def update_carbon_path ( self , index : QtCore . QModelIndex , layer_path : str ) -> bool : \"\"\"Update the carbon path at the given position specified by the index. :param index: Location to modify the carbon path. :type index: QtCore.QModelIndex :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path was successfully updated else False if there is no carbon item at the given location. :rtype: bool \"\"\" if not index . isValid (): return False item = self . itemFromIndex ( index ) if item is None : return False item . update ( layer_path ) return True","title":"update_carbon_path()"},{"location":"developer/api/gui/api_component_items/","text":"Component item model Contains item models for view widgets such as NCS pathway or IM views. ComponentItemModel ComponentItemModel ( parent = None ) Bases: QStandardItemModel View model for ModelComponent objects. Source code in src/cplus_plugin/gui/component_item_model.py 641 642 643 644 645 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) self . _uuid_row_idx = {} add_component_item add_component_item ( component_item , position =- 1 ) Adds a model component item to the view model. Parameters: Name Type Description Default component_item ModelComponentItem Model component item to be added to the view model. required position int Reference row to insert the item. -1 Returns: Type Description bool True if the component item was successfully added, else False if there is an existing component item with the same UUID. Source code in src/cplus_plugin/gui/component_item_model.py 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 def add_component_item ( self , component_item : ModelComponentItem , position =- 1 ) -> bool : \"\"\"Adds a model component item to the view model. :param component_item: Model component item to be added to the view model. :type component_item: ModelComponentItem :param position: Reference row to insert the item. :type position: int :returns: True if the component item was successfully added, else False if there is an existing component item with the same UUID. :rtype: bool \"\"\" idx = position if position == - 1 : idx = self . rowCount () if self . contains_item ( str ( component_item . uuid )): return False self . insertRow ( idx , component_item ) self . _re_index_rows () return True component_item_by_uuid component_item_by_uuid ( uuid_str ) Retrieves a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description ModelComponentItem Component item matching the given UUID or None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 def component_item_by_uuid ( self , uuid_str : str ) -> typing . Union [ ModelComponentItemType , None ]: \"\"\"Retrieves a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: Component item matching the given UUID or None if not found. :rtype: ModelComponentItem \"\"\" if uuid_str not in self . _uuid_row_idx : return None row = self . _uuid_row_idx [ uuid_str ] return self . item ( row ) contains_item contains_item ( item_uuid ) Checks if the model contains an item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the model item. required Returns: Type Description bool True if there is an existing item else False. Source code in src/cplus_plugin/gui/component_item_model.py 676 677 678 679 680 681 682 683 684 685 def contains_item ( self , item_uuid : str ) -> bool : \"\"\"Checks if the model contains an item with the given UUID. :param item_uuid: UUID of the model item. :type item_uuid: str :returns: True if there is an existing item else False. :rtype: bool \"\"\" return True if self . component_item_by_uuid ( item_uuid ) is not None else False enable_default_items enable_default_items ( state ) Enable or disable items for default model components. Parameters: Name Type Description Default state bool True to enable or False to disable. required Source code in src/cplus_plugin/gui/component_item_model.py 800 801 802 803 804 805 806 807 808 809 810 811 def enable_default_items ( self , state : bool ): \"\"\"Enable or disable items for default model components. :param state: True to enable or False to disable. :type state: bool \"\"\" for item in self . model_component_items (): if not isinstance ( item , LayerComponentItem ): continue if not item . user_defined : item . setEnabled ( state ) index_by_uuid index_by_uuid ( uuid_str ) Get the QModelIndex object for the component item matching the given UUID identifier. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description QtCore.QModelIndex QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. Source code in src/cplus_plugin/gui/component_item_model.py 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 def index_by_uuid ( self , uuid_str ) -> QtCore . QModelIndex : \"\"\"Get the QModelIndex object for the component item matching the given UUID identifier. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. :rtype: QtCore.QModelIndex \"\"\" if uuid_str not in self . _uuid_row_idx : return QtCore . QModelIndex () row = self . _uuid_row_idx [ uuid_str ] return self . index ( row , 0 ) model_component_items model_component_items () Returns model component items in the model. Returns: Type Description list Model component items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 748 749 750 751 752 753 754 755 756 757 758 759 760 761 def model_component_items ( self ) -> typing . List [ ModelComponentItem ]: \"\"\"Returns model component items in the model. :returns: Model component items in the model. :rtype: list \"\"\" rows = self . rowCount () items = [] for r in range ( rows ): item = self . item ( r ) items . append ( item ) return items model_components model_components () Returns a collection of model component objects in the model. Returns: Type Description list A collection of all model component objects. Source code in src/cplus_plugin/gui/component_item_model.py 740 741 742 743 744 745 746 def model_components ( self ) -> typing . List [ BaseModelComponentType ]: \"\"\"Returns a collection of model component objects in the model. :returns: A collection of all model component objects. :rtype: list \"\"\" return [ item . model_component for item in self . model_component_items ()] remove_component_item remove_component_item ( uuid_str ) Removes a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item to be removed. required Returns: Type Description bool True if the component item was successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 def remove_component_item ( self , uuid_str : str ) -> bool : \"\"\"Removes a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item to be removed. :type uuid_str: str :returns: True if the component item was successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" if not self . contains_item ( uuid_str ): return False if uuid_str not in self . _uuid_row_idx : return False self . removeRows ( self . _uuid_row_idx [ uuid_str ], 1 ) del self . _uuid_row_idx [ uuid_str ] self . _re_index_rows () return True update_item update_item ( item ) Update an existing ModelComponentItem if it exists in the model. Parameters: Name Type Description Default item ModelComponentItemType An updated instance of the ModelComponentItem. required Returns: Type Description bool True if the item was successfully updated, else False if there was no matching item found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 def update_item ( self , item : ModelComponentItemType ) -> bool : \"\"\"Update an existing ModelComponentItem if it exists in the model. :param item: An updated instance of the ModelComponentItem. :type item: ModelComponentItem :returns: True if the item was successfully updated, else False if there was no matching item found in the model. :rtype: bool \"\"\" if not self . contains_item ( item . uuid ): return False item . update ( item . model_component ) return True IMItemModel Bases: ComponentItemModel View model for implementation model. add_implementation_model add_implementation_model ( implementation_model , layer = None ) Add an ImplementationModel object to the model. Parameters: Name Type Description Default implementation_model ImplementationModel ImplementationModel object to be added to the view. required layer QgsMapLayer Map layer for the implementation model. None Returns: Type Description bool True if ImplementationModel object was added successfully, else False. Source code in src/cplus_plugin/gui/component_item_model.py 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 def add_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ) -> bool : \"\"\"Add an ImplementationModel object to the model. :param implementation_model: ImplementationModel object to be added to the view. :type implementation_model: ImplementationModel :param layer: Map layer for the implementation model. :type layer: QgsMapLayer :returns: True if ImplementationModel object was added successfully, else False. :rtype: bool \"\"\" # Check if we can retrieve the layer from the path if layer is None : if implementation_model . path : layer = implementation_model . to_map_layer () implementation_model_item = ImplementationModelItem . create ( implementation_model ) result = self . add_component_item ( implementation_model_item ) if layer : status = self . set_model_layer ( implementation_model_item , layer ) if not status : result = False else : # Add NCS pathways. If there are underlying NCS pathway objects then # clone them, remove then re-insert so that the underlying NCS pathways can # have the unique UUID in the IM item. if result : cloned_implementation_model = clone_implementation_model ( implementation_model ) cloned_ncs_pathways = cloned_implementation_model . pathways # Remove pathways in the IM implementation_model . pathways = [] # Now add the NCSs afresh for ncs in cloned_ncs_pathways : ncs_item = NcsPathwayItem . create ( ncs ) self . add_ncs_pathway ( ncs_item , implementation_model_item ) return result add_ncs_pathway add_ncs_pathway ( ncs_item , target_model_item ) Adds an NCS pathway item to the model. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required target_model_item ImplementationModelItem Target implementation model for the NCS item. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the implementation model. Source code in src/cplus_plugin/gui/component_item_model.py 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 def add_ncs_pathway ( self , ncs_item : NcsPathwayItem , target_model_item : ImplementationModelItem ) -> bool : \"\"\"Adds an NCS pathway item to the model. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :param target_model_item: Target implementation model for the NCS item. :type target_model_item: ImplementationModelItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the implementation model. \"\"\" idx = target_model_item . index () if not idx . isValid (): return False if not isinstance ( target_model_item , LayerComponentItem ): return False # Do not add if the IM item has been disabled (e.g. disabled default IMs) if not target_model_item . isEnabled (): return False # If there is an existing layer then return if target_model_item . layer : return False clone_ncs_item = ncs_item . clone () status = target_model_item . add_ncs_pathway_item ( clone_ncs_item ) if not status : return False bottom_idx = target_model_item . bottom_ncs_item_index () reference_row = max ( bottom_idx . row (), idx . row ()) self . add_component_item ( clone_ncs_item , reference_row + 1 ) self . im_pathways_updated . emit ( target_model_item ) return True dropMimeData dropMimeData ( data , action , row , column , parent ) Implements behaviour for handling data supplied by drag and drop operation. Parameters: Name Type Description Default data QMimeData Object containing data from the drag operation. required action DropAction Type of the drag and drop operation. required row int Row location of dropped data. required column int Column location of dropped data. required parent QModelIndex Index location for target item where the operation ended. required Returns: Type Description bool True if the data and action can be handled by the model, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 def dropMimeData ( self , data : QtCore . QMimeData , action : QtCore . Qt . DropAction , row : int , column : int , parent : QtCore . QModelIndex , ) -> bool : \"\"\"Implements behaviour for handling data supplied by drag and drop operation. :param data: Object containing data from the drag operation. :type data: QtCore.QMimeData :param action: Type of the drag and drop operation. :type action: QtCore.Qt.DropAction :param row: Row location of dropped data. :type row: int :param column: Column location of dropped data. :type column: int :param parent: Index location for target item where the operation ended. :type parent: QtCore.QModelIndex :returns: True if the data and action can be handled by the model, else False. :rtype: bool \"\"\" if action == QtCore . Qt . IgnoreAction : return True if not data . hasFormat ( NCS_MIME_TYPE ): return False encoded_data = data . data ( NCS_MIME_TYPE ) data_stream = QtCore . QDataStream ( encoded_data , QtCore . QIODevice . ReadOnly ) ncs_items = [] while not data_stream . atEnd (): byte_data = QtCore . QByteArray () data_stream >> byte_data item_data = json . loads ( byte_data . data ()) ncs_pathway = create_ncs_pathway ( item_data ) ncs_item = NcsPathwayItem ( ncs_pathway ) ncs_items . append ( ncs_item ) # Get reference ImplementationModel item if parent . isValid (): model_item = self . itemFromIndex ( parent ) else : row_count = self . rowCount () model_item = self . item ( row_count - 1 ) if model_item is None or isinstance ( model_item , LayerItem ): return False if model_item . type () == NCS_PATHWAY_TYPE : target_im_item = model_item . parent else : target_im_item = model_item # Add NCS items to model. status = True for item in ncs_items : status = self . add_ncs_pathway ( item , target_im_item ) return status model_items model_items () Returns all ImplementationModelItem objects in the model. Returns: Type Description list Implementation model items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1201 1202 1203 1204 1205 1206 1207 1208 1209 def model_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns all ImplementationModelItem objects in the model. :returns: Implementation model items in the model. :rtype: list \"\"\" component_items = self . model_component_items () return [ ci for ci in component_items if ci . type () == IMPLEMENTATION_MODEL_TYPE ] models models () Returns implementation model objects in the model. Returns: Type Description list Implementation model objects in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1193 1194 1195 1196 1197 1198 1199 def models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns implementation model objects in the model. :returns: Implementation model objects in the model. :rtype: list \"\"\" return [ model_item . implementation_model for model_item in self . model_items ()] remove_implementation_model remove_implementation_model ( uuid_str ) Remove an implementation model item from the model. param uuid: UUID of the implementation model item to be removed. Returns: Type Description bool True if the implementation model item as successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 def remove_implementation_model ( self , uuid_str : str ) -> bool : \"\"\"Remove an implementation model item from the model. param uuid: UUID of the implementation model item to be removed. :type uuid_str: str :returns: True if the implementation model item as successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" implementation_model_item = self . component_item_by_uuid ( uuid_str ) if implementation_model_item is None : return False if len ( implementation_model_item . ncs_items ) > 0 : ncs_items = implementation_model_item . ncs_items for item in ncs_items : self . remove_component_item ( item . uuid ) else : # Layer item self . remove_layer ( implementation_model_item ) return self . remove_component_item ( uuid_str ) remove_layer remove_layer ( implementation_model_item ) Removes the layer reference from the underlying implementation model. Parameters: Name Type Description Default implementation_model_item ImplementationModelItem Implementation model item whose layer is to be removed. required Source code in src/cplus_plugin/gui/component_item_model.py 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 def remove_layer ( self , implementation_model_item : ImplementationModelItem ): \"\"\"Removes the layer reference from the underlying implementation model. :param implementation_model_item: Implementation model item whose layer is to be removed. :type implementation_model_item: ImplementationModelItem \"\"\" if implementation_model_item . layer is None : return if not self . contains_item ( implementation_model_item . uuid ): return # Remove item in model item_idx = self . index_by_uuid ( implementation_model_item . uuid ) layer_row = item_idx . row () + 1 self . removeRows ( layer_row , 1 ) self . _re_index_rows () # Remove underlying layer reference implementation_model_item . clear_layer () remove_ncs_pathway_item remove_ncs_pathway_item ( ncs_uuid , parent ) Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. Parameters: Name Type Description Default parent ImplementationModelItem Reference implementation model item that is the parent to the NCS pathway item. required Returns: Type Description bool True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 def remove_ncs_pathway_item ( self , ncs_uuid : str , parent : ImplementationModelItem ) -> bool : \"\"\"Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :param parent: Reference implementation model item that is the parent to the NCS pathway item. :type parent: ImplementationModelItem :returns: True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. :rtype: bool \"\"\" status = parent . remove_ncs_pathway_item ( ncs_uuid ) if not status : return False self . im_pathways_updated . emit ( parent ) return self . remove_component_item ( ncs_uuid ) remove_ncs_pathway_items remove_ncs_pathway_items ( ncs_pathway_uuid ) Delete NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be deleted. Parameters: Name Type Description Default ncs_pathway_uuid str Unique identifier of the NCS pathway object whose corresponding models are to be removed in the implementation models. required Source code in src/cplus_plugin/gui/component_item_model.py 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 def remove_ncs_pathway_items ( self , ncs_pathway_uuid : str ): \"\"\"Delete NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be deleted. :param ncs_pathway_uuid: Unique identifier of the NCS pathway object whose corresponding models are to be removed in the implementation models. :type ncs_pathway_uuid: str \"\"\" for im_item in self . model_items (): ncs_item_for_original = im_item . ncs_item_from_original_pathway ( ncs_pathway_uuid ) if ncs_item_for_original is None : continue status = self . remove_ncs_pathway_item ( ncs_item_for_original . uuid , im_item ) set_model_layer set_model_layer ( implementation_model_item , layer , display_name = '' ) Set the layer for the given implementation model item. Parameters: Name Type Description Default implementation_model_item ImplementationModelItem Implementation model item whose layer is to be specified. required layer QgsMapLayer Map layer to be set for the implementation model. required display_name str Display name for the layer node. If not specified then the name from the map layer is used. '' Returns: Type Description bool True if the layer was successfully set for the implementation model, else False if the layer is invalid, if there are already existing NCS pathways in the implementation model or if the item is not in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 def set_model_layer ( self , implementation_model_item : ImplementationModelItem , layer : QgsMapLayer , display_name : str = \"\" , ) -> bool : \"\"\"Set the layer for the given implementation model item. :param implementation_model_item: Implementation model item whose layer is to be specified. :type implementation_model_item: ImplementationModelItem :param layer: Map layer to be set for the implementation model. :type layer: QgsMapLayer :param display_name: Display name for the layer node. If not specified then the name from the map layer is used. :type display_name: str :returns: True if the layer was successfully set for the implementation model, else False if the layer is invalid, if there are already existing NCS pathways in the implementation model or if the item is not in the model. :rtype: bool \"\"\" if len ( implementation_model_item . ncs_items ) > 0 : return False if not self . contains_item ( implementation_model_item . uuid ): return False if not implementation_model_item . set_layer ( layer ): return False if not display_name : display_name = layer . name () icon = FileUtils . get_icon ( \"mIconRaster.svg\" ) item = LayerItem ( icon , display_name ) item . setToolTip ( layer . source ()) item . setData ( implementation_model_item ) item_idx = self . index_by_uuid ( implementation_model_item . uuid ) layer_row = item_idx . row () + 1 self . insertRow ( layer_row , item ) self . _re_index_rows () return True update_implementation_model update_implementation_model ( implementation_model , layer = None ) Updates the implementation model item in the model. Parameters: Name Type Description Default implementation_model ImplementationModel implementation_model object whose corresponding item is to be updated. required layer QgsMapLayer Map layer to be updated for the implementation if specified. None Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 def update_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ) -> bool : \"\"\"Updates the implementation model item in the model. :param implementation_model: implementation_model object whose corresponding item is to be updated. :type implementation_model: ImplementationModel :param layer: Map layer to be updated for the implementation if specified. :type layer: QgsMapLayer :returns: Returns True if the operation was successful else False if the matching item was not found in the model. \"\"\" item = self . component_item_by_uuid ( str ( implementation_model . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False # Update layer information self . remove_layer ( item ) if layer : layer_status = self . set_model_layer ( item , layer ) if not layer_status : return False return True update_ncs_pathway_items update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be updated. Parameters: Name Type Description Default ncs_pathway NcsPathway Original NCS pathway object whose corresponding models are to be updated. required Returns: Type Description bool True if matching NCS pathway items have been updated, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be updated. :param ncs_pathway: Original NCS pathway object whose corresponding models are to be updated. :type ncs_pathway: NcsPathway :returns: True if matching NCS pathway items have been updated, else False. :rtype: bool \"\"\" if not ncs_pathway . is_valid (): return False for im_item in self . model_items (): ncs_item_for_original = im_item . ncs_item_from_original_pathway ( ncs_pathway ) if ncs_item_for_original is None : continue item_pathway = ncs_item_for_original . ncs_pathway # Copy attribute values excluding the UUID copy_layer_component_attributes ( item_pathway , ncs_pathway ) ncs_item_for_original . update ( item_pathway ) return True ImplementationModelItem ImplementationModelItem ( implementation_model ) Bases: LayerComponentItem Standard item for an implementation model object. Source code in src/cplus_plugin/gui/component_item_model.py 310 311 312 313 314 315 316 317 318 319 320 321 322 def __init__ ( self , implementation_model : ImplementationModel ): super () . __init__ ( implementation_model ) self . _implementation_model = implementation_model font = self . font () font . setBold ( True ) self . setFont ( font ) self . _ncs_items = [] # Remap pathway uuids so that there are no duplicate # pathways under each implementation model. self . _uuid_remap = {} implementation_model property implementation_model Returns an instance of the underlying ImplementationModel object. Returns: Type Description ImplementationModel The underlying ImplementationModel object. layer_item property layer_item Returns the view item for the layer. Returns: Type Description QtGui.QStandardItem Returns the view item for the map layer else None if no layer has been specified for the model. ncs_items property ncs_items Returns a collection of NcsPathwayItem in this implementation model. Returns: Type Description list Collection of NcsPathwayItem objects in this implementation model. ncs_pathways property ncs_pathways Returns a collection of NcsPathway objects. Returns: Type Description list Collection of NcsPathway objects linked to the underlying ImplementationModel object. original_ncs_pathways property original_ncs_pathways Returns a collection of NcsPathway objects but with their original UUIDs. These are used for persisting the NCsPathway objects related to the underlying IM object. Returns: Type Description list Collection of NcsPathway objects with their original UUIDs linked to the underlying ImplementationModel object. add_ncs_pathway_item add_ncs_pathway_item ( ncs_item ) Adds an NCS pathway item to this implementation model item. If the item already contains a layer, then the add operation will not be successful. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. Source code in src/cplus_plugin/gui/component_item_model.py 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 def add_ncs_pathway_item ( self , ncs_item : NcsPathwayItem ) -> bool : \"\"\"Adds an NCS pathway item to this implementation model item. If the item already contains a layer, then the add operation will not be successful. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. \"\"\" if self . layer : return False old_uuid = ncs_item . uuid new_uuid = uuid4 () ncs_item . ncs_pathway . uuid = new_uuid if old_uuid in self . _uuid_remap : return False if self . contains_ncs_item ( ncs_item . uuid ): return False if not ncs_item . is_valid (): return False if self . _implementation_model . contains_pathway ( ncs_item . uuid ): return False if not self . _implementation_model . add_ncs_pathway ( ncs_item . ncs_pathway ): return False self . _ncs_items . append ( ncs_item ) ncs_item . _parent = self self . _uuid_remap [ old_uuid ] = str ( new_uuid ) return True bottom_ncs_item_index bottom_ncs_item_index () Returns the model index of the bottom-most NcsPathwayItem under this implementation model item. Returns: Type Description QModelIndex Model index of the bottom-most NcsPathwayItem. Source code in src/cplus_plugin/gui/component_item_model.py 533 534 535 536 537 538 539 540 541 542 543 544 545 def bottom_ncs_item_index ( self ) -> typing . Union [ QtCore . QModelIndex , None ]: \"\"\"Returns the model index of the bottom-most NcsPathwayItem under this implementation model item. :returns: Model index of the bottom-most NcsPathwayItem. :rtype: QModelIndex \"\"\" if len ( self . _ncs_items ) == 0 : return None bottom_ncs_item = max ( self . _ncs_items , key = lambda n : n . index () . row ()) return bottom_ncs_item . index () clear_layer clear_layer () Clears the layer reference in the model component. Source code in src/cplus_plugin/gui/component_item_model.py 423 424 425 def clear_layer ( self ): \"\"\"Clears the layer reference in the model component.\"\"\" self . _implementation_model . clear_layer () clone clone () Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the IM will not change. Source code in src/cplus_plugin/gui/component_item_model.py 566 567 568 569 570 571 572 573 574 575 576 577 578 def clone ( self ) -> \"ImplementationModelItem\" : \"\"\"Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the IM will not change. \"\"\" implementation_model = clone_implementation_model ( self . implementation_model , ) # Use NCS pathways with original UUIDs implementation_model . pathways = self . original_ncs_pathways return ImplementationModelItem ( implementation_model ) contains_ncs_item contains_ncs_item ( item_uuid ) Checks whether this item contains an NcsPathway item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the NcsPathway item to search for. required Returns: Type Description bool True if there is an NcsPathwayItem matching the given UUID, else False. Source code in src/cplus_plugin/gui/component_item_model.py 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 def contains_ncs_item ( self , item_uuid : str ) -> bool : \"\"\"Checks whether this item contains an NcsPathway item with the given UUID. :param item_uuid: UUID of the NcsPathway item to search for. :type item_uuid: str :returns: True if there is an NcsPathwayItem matching the given UUID, else False. :rtype: bool \"\"\" if self . ncs_item_by_uuid ( item_uuid ) is None : return False return True create staticmethod create ( implementation_model ) Creates an instance of the ImplementationModelItem from the model object. Returns: Type Description ImplementationModel An instance of the ImplementationModelItem item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 555 556 557 558 559 560 561 562 563 564 @staticmethod def create ( implementation_model : ImplementationModel ) -> \"ImplementationModelItem\" : \"\"\"Creates an instance of the ImplementationModelItem from the model object. :returns: An instance of the ImplementationModelItem item to be used in a standard model. :rtype: ImplementationModel \"\"\" return ImplementationModelItem ( implementation_model ) enable_default_pathways enable_default_pathways ( state ) Enable or disable default NCS pathway items. Parameters: Name Type Description Default state bool True to enable default NCS pathways else False to disable them. required Source code in src/cplus_plugin/gui/component_item_model.py 580 581 582 583 584 585 586 587 588 589 590 591 592 def enable_default_pathways ( self , state : bool ): \"\"\"Enable or disable default NCS pathway items. :param state: True to enable default NCS pathways else False to disable them. :type state: bool \"\"\" for ncs_item in self . _ncs_items : if ncs_item . user_defined : continue if ncs_item . isEnabled () != state : ncs_item . setEnabled ( state ) ncs_item_by_uuid ncs_item_by_uuid ( ncs_uuid ) Returns an NcsPathway item matching the given UUID. Parameters: Name Type Description Default ncs_uuid str UUID of the NcsPathway item to retrieve. required Returns: Type Description NcsPathwayItem NcsPathwayItem matching the given UUID, else None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 def ncs_item_by_uuid ( self , ncs_uuid : str ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Returns an NcsPathway item matching the given UUID. :param ncs_uuid: UUID of the NcsPathway item to retrieve. :type ncs_uuid: str :returns: NcsPathwayItem matching the given UUID, else None if not found. :rtype: NcsPathwayItem \"\"\" ncs_items = [ n for n in self . _ncs_items if n . uuid == ncs_uuid ] if len ( ncs_items ) == 0 : return None return ncs_items [ 0 ] ncs_item_from_original_pathway ncs_item_from_original_pathway ( ncs_pathway ) Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this implementation model item. Parameters: Name Type Description Default ncs_pathway Union [ NcsPathway , str ] Original NCS pathway data model or unique identifier of the NCS pathway. required Returns: Type Description Union [ NcsPathwayItem , None] The matching NCS pathway item in this implementation model item, else None if there is no matching item. Source code in src/cplus_plugin/gui/component_item_model.py 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def ncs_item_from_original_pathway ( self , ncs_pathway : typing . Union [ NcsPathway , str ] ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this implementation model item. :param ncs_pathway: Original NCS pathway data model or unique identifier of the NCS pathway. :type ncs_pathway: NcsPathway, str :returns: The matching NCS pathway item in this implementation model item, else None if there is no matching item. \"\"\" if isinstance ( ncs_pathway , NcsPathway ): ncs_uuid = str ( ncs_pathway . uuid ) else : ncs_uuid = ncs_pathway if ncs_uuid not in self . _uuid_remap : return None new_uuid = self . _uuid_remap [ ncs_uuid ] return self . ncs_item_by_uuid ( new_uuid ) remove_ncs_pathway_item remove_ncs_pathway_item ( item_uuid ) Removes the NcsPathwayItem matching the given UUID. Parameters: Name Type Description Default item_uuid str The UUID of the NcsPathwayItem to remove. required Returns: Type Description bool True if the item was successfully removed, else False. Source code in src/cplus_plugin/gui/component_item_model.py 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 def remove_ncs_pathway_item ( self , item_uuid : str ) -> bool : \"\"\"Removes the NcsPathwayItem matching the given UUID. :param item_uuid: The UUID of the NcsPathwayItem to remove. :type item_uuid: str :returns: True if the item was successfully removed, else False. :rtype: bool \"\"\" if not self . contains_ncs_item ( item_uuid ): return False idxs = [ i for i , n in enumerate ( self . _ncs_items ) if n . uuid == item_uuid ] if len ( idxs ) == 0 : return False item = self . _ncs_items . pop ( idxs [ 0 ]) item . _parent = None del item self . _implementation_model . remove_ncs_pathway ( item_uuid ) old_uuids = [ k for k , v in self . _uuid_remap . items () if v == item_uuid ] if len ( old_uuids ) > 0 : del self . _uuid_remap [ old_uuids [ 0 ]] return True setEnabled setEnabled ( enabled ) Override for default implementation that also enables or disables NCS pathway items. Source code in src/cplus_plugin/gui/component_item_model.py 614 615 616 617 618 619 620 621 def setEnabled ( self , enabled : bool ): \"\"\"Override for default implementation that also enables or disables NCS pathway items. \"\"\" self . enable_default_pathways ( enabled ) self . _enable_layer_item ( enabled ) self . setSelectable ( enabled ) super () . setEnabled ( enabled ) type type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 547 548 549 550 551 552 553 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return IMPLEMENTATION_MODEL_TYPE LayerComponentItem LayerComponentItem ( model_component ) Bases: ModelComponentItem Base class view item for layer-based component items. Source code in src/cplus_plugin/gui/component_item_model.py 130 131 132 133 def __init__ ( self , model_component : LayerModelComponent ): if not isinstance ( model_component , LayerModelComponent ): raise TypeError ( \"'model_component' not of type LayerModelComponent\" ) super () . __init__ ( model_component ) layer property layer Returns the map layer from the underlying model component object. Returns: Type Description QgsMapLayer Map layer corresponding from the underlying model component. user_defined property user_defined Returns whether the model component is user-defined or default that is shipped together with the plugin. Returns: Type Description bool True if the model component is user-defined else False if its a default component. clone abstractmethod clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 204 205 206 207 208 209 210 211 212 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass create abstractmethod staticmethod create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass is_valid is_valid () Checks whether the map layer of the underlying model component object is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/gui/component_item_model.py 135 136 137 138 139 140 141 142 143 144 145 146 def is_valid ( self ) -> bool : \"\"\"Checks whether the map layer of the underlying model component object is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" if self . _model_component is None : return False return self . _model_component . is_valid () set_layer set_layer ( layer ) Set the map layer for the component item. It sets the :py:attr: ~path attribute of the underlying data model. Parameters: Name Type Description Default layer QgsMapLayer Map layer for the component item. required Returns: Type Description bool Returns True if the layer was successfully set, else False if the layer is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def set_layer ( self , layer : QgsMapLayer ) -> bool : \"\"\"Set the map layer for the component item. It sets the :py:attr:`~path` attribute of the underlying data model. :param layer: Map layer for the component item. :type layer: QgsMapLayer :returns: Returns True if the layer was successfully set, else False if the layer is invalid. :rtype: bool \"\"\" if not layer : return False if not layer . isValid (): return False path = layer . source () self . _model_component . path = path if isinstance ( layer , QgsRasterLayer ): self . _model_component . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . _model_component . layer_type = LayerType . VECTOR return True LayerItem Bases: QStandardItem Contains a custom identifier for an item used to define a layer for an implementation model. type type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 629 630 631 632 633 634 635 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return LAYER_ITEM_TYPE ModelComponentItem ModelComponentItem ( model_component ) Bases: QStandardItem Base standard item for a BaseModelComponent object. Source code in src/cplus_plugin/gui/component_item_model.py 44 45 46 47 48 49 50 def __init__ ( self , model_component : BaseModelComponent ): super () . __init__ ( model_component . name ) self . setToolTip ( model_component . name ) self . _model_component = model_component if self . _model_component is not None : self . update ( self . _model_component ) description property description Returns the description of the item. Returns: Type Description str Description of the item. model_component property model_component Returns an instance of the underlying model component object. Returns: Type Description BaseModelComponent Instance of underlying model component object. uuid property uuid Returns the UUID of the item. Returns: Type Description str UUID string of the item. clone abstractmethod clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 111 112 113 114 115 116 117 118 119 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass create abstractmethod staticmethod create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass update update ( model_component ) Update the component-related properties of the item. Source code in src/cplus_plugin/gui/component_item_model.py 52 53 54 55 56 57 58 59 def update ( self , model_component : BaseModelComponent ): \"\"\"Update the component-related properties of the item.\"\"\" if model_component is None : return self . _model_component = model_component self . setText ( model_component . name ) self . setToolTip ( model_component . name ) NcsPathwayItem NcsPathwayItem ( ncs ) Bases: LayerComponentItem Standard item for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 229 230 231 232 def __init__ ( self , ncs : NcsPathway ): super () . __init__ ( ncs ) self . _ncs_pathway = ncs self . _parent = None ncs_pathway property ncs_pathway Returns an instance of the underlying NcsPathway object. Returns: Type Description NcsPathway The underlying NcsPathway model object. parent property parent Returns the parent ImplementationModelItem if specified. Returns: Type Description ImplementationModelItem Returns the parent item if set when this item is mapped to an ImplementationModelItem. clone clone () Creates a cloned version of this item. Source code in src/cplus_plugin/gui/component_item_model.py 271 272 273 274 275 def clone ( self ) -> \"NcsPathwayItem\" : \"\"\"Creates a cloned version of this item.\"\"\" ncs = clone_ncs_pathway ( self . ncs_pathway ) return NcsPathwayItem ( ncs ) create staticmethod create ( ncs ) Creates an instance of the NcsPathwayItem from the model object. Returns: Type Description NcsPathwayItem An instance of the NcsPathway item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 261 262 263 264 265 266 267 268 269 @staticmethod def create ( ncs : NcsPathway ) -> \"NcsPathwayItem\" : \"\"\"Creates an instance of the NcsPathwayItem from the model object. :returns: An instance of the NcsPathway item to be used in a standard model. :rtype: NcsPathwayItem \"\"\" return NcsPathwayItem ( ncs ) is_carbon_valid is_carbon_valid () Returns the validity of the carbon layers in the underlying NCSPathway model object. Returns: Type Description bool True if the carbon layers are valid, else False. Source code in src/cplus_plugin/gui/component_item_model.py 289 290 291 292 293 294 295 296 297 def is_carbon_valid ( self ) -> bool : \"\"\"Returns the validity of the carbon layers in the underlying NCSPathway model object. :returns: True if the carbon layers are valid, else False. :rtype: bool \"\"\" return self . ncs_pathway . is_carbon_valid () json_data json_data () Creates a mapping of NCS pathway property names and their corresponding values. Returns: Type Description str JSON representation of property name-value pairs for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 277 278 279 280 281 282 283 284 285 286 287 def json_data ( self ) -> str : \"\"\"Creates a mapping of NCS pathway property names and their corresponding values. :returns: JSON representation of property name-value pairs for an NCS pathway object. :rtype: str \"\"\" ncs_attrs = ncs_pathway_to_dict ( self . _ncs_pathway ) return json . dumps ( ncs_attrs ) setEnabled setEnabled ( enabled ) Override for default implementation that also enables or disables selection of the item. Source code in src/cplus_plugin/gui/component_item_model.py 299 300 301 302 303 304 def setEnabled ( self , enabled : bool ): \"\"\"Override for default implementation that also enables or disables selection of the item. \"\"\" self . setSelectable ( enabled ) super () . setEnabled ( enabled ) type type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 253 254 255 256 257 258 259 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return NCS_PATHWAY_TYPE NcsPathwayItemModel Bases: ComponentItemModel View model for NCS pathways. add_ncs_pathway add_ncs_pathway ( ncs ) Add an NCS pathway object to the model. Parameters: Name Type Description Default ncs NcsPathway NCS pathway object to the added to the view. required Returns: Type Description bool True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Add an NCS pathway object to the model. :param ncs: NCS pathway object to the added to the view. :type ncs: NcsPathway :returns: True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. :rtype: bool \"\"\" ncs_item = NcsPathwayItem . create ( ncs ) self . _update_display ( ncs_item ) status = self . add_component_item ( ncs_item ) self . sort ( 0 ) self . _re_index_rows () return status mimeData mimeData ( indexes ) Serializes the NCS items corresponding to the specified indexes. Parameters: Name Type Description Default indexes List [ QModelIndex ] NCS items stored in the specified indexes. required Returns: Type Description QtCore.QMimeData Mime object containing serialized NCS items. Source code in src/cplus_plugin/gui/component_item_model.py 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 def mimeData ( self , indexes : typing . List [ QtCore . QModelIndex ]) -> QtCore . QMimeData : \"\"\"Serializes the NCS items corresponding to the specified indexes. :param indexes: NCS items stored in the specified indexes. :type indexes: list :returns: Mime object containing serialized NCS items. :rtype: QtCore.QMimeData \"\"\" mime_data = QtCore . QMimeData () item_data = QtCore . QByteArray () data_stream = QtCore . QDataStream ( item_data , QtCore . QIODevice . WriteOnly ) for idx in indexes : if not idx . isValid (): continue ncs_item = self . itemFromIndex ( idx ) if ncs_item is None : continue # Do not add disabled items (e.g. disabled default NCS pathway items) if not ncs_item . isEnabled (): continue ncs_data = QtCore . QByteArray () ncs_data . append ( ncs_item . json_data ()) data_stream << ncs_data mime_data . setData ( NCS_MIME_TYPE , item_data ) return mime_data mimeTypes mimeTypes () Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. Returns: Type Description list MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. Source code in src/cplus_plugin/gui/component_item_model.py 921 922 923 924 925 926 927 928 929 930 def mimeTypes ( self ) -> typing . List [ str ]: \"\"\"Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. :returns: MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. :rtype: list \"\"\" return [ NCS_MIME_TYPE ] pathways pathways ( valid_only = False ) Returns NCS pathway objects in the model. Parameters: Name Type Description Default valid_only bool Whether to only return NCS pathway objects that are valid. False Returns: Type Description list All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. Source code in src/cplus_plugin/gui/component_item_model.py 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 def pathways ( self , valid_only : bool = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns NCS pathway objects in the model. :param valid_only: Whether to only return NCS pathway objects that are valid. :type valid_only: bool :returns: All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. :rtype: list \"\"\" ncs_pathways = self . model_components () if valid_only : return [ p for p in ncs_pathways if p . is_valid ()] return ncs_pathways remove_ncs_pathway remove_ncs_pathway ( ncs_uuid ) Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. Returns: Type Description bool True if the NCS pathway item as successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 899 900 901 902 903 904 905 906 907 908 909 def remove_ncs_pathway ( self , ncs_uuid : str ) -> bool : \"\"\"Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :returns: True if the NCS pathway item as successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" return self . remove_component_item ( ncs_uuid ) supportedDropActions supportedDropActions () Configure the model to only support copying items in a drag-and-drop operation. Returns: Type Description QtCore.Qt.DropActions Supported drag-and-drop action for NCS pathway items. Source code in src/cplus_plugin/gui/component_item_model.py 911 912 913 914 915 916 917 918 919 def supportedDropActions ( self ) -> QtCore . Qt . DropActions : \"\"\"Configure the model to only support copying items in a drag-and-drop operation. :returns: Supported drag-and-drop action for NCS pathway items. :rtype: QtCore.Qt.DropActions \"\"\" return QtCore . Qt . CopyAction update_ncs_pathway update_ncs_pathway ( ncs ) Updates the NCS pathway item in the model. Parameters: Name Type Description Default ncs NcsPathway NcsPathway whose corresponding item is to be updated. required Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 def update_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Updates the NCS pathway item in the model. :param ncs: NcsPathway whose corresponding item is to be updated. :type ncs: NcsPathway :returns: Returns True if the operation was successful else False if the matching item was not found in the model. \"\"\" item = self . component_item_by_uuid ( str ( ncs . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False self . _update_display ( item ) self . sort ( 0 ) self . _re_index_rows () return True","title":"Component item model"},{"location":"developer/api/gui/api_component_items/#component-item-model","text":"Contains item models for view widgets such as NCS pathway or IM views.","title":"Component item model"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel","text":"ComponentItemModel ( parent = None ) Bases: QStandardItemModel View model for ModelComponent objects. Source code in src/cplus_plugin/gui/component_item_model.py 641 642 643 644 645 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) self . _uuid_row_idx = {}","title":"ComponentItemModel"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.add_component_item","text":"add_component_item ( component_item , position =- 1 ) Adds a model component item to the view model. Parameters: Name Type Description Default component_item ModelComponentItem Model component item to be added to the view model. required position int Reference row to insert the item. -1 Returns: Type Description bool True if the component item was successfully added, else False if there is an existing component item with the same UUID. Source code in src/cplus_plugin/gui/component_item_model.py 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 def add_component_item ( self , component_item : ModelComponentItem , position =- 1 ) -> bool : \"\"\"Adds a model component item to the view model. :param component_item: Model component item to be added to the view model. :type component_item: ModelComponentItem :param position: Reference row to insert the item. :type position: int :returns: True if the component item was successfully added, else False if there is an existing component item with the same UUID. :rtype: bool \"\"\" idx = position if position == - 1 : idx = self . rowCount () if self . contains_item ( str ( component_item . uuid )): return False self . insertRow ( idx , component_item ) self . _re_index_rows () return True","title":"add_component_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.component_item_by_uuid","text":"component_item_by_uuid ( uuid_str ) Retrieves a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description ModelComponentItem Component item matching the given UUID or None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 def component_item_by_uuid ( self , uuid_str : str ) -> typing . Union [ ModelComponentItemType , None ]: \"\"\"Retrieves a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: Component item matching the given UUID or None if not found. :rtype: ModelComponentItem \"\"\" if uuid_str not in self . _uuid_row_idx : return None row = self . _uuid_row_idx [ uuid_str ] return self . item ( row )","title":"component_item_by_uuid()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.contains_item","text":"contains_item ( item_uuid ) Checks if the model contains an item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the model item. required Returns: Type Description bool True if there is an existing item else False. Source code in src/cplus_plugin/gui/component_item_model.py 676 677 678 679 680 681 682 683 684 685 def contains_item ( self , item_uuid : str ) -> bool : \"\"\"Checks if the model contains an item with the given UUID. :param item_uuid: UUID of the model item. :type item_uuid: str :returns: True if there is an existing item else False. :rtype: bool \"\"\" return True if self . component_item_by_uuid ( item_uuid ) is not None else False","title":"contains_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.enable_default_items","text":"enable_default_items ( state ) Enable or disable items for default model components. Parameters: Name Type Description Default state bool True to enable or False to disable. required Source code in src/cplus_plugin/gui/component_item_model.py 800 801 802 803 804 805 806 807 808 809 810 811 def enable_default_items ( self , state : bool ): \"\"\"Enable or disable items for default model components. :param state: True to enable or False to disable. :type state: bool \"\"\" for item in self . model_component_items (): if not isinstance ( item , LayerComponentItem ): continue if not item . user_defined : item . setEnabled ( state )","title":"enable_default_items()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.index_by_uuid","text":"index_by_uuid ( uuid_str ) Get the QModelIndex object for the component item matching the given UUID identifier. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description QtCore.QModelIndex QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. Source code in src/cplus_plugin/gui/component_item_model.py 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 def index_by_uuid ( self , uuid_str ) -> QtCore . QModelIndex : \"\"\"Get the QModelIndex object for the component item matching the given UUID identifier. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. :rtype: QtCore.QModelIndex \"\"\" if uuid_str not in self . _uuid_row_idx : return QtCore . QModelIndex () row = self . _uuid_row_idx [ uuid_str ] return self . index ( row , 0 )","title":"index_by_uuid()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.model_component_items","text":"model_component_items () Returns model component items in the model. Returns: Type Description list Model component items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 748 749 750 751 752 753 754 755 756 757 758 759 760 761 def model_component_items ( self ) -> typing . List [ ModelComponentItem ]: \"\"\"Returns model component items in the model. :returns: Model component items in the model. :rtype: list \"\"\" rows = self . rowCount () items = [] for r in range ( rows ): item = self . item ( r ) items . append ( item ) return items","title":"model_component_items()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.model_components","text":"model_components () Returns a collection of model component objects in the model. Returns: Type Description list A collection of all model component objects. Source code in src/cplus_plugin/gui/component_item_model.py 740 741 742 743 744 745 746 def model_components ( self ) -> typing . List [ BaseModelComponentType ]: \"\"\"Returns a collection of model component objects in the model. :returns: A collection of all model component objects. :rtype: list \"\"\" return [ item . model_component for item in self . model_component_items ()]","title":"model_components()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.remove_component_item","text":"remove_component_item ( uuid_str ) Removes a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item to be removed. required Returns: Type Description bool True if the component item was successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 def remove_component_item ( self , uuid_str : str ) -> bool : \"\"\"Removes a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item to be removed. :type uuid_str: str :returns: True if the component item was successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" if not self . contains_item ( uuid_str ): return False if uuid_str not in self . _uuid_row_idx : return False self . removeRows ( self . _uuid_row_idx [ uuid_str ], 1 ) del self . _uuid_row_idx [ uuid_str ] self . _re_index_rows () return True","title":"remove_component_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.update_item","text":"update_item ( item ) Update an existing ModelComponentItem if it exists in the model. Parameters: Name Type Description Default item ModelComponentItemType An updated instance of the ModelComponentItem. required Returns: Type Description bool True if the item was successfully updated, else False if there was no matching item found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 def update_item ( self , item : ModelComponentItemType ) -> bool : \"\"\"Update an existing ModelComponentItem if it exists in the model. :param item: An updated instance of the ModelComponentItem. :type item: ModelComponentItem :returns: True if the item was successfully updated, else False if there was no matching item found in the model. :rtype: bool \"\"\" if not self . contains_item ( item . uuid ): return False item . update ( item . model_component ) return True","title":"update_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel","text":"Bases: ComponentItemModel View model for implementation model.","title":"IMItemModel"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.add_implementation_model","text":"add_implementation_model ( implementation_model , layer = None ) Add an ImplementationModel object to the model. Parameters: Name Type Description Default implementation_model ImplementationModel ImplementationModel object to be added to the view. required layer QgsMapLayer Map layer for the implementation model. None Returns: Type Description bool True if ImplementationModel object was added successfully, else False. Source code in src/cplus_plugin/gui/component_item_model.py 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 def add_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ) -> bool : \"\"\"Add an ImplementationModel object to the model. :param implementation_model: ImplementationModel object to be added to the view. :type implementation_model: ImplementationModel :param layer: Map layer for the implementation model. :type layer: QgsMapLayer :returns: True if ImplementationModel object was added successfully, else False. :rtype: bool \"\"\" # Check if we can retrieve the layer from the path if layer is None : if implementation_model . path : layer = implementation_model . to_map_layer () implementation_model_item = ImplementationModelItem . create ( implementation_model ) result = self . add_component_item ( implementation_model_item ) if layer : status = self . set_model_layer ( implementation_model_item , layer ) if not status : result = False else : # Add NCS pathways. If there are underlying NCS pathway objects then # clone them, remove then re-insert so that the underlying NCS pathways can # have the unique UUID in the IM item. if result : cloned_implementation_model = clone_implementation_model ( implementation_model ) cloned_ncs_pathways = cloned_implementation_model . pathways # Remove pathways in the IM implementation_model . pathways = [] # Now add the NCSs afresh for ncs in cloned_ncs_pathways : ncs_item = NcsPathwayItem . create ( ncs ) self . add_ncs_pathway ( ncs_item , implementation_model_item ) return result","title":"add_implementation_model()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.add_ncs_pathway","text":"add_ncs_pathway ( ncs_item , target_model_item ) Adds an NCS pathway item to the model. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required target_model_item ImplementationModelItem Target implementation model for the NCS item. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the implementation model. Source code in src/cplus_plugin/gui/component_item_model.py 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 def add_ncs_pathway ( self , ncs_item : NcsPathwayItem , target_model_item : ImplementationModelItem ) -> bool : \"\"\"Adds an NCS pathway item to the model. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :param target_model_item: Target implementation model for the NCS item. :type target_model_item: ImplementationModelItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the implementation model. \"\"\" idx = target_model_item . index () if not idx . isValid (): return False if not isinstance ( target_model_item , LayerComponentItem ): return False # Do not add if the IM item has been disabled (e.g. disabled default IMs) if not target_model_item . isEnabled (): return False # If there is an existing layer then return if target_model_item . layer : return False clone_ncs_item = ncs_item . clone () status = target_model_item . add_ncs_pathway_item ( clone_ncs_item ) if not status : return False bottom_idx = target_model_item . bottom_ncs_item_index () reference_row = max ( bottom_idx . row (), idx . row ()) self . add_component_item ( clone_ncs_item , reference_row + 1 ) self . im_pathways_updated . emit ( target_model_item ) return True","title":"add_ncs_pathway()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.dropMimeData","text":"dropMimeData ( data , action , row , column , parent ) Implements behaviour for handling data supplied by drag and drop operation. Parameters: Name Type Description Default data QMimeData Object containing data from the drag operation. required action DropAction Type of the drag and drop operation. required row int Row location of dropped data. required column int Column location of dropped data. required parent QModelIndex Index location for target item where the operation ended. required Returns: Type Description bool True if the data and action can be handled by the model, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 def dropMimeData ( self , data : QtCore . QMimeData , action : QtCore . Qt . DropAction , row : int , column : int , parent : QtCore . QModelIndex , ) -> bool : \"\"\"Implements behaviour for handling data supplied by drag and drop operation. :param data: Object containing data from the drag operation. :type data: QtCore.QMimeData :param action: Type of the drag and drop operation. :type action: QtCore.Qt.DropAction :param row: Row location of dropped data. :type row: int :param column: Column location of dropped data. :type column: int :param parent: Index location for target item where the operation ended. :type parent: QtCore.QModelIndex :returns: True if the data and action can be handled by the model, else False. :rtype: bool \"\"\" if action == QtCore . Qt . IgnoreAction : return True if not data . hasFormat ( NCS_MIME_TYPE ): return False encoded_data = data . data ( NCS_MIME_TYPE ) data_stream = QtCore . QDataStream ( encoded_data , QtCore . QIODevice . ReadOnly ) ncs_items = [] while not data_stream . atEnd (): byte_data = QtCore . QByteArray () data_stream >> byte_data item_data = json . loads ( byte_data . data ()) ncs_pathway = create_ncs_pathway ( item_data ) ncs_item = NcsPathwayItem ( ncs_pathway ) ncs_items . append ( ncs_item ) # Get reference ImplementationModel item if parent . isValid (): model_item = self . itemFromIndex ( parent ) else : row_count = self . rowCount () model_item = self . item ( row_count - 1 ) if model_item is None or isinstance ( model_item , LayerItem ): return False if model_item . type () == NCS_PATHWAY_TYPE : target_im_item = model_item . parent else : target_im_item = model_item # Add NCS items to model. status = True for item in ncs_items : status = self . add_ncs_pathway ( item , target_im_item ) return status","title":"dropMimeData()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.model_items","text":"model_items () Returns all ImplementationModelItem objects in the model. Returns: Type Description list Implementation model items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1201 1202 1203 1204 1205 1206 1207 1208 1209 def model_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns all ImplementationModelItem objects in the model. :returns: Implementation model items in the model. :rtype: list \"\"\" component_items = self . model_component_items () return [ ci for ci in component_items if ci . type () == IMPLEMENTATION_MODEL_TYPE ]","title":"model_items()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.models","text":"models () Returns implementation model objects in the model. Returns: Type Description list Implementation model objects in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1193 1194 1195 1196 1197 1198 1199 def models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns implementation model objects in the model. :returns: Implementation model objects in the model. :rtype: list \"\"\" return [ model_item . implementation_model for model_item in self . model_items ()]","title":"models()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.remove_implementation_model","text":"remove_implementation_model ( uuid_str ) Remove an implementation model item from the model. param uuid: UUID of the implementation model item to be removed. Returns: Type Description bool True if the implementation model item as successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 def remove_implementation_model ( self , uuid_str : str ) -> bool : \"\"\"Remove an implementation model item from the model. param uuid: UUID of the implementation model item to be removed. :type uuid_str: str :returns: True if the implementation model item as successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" implementation_model_item = self . component_item_by_uuid ( uuid_str ) if implementation_model_item is None : return False if len ( implementation_model_item . ncs_items ) > 0 : ncs_items = implementation_model_item . ncs_items for item in ncs_items : self . remove_component_item ( item . uuid ) else : # Layer item self . remove_layer ( implementation_model_item ) return self . remove_component_item ( uuid_str )","title":"remove_implementation_model()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.remove_layer","text":"remove_layer ( implementation_model_item ) Removes the layer reference from the underlying implementation model. Parameters: Name Type Description Default implementation_model_item ImplementationModelItem Implementation model item whose layer is to be removed. required Source code in src/cplus_plugin/gui/component_item_model.py 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 def remove_layer ( self , implementation_model_item : ImplementationModelItem ): \"\"\"Removes the layer reference from the underlying implementation model. :param implementation_model_item: Implementation model item whose layer is to be removed. :type implementation_model_item: ImplementationModelItem \"\"\" if implementation_model_item . layer is None : return if not self . contains_item ( implementation_model_item . uuid ): return # Remove item in model item_idx = self . index_by_uuid ( implementation_model_item . uuid ) layer_row = item_idx . row () + 1 self . removeRows ( layer_row , 1 ) self . _re_index_rows () # Remove underlying layer reference implementation_model_item . clear_layer ()","title":"remove_layer()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.remove_ncs_pathway_item","text":"remove_ncs_pathway_item ( ncs_uuid , parent ) Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. Parameters: Name Type Description Default parent ImplementationModelItem Reference implementation model item that is the parent to the NCS pathway item. required Returns: Type Description bool True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 def remove_ncs_pathway_item ( self , ncs_uuid : str , parent : ImplementationModelItem ) -> bool : \"\"\"Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :param parent: Reference implementation model item that is the parent to the NCS pathway item. :type parent: ImplementationModelItem :returns: True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. :rtype: bool \"\"\" status = parent . remove_ncs_pathway_item ( ncs_uuid ) if not status : return False self . im_pathways_updated . emit ( parent ) return self . remove_component_item ( ncs_uuid )","title":"remove_ncs_pathway_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.remove_ncs_pathway_items","text":"remove_ncs_pathway_items ( ncs_pathway_uuid ) Delete NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be deleted. Parameters: Name Type Description Default ncs_pathway_uuid str Unique identifier of the NCS pathway object whose corresponding models are to be removed in the implementation models. required Source code in src/cplus_plugin/gui/component_item_model.py 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 def remove_ncs_pathway_items ( self , ncs_pathway_uuid : str ): \"\"\"Delete NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be deleted. :param ncs_pathway_uuid: Unique identifier of the NCS pathway object whose corresponding models are to be removed in the implementation models. :type ncs_pathway_uuid: str \"\"\" for im_item in self . model_items (): ncs_item_for_original = im_item . ncs_item_from_original_pathway ( ncs_pathway_uuid ) if ncs_item_for_original is None : continue status = self . remove_ncs_pathway_item ( ncs_item_for_original . uuid , im_item )","title":"remove_ncs_pathway_items()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.set_model_layer","text":"set_model_layer ( implementation_model_item , layer , display_name = '' ) Set the layer for the given implementation model item. Parameters: Name Type Description Default implementation_model_item ImplementationModelItem Implementation model item whose layer is to be specified. required layer QgsMapLayer Map layer to be set for the implementation model. required display_name str Display name for the layer node. If not specified then the name from the map layer is used. '' Returns: Type Description bool True if the layer was successfully set for the implementation model, else False if the layer is invalid, if there are already existing NCS pathways in the implementation model or if the item is not in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 def set_model_layer ( self , implementation_model_item : ImplementationModelItem , layer : QgsMapLayer , display_name : str = \"\" , ) -> bool : \"\"\"Set the layer for the given implementation model item. :param implementation_model_item: Implementation model item whose layer is to be specified. :type implementation_model_item: ImplementationModelItem :param layer: Map layer to be set for the implementation model. :type layer: QgsMapLayer :param display_name: Display name for the layer node. If not specified then the name from the map layer is used. :type display_name: str :returns: True if the layer was successfully set for the implementation model, else False if the layer is invalid, if there are already existing NCS pathways in the implementation model or if the item is not in the model. :rtype: bool \"\"\" if len ( implementation_model_item . ncs_items ) > 0 : return False if not self . contains_item ( implementation_model_item . uuid ): return False if not implementation_model_item . set_layer ( layer ): return False if not display_name : display_name = layer . name () icon = FileUtils . get_icon ( \"mIconRaster.svg\" ) item = LayerItem ( icon , display_name ) item . setToolTip ( layer . source ()) item . setData ( implementation_model_item ) item_idx = self . index_by_uuid ( implementation_model_item . uuid ) layer_row = item_idx . row () + 1 self . insertRow ( layer_row , item ) self . _re_index_rows () return True","title":"set_model_layer()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.update_implementation_model","text":"update_implementation_model ( implementation_model , layer = None ) Updates the implementation model item in the model. Parameters: Name Type Description Default implementation_model ImplementationModel implementation_model object whose corresponding item is to be updated. required layer QgsMapLayer Map layer to be updated for the implementation if specified. None Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 def update_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ) -> bool : \"\"\"Updates the implementation model item in the model. :param implementation_model: implementation_model object whose corresponding item is to be updated. :type implementation_model: ImplementationModel :param layer: Map layer to be updated for the implementation if specified. :type layer: QgsMapLayer :returns: Returns True if the operation was successful else False if the matching item was not found in the model. \"\"\" item = self . component_item_by_uuid ( str ( implementation_model . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False # Update layer information self . remove_layer ( item ) if layer : layer_status = self . set_model_layer ( item , layer ) if not layer_status : return False return True","title":"update_implementation_model()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.update_ncs_pathway_items","text":"update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be updated. Parameters: Name Type Description Default ncs_pathway NcsPathway Original NCS pathway object whose corresponding models are to be updated. required Returns: Type Description bool True if matching NCS pathway items have been updated, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be updated. :param ncs_pathway: Original NCS pathway object whose corresponding models are to be updated. :type ncs_pathway: NcsPathway :returns: True if matching NCS pathway items have been updated, else False. :rtype: bool \"\"\" if not ncs_pathway . is_valid (): return False for im_item in self . model_items (): ncs_item_for_original = im_item . ncs_item_from_original_pathway ( ncs_pathway ) if ncs_item_for_original is None : continue item_pathway = ncs_item_for_original . ncs_pathway # Copy attribute values excluding the UUID copy_layer_component_attributes ( item_pathway , ncs_pathway ) ncs_item_for_original . update ( item_pathway ) return True","title":"update_ncs_pathway_items()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem","text":"ImplementationModelItem ( implementation_model ) Bases: LayerComponentItem Standard item for an implementation model object. Source code in src/cplus_plugin/gui/component_item_model.py 310 311 312 313 314 315 316 317 318 319 320 321 322 def __init__ ( self , implementation_model : ImplementationModel ): super () . __init__ ( implementation_model ) self . _implementation_model = implementation_model font = self . font () font . setBold ( True ) self . setFont ( font ) self . _ncs_items = [] # Remap pathway uuids so that there are no duplicate # pathways under each implementation model. self . _uuid_remap = {}","title":"ImplementationModelItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.implementation_model","text":"implementation_model Returns an instance of the underlying ImplementationModel object. Returns: Type Description ImplementationModel The underlying ImplementationModel object.","title":"implementation_model"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.layer_item","text":"layer_item Returns the view item for the layer. Returns: Type Description QtGui.QStandardItem Returns the view item for the map layer else None if no layer has been specified for the model.","title":"layer_item"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.ncs_items","text":"ncs_items Returns a collection of NcsPathwayItem in this implementation model. Returns: Type Description list Collection of NcsPathwayItem objects in this implementation model.","title":"ncs_items"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.ncs_pathways","text":"ncs_pathways Returns a collection of NcsPathway objects. Returns: Type Description list Collection of NcsPathway objects linked to the underlying ImplementationModel object.","title":"ncs_pathways"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.original_ncs_pathways","text":"original_ncs_pathways Returns a collection of NcsPathway objects but with their original UUIDs. These are used for persisting the NCsPathway objects related to the underlying IM object. Returns: Type Description list Collection of NcsPathway objects with their original UUIDs linked to the underlying ImplementationModel object.","title":"original_ncs_pathways"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.add_ncs_pathway_item","text":"add_ncs_pathway_item ( ncs_item ) Adds an NCS pathway item to this implementation model item. If the item already contains a layer, then the add operation will not be successful. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. Source code in src/cplus_plugin/gui/component_item_model.py 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 def add_ncs_pathway_item ( self , ncs_item : NcsPathwayItem ) -> bool : \"\"\"Adds an NCS pathway item to this implementation model item. If the item already contains a layer, then the add operation will not be successful. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. \"\"\" if self . layer : return False old_uuid = ncs_item . uuid new_uuid = uuid4 () ncs_item . ncs_pathway . uuid = new_uuid if old_uuid in self . _uuid_remap : return False if self . contains_ncs_item ( ncs_item . uuid ): return False if not ncs_item . is_valid (): return False if self . _implementation_model . contains_pathway ( ncs_item . uuid ): return False if not self . _implementation_model . add_ncs_pathway ( ncs_item . ncs_pathway ): return False self . _ncs_items . append ( ncs_item ) ncs_item . _parent = self self . _uuid_remap [ old_uuid ] = str ( new_uuid ) return True","title":"add_ncs_pathway_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.bottom_ncs_item_index","text":"bottom_ncs_item_index () Returns the model index of the bottom-most NcsPathwayItem under this implementation model item. Returns: Type Description QModelIndex Model index of the bottom-most NcsPathwayItem. Source code in src/cplus_plugin/gui/component_item_model.py 533 534 535 536 537 538 539 540 541 542 543 544 545 def bottom_ncs_item_index ( self ) -> typing . Union [ QtCore . QModelIndex , None ]: \"\"\"Returns the model index of the bottom-most NcsPathwayItem under this implementation model item. :returns: Model index of the bottom-most NcsPathwayItem. :rtype: QModelIndex \"\"\" if len ( self . _ncs_items ) == 0 : return None bottom_ncs_item = max ( self . _ncs_items , key = lambda n : n . index () . row ()) return bottom_ncs_item . index ()","title":"bottom_ncs_item_index()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.clear_layer","text":"clear_layer () Clears the layer reference in the model component. Source code in src/cplus_plugin/gui/component_item_model.py 423 424 425 def clear_layer ( self ): \"\"\"Clears the layer reference in the model component.\"\"\" self . _implementation_model . clear_layer ()","title":"clear_layer()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.clone","text":"clone () Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the IM will not change. Source code in src/cplus_plugin/gui/component_item_model.py 566 567 568 569 570 571 572 573 574 575 576 577 578 def clone ( self ) -> \"ImplementationModelItem\" : \"\"\"Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the IM will not change. \"\"\" implementation_model = clone_implementation_model ( self . implementation_model , ) # Use NCS pathways with original UUIDs implementation_model . pathways = self . original_ncs_pathways return ImplementationModelItem ( implementation_model )","title":"clone()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.contains_ncs_item","text":"contains_ncs_item ( item_uuid ) Checks whether this item contains an NcsPathway item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the NcsPathway item to search for. required Returns: Type Description bool True if there is an NcsPathwayItem matching the given UUID, else False. Source code in src/cplus_plugin/gui/component_item_model.py 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 def contains_ncs_item ( self , item_uuid : str ) -> bool : \"\"\"Checks whether this item contains an NcsPathway item with the given UUID. :param item_uuid: UUID of the NcsPathway item to search for. :type item_uuid: str :returns: True if there is an NcsPathwayItem matching the given UUID, else False. :rtype: bool \"\"\" if self . ncs_item_by_uuid ( item_uuid ) is None : return False return True","title":"contains_ncs_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.create","text":"create ( implementation_model ) Creates an instance of the ImplementationModelItem from the model object. Returns: Type Description ImplementationModel An instance of the ImplementationModelItem item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 555 556 557 558 559 560 561 562 563 564 @staticmethod def create ( implementation_model : ImplementationModel ) -> \"ImplementationModelItem\" : \"\"\"Creates an instance of the ImplementationModelItem from the model object. :returns: An instance of the ImplementationModelItem item to be used in a standard model. :rtype: ImplementationModel \"\"\" return ImplementationModelItem ( implementation_model )","title":"create()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.enable_default_pathways","text":"enable_default_pathways ( state ) Enable or disable default NCS pathway items. Parameters: Name Type Description Default state bool True to enable default NCS pathways else False to disable them. required Source code in src/cplus_plugin/gui/component_item_model.py 580 581 582 583 584 585 586 587 588 589 590 591 592 def enable_default_pathways ( self , state : bool ): \"\"\"Enable or disable default NCS pathway items. :param state: True to enable default NCS pathways else False to disable them. :type state: bool \"\"\" for ncs_item in self . _ncs_items : if ncs_item . user_defined : continue if ncs_item . isEnabled () != state : ncs_item . setEnabled ( state )","title":"enable_default_pathways()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.ncs_item_by_uuid","text":"ncs_item_by_uuid ( ncs_uuid ) Returns an NcsPathway item matching the given UUID. Parameters: Name Type Description Default ncs_uuid str UUID of the NcsPathway item to retrieve. required Returns: Type Description NcsPathwayItem NcsPathwayItem matching the given UUID, else None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 def ncs_item_by_uuid ( self , ncs_uuid : str ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Returns an NcsPathway item matching the given UUID. :param ncs_uuid: UUID of the NcsPathway item to retrieve. :type ncs_uuid: str :returns: NcsPathwayItem matching the given UUID, else None if not found. :rtype: NcsPathwayItem \"\"\" ncs_items = [ n for n in self . _ncs_items if n . uuid == ncs_uuid ] if len ( ncs_items ) == 0 : return None return ncs_items [ 0 ]","title":"ncs_item_by_uuid()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.ncs_item_from_original_pathway","text":"ncs_item_from_original_pathway ( ncs_pathway ) Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this implementation model item. Parameters: Name Type Description Default ncs_pathway Union [ NcsPathway , str ] Original NCS pathway data model or unique identifier of the NCS pathway. required Returns: Type Description Union [ NcsPathwayItem , None] The matching NCS pathway item in this implementation model item, else None if there is no matching item. Source code in src/cplus_plugin/gui/component_item_model.py 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def ncs_item_from_original_pathway ( self , ncs_pathway : typing . Union [ NcsPathway , str ] ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this implementation model item. :param ncs_pathway: Original NCS pathway data model or unique identifier of the NCS pathway. :type ncs_pathway: NcsPathway, str :returns: The matching NCS pathway item in this implementation model item, else None if there is no matching item. \"\"\" if isinstance ( ncs_pathway , NcsPathway ): ncs_uuid = str ( ncs_pathway . uuid ) else : ncs_uuid = ncs_pathway if ncs_uuid not in self . _uuid_remap : return None new_uuid = self . _uuid_remap [ ncs_uuid ] return self . ncs_item_by_uuid ( new_uuid )","title":"ncs_item_from_original_pathway()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.remove_ncs_pathway_item","text":"remove_ncs_pathway_item ( item_uuid ) Removes the NcsPathwayItem matching the given UUID. Parameters: Name Type Description Default item_uuid str The UUID of the NcsPathwayItem to remove. required Returns: Type Description bool True if the item was successfully removed, else False. Source code in src/cplus_plugin/gui/component_item_model.py 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 def remove_ncs_pathway_item ( self , item_uuid : str ) -> bool : \"\"\"Removes the NcsPathwayItem matching the given UUID. :param item_uuid: The UUID of the NcsPathwayItem to remove. :type item_uuid: str :returns: True if the item was successfully removed, else False. :rtype: bool \"\"\" if not self . contains_ncs_item ( item_uuid ): return False idxs = [ i for i , n in enumerate ( self . _ncs_items ) if n . uuid == item_uuid ] if len ( idxs ) == 0 : return False item = self . _ncs_items . pop ( idxs [ 0 ]) item . _parent = None del item self . _implementation_model . remove_ncs_pathway ( item_uuid ) old_uuids = [ k for k , v in self . _uuid_remap . items () if v == item_uuid ] if len ( old_uuids ) > 0 : del self . _uuid_remap [ old_uuids [ 0 ]] return True","title":"remove_ncs_pathway_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.setEnabled","text":"setEnabled ( enabled ) Override for default implementation that also enables or disables NCS pathway items. Source code in src/cplus_plugin/gui/component_item_model.py 614 615 616 617 618 619 620 621 def setEnabled ( self , enabled : bool ): \"\"\"Override for default implementation that also enables or disables NCS pathway items. \"\"\" self . enable_default_pathways ( enabled ) self . _enable_layer_item ( enabled ) self . setSelectable ( enabled ) super () . setEnabled ( enabled )","title":"setEnabled()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 547 548 549 550 551 552 553 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return IMPLEMENTATION_MODEL_TYPE","title":"type()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem","text":"LayerComponentItem ( model_component ) Bases: ModelComponentItem Base class view item for layer-based component items. Source code in src/cplus_plugin/gui/component_item_model.py 130 131 132 133 def __init__ ( self , model_component : LayerModelComponent ): if not isinstance ( model_component , LayerModelComponent ): raise TypeError ( \"'model_component' not of type LayerModelComponent\" ) super () . __init__ ( model_component )","title":"LayerComponentItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.layer","text":"layer Returns the map layer from the underlying model component object. Returns: Type Description QgsMapLayer Map layer corresponding from the underlying model component.","title":"layer"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.user_defined","text":"user_defined Returns whether the model component is user-defined or default that is shipped together with the plugin. Returns: Type Description bool True if the model component is user-defined else False if its a default component.","title":"user_defined"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.clone","text":"clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 204 205 206 207 208 209 210 211 212 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass","title":"clone()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.create","text":"create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass","title":"create()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.is_valid","text":"is_valid () Checks whether the map layer of the underlying model component object is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/gui/component_item_model.py 135 136 137 138 139 140 141 142 143 144 145 146 def is_valid ( self ) -> bool : \"\"\"Checks whether the map layer of the underlying model component object is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" if self . _model_component is None : return False return self . _model_component . is_valid ()","title":"is_valid()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.set_layer","text":"set_layer ( layer ) Set the map layer for the component item. It sets the :py:attr: ~path attribute of the underlying data model. Parameters: Name Type Description Default layer QgsMapLayer Map layer for the component item. required Returns: Type Description bool Returns True if the layer was successfully set, else False if the layer is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def set_layer ( self , layer : QgsMapLayer ) -> bool : \"\"\"Set the map layer for the component item. It sets the :py:attr:`~path` attribute of the underlying data model. :param layer: Map layer for the component item. :type layer: QgsMapLayer :returns: Returns True if the layer was successfully set, else False if the layer is invalid. :rtype: bool \"\"\" if not layer : return False if not layer . isValid (): return False path = layer . source () self . _model_component . path = path if isinstance ( layer , QgsRasterLayer ): self . _model_component . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . _model_component . layer_type = LayerType . VECTOR return True","title":"set_layer()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerItem","text":"Bases: QStandardItem Contains a custom identifier for an item used to define a layer for an implementation model.","title":"LayerItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 629 630 631 632 633 634 635 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return LAYER_ITEM_TYPE","title":"type()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem","text":"ModelComponentItem ( model_component ) Bases: QStandardItem Base standard item for a BaseModelComponent object. Source code in src/cplus_plugin/gui/component_item_model.py 44 45 46 47 48 49 50 def __init__ ( self , model_component : BaseModelComponent ): super () . __init__ ( model_component . name ) self . setToolTip ( model_component . name ) self . _model_component = model_component if self . _model_component is not None : self . update ( self . _model_component )","title":"ModelComponentItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.description","text":"description Returns the description of the item. Returns: Type Description str Description of the item.","title":"description"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.model_component","text":"model_component Returns an instance of the underlying model component object. Returns: Type Description BaseModelComponent Instance of underlying model component object.","title":"model_component"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.uuid","text":"uuid Returns the UUID of the item. Returns: Type Description str UUID string of the item.","title":"uuid"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.clone","text":"clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 111 112 113 114 115 116 117 118 119 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass","title":"clone()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.create","text":"create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass","title":"create()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.update","text":"update ( model_component ) Update the component-related properties of the item. Source code in src/cplus_plugin/gui/component_item_model.py 52 53 54 55 56 57 58 59 def update ( self , model_component : BaseModelComponent ): \"\"\"Update the component-related properties of the item.\"\"\" if model_component is None : return self . _model_component = model_component self . setText ( model_component . name ) self . setToolTip ( model_component . name )","title":"update()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem","text":"NcsPathwayItem ( ncs ) Bases: LayerComponentItem Standard item for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 229 230 231 232 def __init__ ( self , ncs : NcsPathway ): super () . __init__ ( ncs ) self . _ncs_pathway = ncs self . _parent = None","title":"NcsPathwayItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.ncs_pathway","text":"ncs_pathway Returns an instance of the underlying NcsPathway object. Returns: Type Description NcsPathway The underlying NcsPathway model object.","title":"ncs_pathway"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.parent","text":"parent Returns the parent ImplementationModelItem if specified. Returns: Type Description ImplementationModelItem Returns the parent item if set when this item is mapped to an ImplementationModelItem.","title":"parent"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.clone","text":"clone () Creates a cloned version of this item. Source code in src/cplus_plugin/gui/component_item_model.py 271 272 273 274 275 def clone ( self ) -> \"NcsPathwayItem\" : \"\"\"Creates a cloned version of this item.\"\"\" ncs = clone_ncs_pathway ( self . ncs_pathway ) return NcsPathwayItem ( ncs )","title":"clone()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.create","text":"create ( ncs ) Creates an instance of the NcsPathwayItem from the model object. Returns: Type Description NcsPathwayItem An instance of the NcsPathway item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 261 262 263 264 265 266 267 268 269 @staticmethod def create ( ncs : NcsPathway ) -> \"NcsPathwayItem\" : \"\"\"Creates an instance of the NcsPathwayItem from the model object. :returns: An instance of the NcsPathway item to be used in a standard model. :rtype: NcsPathwayItem \"\"\" return NcsPathwayItem ( ncs )","title":"create()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.is_carbon_valid","text":"is_carbon_valid () Returns the validity of the carbon layers in the underlying NCSPathway model object. Returns: Type Description bool True if the carbon layers are valid, else False. Source code in src/cplus_plugin/gui/component_item_model.py 289 290 291 292 293 294 295 296 297 def is_carbon_valid ( self ) -> bool : \"\"\"Returns the validity of the carbon layers in the underlying NCSPathway model object. :returns: True if the carbon layers are valid, else False. :rtype: bool \"\"\" return self . ncs_pathway . is_carbon_valid ()","title":"is_carbon_valid()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.json_data","text":"json_data () Creates a mapping of NCS pathway property names and their corresponding values. Returns: Type Description str JSON representation of property name-value pairs for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 277 278 279 280 281 282 283 284 285 286 287 def json_data ( self ) -> str : \"\"\"Creates a mapping of NCS pathway property names and their corresponding values. :returns: JSON representation of property name-value pairs for an NCS pathway object. :rtype: str \"\"\" ncs_attrs = ncs_pathway_to_dict ( self . _ncs_pathway ) return json . dumps ( ncs_attrs )","title":"json_data()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.setEnabled","text":"setEnabled ( enabled ) Override for default implementation that also enables or disables selection of the item. Source code in src/cplus_plugin/gui/component_item_model.py 299 300 301 302 303 304 def setEnabled ( self , enabled : bool ): \"\"\"Override for default implementation that also enables or disables selection of the item. \"\"\" self . setSelectable ( enabled ) super () . setEnabled ( enabled )","title":"setEnabled()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 253 254 255 256 257 258 259 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return NCS_PATHWAY_TYPE","title":"type()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel","text":"Bases: ComponentItemModel View model for NCS pathways.","title":"NcsPathwayItemModel"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.add_ncs_pathway","text":"add_ncs_pathway ( ncs ) Add an NCS pathway object to the model. Parameters: Name Type Description Default ncs NcsPathway NCS pathway object to the added to the view. required Returns: Type Description bool True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Add an NCS pathway object to the model. :param ncs: NCS pathway object to the added to the view. :type ncs: NcsPathway :returns: True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. :rtype: bool \"\"\" ncs_item = NcsPathwayItem . create ( ncs ) self . _update_display ( ncs_item ) status = self . add_component_item ( ncs_item ) self . sort ( 0 ) self . _re_index_rows () return status","title":"add_ncs_pathway()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.mimeData","text":"mimeData ( indexes ) Serializes the NCS items corresponding to the specified indexes. Parameters: Name Type Description Default indexes List [ QModelIndex ] NCS items stored in the specified indexes. required Returns: Type Description QtCore.QMimeData Mime object containing serialized NCS items. Source code in src/cplus_plugin/gui/component_item_model.py 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 def mimeData ( self , indexes : typing . List [ QtCore . QModelIndex ]) -> QtCore . QMimeData : \"\"\"Serializes the NCS items corresponding to the specified indexes. :param indexes: NCS items stored in the specified indexes. :type indexes: list :returns: Mime object containing serialized NCS items. :rtype: QtCore.QMimeData \"\"\" mime_data = QtCore . QMimeData () item_data = QtCore . QByteArray () data_stream = QtCore . QDataStream ( item_data , QtCore . QIODevice . WriteOnly ) for idx in indexes : if not idx . isValid (): continue ncs_item = self . itemFromIndex ( idx ) if ncs_item is None : continue # Do not add disabled items (e.g. disabled default NCS pathway items) if not ncs_item . isEnabled (): continue ncs_data = QtCore . QByteArray () ncs_data . append ( ncs_item . json_data ()) data_stream << ncs_data mime_data . setData ( NCS_MIME_TYPE , item_data ) return mime_data","title":"mimeData()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.mimeTypes","text":"mimeTypes () Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. Returns: Type Description list MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. Source code in src/cplus_plugin/gui/component_item_model.py 921 922 923 924 925 926 927 928 929 930 def mimeTypes ( self ) -> typing . List [ str ]: \"\"\"Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. :returns: MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. :rtype: list \"\"\" return [ NCS_MIME_TYPE ]","title":"mimeTypes()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.pathways","text":"pathways ( valid_only = False ) Returns NCS pathway objects in the model. Parameters: Name Type Description Default valid_only bool Whether to only return NCS pathway objects that are valid. False Returns: Type Description list All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. Source code in src/cplus_plugin/gui/component_item_model.py 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 def pathways ( self , valid_only : bool = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns NCS pathway objects in the model. :param valid_only: Whether to only return NCS pathway objects that are valid. :type valid_only: bool :returns: All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. :rtype: list \"\"\" ncs_pathways = self . model_components () if valid_only : return [ p for p in ncs_pathways if p . is_valid ()] return ncs_pathways","title":"pathways()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.remove_ncs_pathway","text":"remove_ncs_pathway ( ncs_uuid ) Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. Returns: Type Description bool True if the NCS pathway item as successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 899 900 901 902 903 904 905 906 907 908 909 def remove_ncs_pathway ( self , ncs_uuid : str ) -> bool : \"\"\"Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :returns: True if the NCS pathway item as successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" return self . remove_component_item ( ncs_uuid )","title":"remove_ncs_pathway()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.supportedDropActions","text":"supportedDropActions () Configure the model to only support copying items in a drag-and-drop operation. Returns: Type Description QtCore.Qt.DropActions Supported drag-and-drop action for NCS pathway items. Source code in src/cplus_plugin/gui/component_item_model.py 911 912 913 914 915 916 917 918 919 def supportedDropActions ( self ) -> QtCore . Qt . DropActions : \"\"\"Configure the model to only support copying items in a drag-and-drop operation. :returns: Supported drag-and-drop action for NCS pathway items. :rtype: QtCore.Qt.DropActions \"\"\" return QtCore . Qt . CopyAction","title":"supportedDropActions()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.update_ncs_pathway","text":"update_ncs_pathway ( ncs ) Updates the NCS pathway item in the model. Parameters: Name Type Description Default ncs NcsPathway NcsPathway whose corresponding item is to be updated. required Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 def update_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Updates the NCS pathway item in the model. :param ncs: NcsPathway whose corresponding item is to be updated. :type ncs: NcsPathway :returns: Returns True if the operation was successful else False if the matching item was not found in the model. \"\"\" item = self . component_item_by_uuid ( str ( ncs . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False self . _update_display ( item ) self . sort ( 0 ) self . _re_index_rows () return True","title":"update_ncs_pathway()"},{"location":"developer/api/gui/api_gui_main/","text":"GUI main The plugin main window class. QgisCplusMain QgisCplusMain ( iface , parent = None ) Bases: QDockWidget , WidgetUi Main plugin UI class Source code in src/cplus_plugin/gui/qgis_cplus_main.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self , iface , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . iface = iface self . progress_dialog = None self . task = None self . processing_cancelled = False self . prepare_input () # Insert widget for step 2 self . implementation_model_widget = ImplementationModelContainerWidget ( self , self . message_bar ) self . implementation_model_widget . ncs_reloaded . connect ( self . on_ncs_pathways_reloaded ) self . tab_widget . insertTab ( 1 , self . implementation_model_widget , self . tr ( \"Step 2\" ) ) self . tab_widget . currentChanged . connect ( self . on_tab_step_changed ) # Step 3, priority weighting layers initialization self . priority_groups_widgets = {} self . pwl_item_flags = None self . initialize_priority_layers () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () self . scenario_result = None self . analysis_finished . connect ( self . post_analysis ) add_priority_group add_priority_group () Adds a new priority group into the plugin, then updates the priority list to show the new added priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 653 654 655 656 657 658 659 def add_priority_group ( self ): \"\"\"Adds a new priority group into the plugin, then updates the priority list to show the new added priority group. \"\"\" group_dialog = PriorityGroupDialog () group_dialog . exec_ () self . update_priority_groups () add_priority_layer add_priority_layer () Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 720 721 722 723 724 725 726 def add_priority_layer ( self ): \"\"\"Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. \"\"\" layer_dialog = PriorityLayerDialog () layer_dialog . exec_ () self . update_priority_layers ( update_groups = False ) add_priority_layer_group add_priority_layer_group ( target_group = None , priority_layer = None ) Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. Parameters: Name Type Description Default target_group dict Priority group where layer will be added to None priority_layer dict Priority weighting layer to be added None Source code in src/cplus_plugin/gui/qgis_cplus_main.py 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 def add_priority_layer_group ( self , target_group = None , priority_layer = None ): \"\"\"Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. :param target_group: Priority group where layer will be added to :type target_group: dict :param priority_layer: Priority weighting layer to be added :type priority_layer: dict \"\"\" selected_priority_layers = ( priority_layer or self . priority_layers_list . selectedItems () ) selected_priority_layers = ( [ selected_priority_layers ] if not isinstance ( selected_priority_layers , list ) else selected_priority_layers ) selected_group = target_group or self . priority_groups_list . currentItem () for selected_priority_layer in selected_priority_layers : if ( selected_group is not None and selected_group . parent () is None ) and selected_priority_layer is not None : children = selected_group . takeChildren () item_found = False text = selected_priority_layer . data ( QtCore . Qt . DisplayRole ) for child in children : if child . text ( 0 ) == text : item_found = True break selected_group . addChildren ( children ) if not item_found : selected_group . setExpanded ( True ) item = QtWidgets . QTreeWidgetItem ( selected_group ) item . setText ( 0 , text ) group_widget = self . priority_groups_list . itemWidget ( selected_group , 0 ) layer_id = selected_priority_layer . data ( QtCore . Qt . UserRole ) priority_layer = settings_manager . get_priority_layer ( layer_id ) item . setData ( 0 , QtCore . Qt . UserRole , priority_layer . get ( USER_DEFINED_ATTRIBUTE ), ) target_group_name = ( group_widget . group . get ( \"name\" ) if group_widget . group else None ) groups = priority_layer . get ( \"groups\" ) new_groups = [] group_found = False for group in groups : if target_group_name == group [ \"name\" ]: group_found = True new_group = settings_manager . find_group_by_name ( target_group_name ) else : new_group = group new_groups . append ( new_group ) if not group_found : searched_group = settings_manager . find_group_by_name ( target_group_name ) new_groups . append ( searched_group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer ) # Trigger check to enable/disable PWLs based on current extent self . on_extent_changed ( self . extent_box . outputExtent ()) analysis_complete analysis_complete ( task , report_manager , progress_dialog ) Calls the responsible function for handling analysis results outputs Parameters: Name Type Description Default task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis reports required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def analysis_complete ( self , task , report_manager , progress_dialog ): \"\"\"Calls the responsible function for handling analysis results outputs :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis reports :type report_manager: ReportManager \"\"\" self . scenario_result = task . scenario_result self . scenario_results ( task , report_manager , progress_dialog ) cancel_processing_task cancel_processing_task () Cancels the current processing task. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1088 1089 1090 def cancel_processing_task ( self ): \"\"\"Cancels the current processing task.\"\"\" self . processing_cancelled = True edit_priority_group edit_priority_group () Edits the current selected priority group and updates the group box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 def edit_priority_group ( self ): \"\"\"Edits the current selected priority group and updates the group box list.\"\"\" if self . priority_groups_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority group from the groups list.\" ), Qgis . Critical , ) return group_identifier = self . priority_groups_list . currentItem () . data ( 0 , QtCore . Qt . UserRole ) if group_identifier == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority groups for editing.\" ), Qgis . Critical , ) return group = settings_manager . get_priority_group ( group_identifier ) group_dialog = PriorityGroupDialog ( group ) group_dialog . exec_ () self . update_priority_groups () edit_priority_layer edit_priority_layer () Edits the current selected priority layer and updates the layer box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 def edit_priority_layer ( self ): \"\"\"Edits the current selected priority layer and updates the layer box list.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority weighting layer from the layers list.\" ), Qgis . Critical , ) return layer_identifier = self . priority_layers_list . currentItem () . data ( QtCore . Qt . UserRole ) if layer_identifier == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . Critical , ) return self . _show_priority_layer_editor ( layer_identifier ) group_value_changed group_value_changed ( group_name , group_value ) Slot to handle priority group widget changes. Parameters: Name Type Description Default group_name str Group name required group_value int Group value required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 def group_value_changed ( self , group_name , group_value ): \"\"\"Slot to handle priority group widget changes. :param group_name: Group name :type group_name: str :param group_value: Group value :type group_value: int \"\"\" group = settings_manager . find_group_by_name ( group_name ) group [ \"value\" ] = group_value settings_manager . save_priority_group ( group ) for index in range ( self . priority_groups_list . topLevelItemCount ()): item = self . priority_groups_list . topLevelItem ( index ) for child_index in range ( item . childCount ()): child = item . child ( child_index ) layer = settings_manager . find_layer_by_name ( child . text ( 0 )) new_groups = [] for group in layer . get ( \"groups\" ): if group . get ( \"name\" ) == group_name : group [ \"value\" ] = group_value new_groups . append ( group ) layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( layer ) initialize_priority_layers initialize_priority_layers () Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def initialize_priority_layers ( self ): \"\"\"Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . UserRole , layer . get ( \"uuid\" )) if self . pwl_item_flags is None : self . pwl_item_flags = item . flags () self . priority_layers_list . addItem ( item ) list_items = [] items_only = [] stored_priority_groups = settings_manager . get_priority_groups () self . priority_groups_list . clear () for group in stored_priority_groups : group_widget = PriorityGroupWidget ( group , ) group_widget . input_value_changed . connect ( self . group_value_changed ) group_widget . slider_value_changed . connect ( self . group_value_changed ) self . priority_groups_widgets [ group [ \"name\" ]] = group_widget pw_layers = settings_manager . find_layers_by_group ( group [ \"name\" ]) item = QtWidgets . QTreeWidgetItem () item . setSizeHint ( 0 , group_widget . sizeHint ()) item . setExpanded ( True ) item . setData ( 0 , QtCore . Qt . UserRole , group . get ( \"uuid\" )) # Add priority layers into the group as a child items. item . setExpanded ( True ) if len ( pw_layers ) > 0 else None for layer in pw_layers : if item . parent () is None : layer_item = QtWidgets . QTreeWidgetItem ( item ) layer_item . setText ( 0 , layer . get ( \"name\" )) layer_item . setData ( 0 , QtCore . Qt . UserRole , layer . get ( USER_DEFINED_ATTRIBUTE ) ) list_items . append (( item , group_widget )) items_only . append ( item ) self . priority_groups_list . addTopLevelItems ( items_only ) for item in list_items : self . priority_groups_list . setItemWidget ( item [ 0 ], 0 , item [ 1 ]) # Trigger process to enable/disable PWLs based on current extents self . on_extent_changed ( self . extent_box . outputExtent ()) main_task main_task () Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1081 1082 1083 1084 1085 1086 def main_task ( self ): \"\"\"Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. \"\"\" log ( \"Running from main task.\" ) move_layer_to_group move_layer_to_group ( layer , group ) Moves a layer open in QGIS to another group. Parameters: Name Type Description Default layer QgsRasterLayer Raster layer to move required group QgsLayerTreeGroup Group to which the raster should be moved required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 def move_layer_to_group ( self , layer , group ) -> None : \"\"\"Moves a layer open in QGIS to another group. :param layer: Raster layer to move :type layer: QgsRasterLayer :param group: Group to which the raster should be moved :type group: QgsLayerTreeGroup \"\"\" if layer : instance_root = QgsProject . instance () . layerTreeRoot () layer = instance_root . findLayer ( layer . id ()) layer_clone = layer . clone () parent = layer . parent () group . insertChildNode ( 0 , layer_clone ) # Add to top of group parent . removeChildNode ( layer ) on_extent_changed on_extent_changed ( new_extent ) Slot raised when scenario extents have changed. Used to enable/disable default model items if they are within or outside the pilot AOI. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 def on_extent_changed ( self , new_extent : QgsRectangle ): \"\"\"Slot raised when scenario extents have changed. Used to enable/disable default model items if they are within or outside the pilot AOI. \"\"\" within_pilot_area = extent_within_pilot ( new_extent , self . extent_box . outputCrs ()) if not within_pilot_area : msg = tr ( \"Area of interest is outside the pilot area. Please use your \" \"own NCS pathways, implementation models and PWLs.\" ) self . show_message ( msg , Qgis . Info ) else : self . message_bar . clearWidgets () self . implementation_model_widget . enable_default_items ( within_pilot_area ) # Enable/disable PWL items for i in range ( self . priority_layers_list . count ()): pwl_item = self . priority_layers_list . item ( i ) uuid_str = pwl_item . data ( QtCore . Qt . UserRole ) if not uuid_str : continue pwl_uuid = uuid . UUID ( uuid_str ) pwl = settings_manager . get_priority_layer ( pwl_uuid ) if USER_DEFINED_ATTRIBUTE not in pwl : continue is_user_defined = pwl . get ( USER_DEFINED_ATTRIBUTE ) if is_user_defined : continue if within_pilot_area : pwl_item . setFlags ( self . pwl_item_flags ) else : pwl_item . setFlags ( QtCore . Qt . NoItemFlags ) # Enable/disable PWL items already defined under the priority groups for i in range ( self . priority_groups_list . topLevelItemCount ()): group_item = self . priority_groups_list . topLevelItem ( i ) for c in range ( group_item . childCount ()): pwl_tree_item = group_item . child ( c ) is_user_defined = pwl_tree_item . data ( 0 , QtCore . Qt . UserRole ) if is_user_defined : continue if within_pilot_area : pwl_tree_item . setFlags ( self . pwl_item_flags ) else : pwl_tree_item . setFlags ( QtCore . Qt . NoItemFlags ) on_ncs_pathways_reloaded on_ncs_pathways_reloaded () Slot raised when NCS pathways have been reloaded in the view. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 382 383 384 385 386 387 def on_ncs_pathways_reloaded ( self ): \"\"\"Slot raised when NCS pathways have been reloaded in the view.\"\"\" within_pilot_area = extent_within_pilot ( self . extent_box . outputExtent (), self . extent_box . outputCrs () ) self . implementation_model_widget . enable_default_items ( within_pilot_area ) on_progress_dialog_cancelled on_progress_dialog_cancelled () Slot raised when analysis has been cancelled in progress dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1657 1658 1659 1660 def on_progress_dialog_cancelled ( self ): \"\"\"Slot raised when analysis has been cancelled in progress dialog.\"\"\" if not self . run_scenario_btn . isEnabled (): self . run_scenario_btn . setEnabled ( True ) on_report_error on_report_error ( progress_dialog , message ) Slot raised when report task error has occured. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 def on_report_error ( self , progress_dialog , message : str ): \"\"\"Slot raised when report task error has occured. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog \"\"\" progress_dialog . report_running = True progress_dialog . change_status_message ( tr ( \"Error generating report, see logs for more info.\" ) ) log ( message ) self . run_scenario_btn . setEnabled ( True ) on_report_finished on_report_finished ( progress_dialog , scenario_id ) Slot raised when report task has finished. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required scenario_id str Scenario analysis id required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 def on_report_finished ( self , progress_dialog , scenario_id : str ): \"\"\"Slot raised when report task has finished. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param scenario_id: Scenario analysis id :type scenario_id: str \"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return progress_dialog . set_report_complete () progress_dialog . change_status_message ( tr ( \"Report generation complete\" )) self . run_scenario_btn . setEnabled ( True ) on_report_running on_report_running ( progress_dialog , scenario_id ) Slot raised when report task has started. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required scenario_id str Scenario analysis id required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 def on_report_running ( self , progress_dialog , scenario_id : str ): \"\"\"Slot raised when report task has started. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param scenario_id: Scenario analysis id :type scenario_id: str \"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return progress_dialog . update_progress_bar ( 0 ) progress_dialog . report_running = True progress_dialog . change_status_message ( tr ( \"Generating report for the analysis output\" ) ) on_reporting_progress_changed on_reporting_progress_changed ( progress_dialog , progress ) Slot raised when the reporting progress has changed. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required progress float Analysis progress value between 0 and 100 required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 def on_reporting_progress_changed ( self , progress_dialog , progress : float ): \"\"\"Slot raised when the reporting progress has changed. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param progress: Analysis progress value between 0 and 100 :type progress: float \"\"\" progress_dialog . update_progress_bar ( progress ) on_tab_step_changed on_tab_step_changed ( index ) Slot raised when the current tab changes. Parameters: Name Type Description Default index int Zero-based index position of new current tab required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 def on_tab_step_changed ( self , index : int ): \"\"\"Slot raised when the current tab changes. :param index: Zero-based index position of new current tab :type index: int \"\"\" if index == 1 : self . implementation_model_widget . can_show_error_messages = True self . implementation_model_widget . load () elif index == 2 : # Validate implementation model selection selected_implementation_models = ( self . implementation_model_widget . selected_im_items () ) if len ( selected_implementation_models ) == 0 : msg = self . tr ( \"Please select at least one implementation model.\" ) self . show_message ( msg ) self . tab_widget . setCurrentIndex ( 1 ) else : self . message_bar . clearWidgets () open_help open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/qgis_cplus_main.py 649 650 651 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) open_settings open_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1505 1506 1507 def open_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE ) post_analysis post_analysis ( scenario_result , task , report_manager , progress_dialog ) Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the implementation models to the canvas with styling. Adds each IMs pathways to the canvas. Parameters: Name Type Description Default scenario_result ScenarioResult ScenarioResult of output results required task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis reports required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 def post_analysis ( self , scenario_result , task , report_manager , progress_dialog ): \"\"\"Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the implementation models to the canvas with styling. Adds each IMs pathways to the canvas. :param scenario_result: ScenarioResult of output results :type scenario_result: ScenarioResult :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis reports :type report_manager: ReportManager \"\"\" # If the processing were stopped, no file will be added if not self . processing_cancelled : list_models = scenario_result . scenario . models raster = scenario_result . analysis_output [ \"OUTPUT\" ] im_weighted_dir = os . path . join ( os . path . dirname ( raster ), \"weighted_ims\" ) scenario_name = scenario_result . scenario . name qgis_instance = QgsProject . instance () instance_root = qgis_instance . layerTreeRoot () # Check if there are other groups for the scenario # and assign a suffix. counter = 1 group_name = scenario_name # Control to prevent infinite loop max_limit = 100 while True and counter <= max_limit : scenario_grp = instance_root . findGroup ( group_name ) if scenario_grp is None : break group_name = f \" { scenario_name } { counter !s} \" counter += 1 # Groups scenario_group = instance_root . insertGroup ( 0 , group_name ) im_group = scenario_group . addGroup ( tr ( IM_GROUP_LAYER_NAME )) im_weighted_group = ( scenario_group . addGroup ( tr ( IM_WEIGHTED_GROUP_NAME )) if os . path . exists ( im_weighted_dir ) else None ) pathways_group = scenario_group . addGroup ( tr ( NCS_PATHWAYS_GROUP_LAYER_NAME )) # Group settings im_group . setExpanded ( False ) im_weighted_group . setExpanded ( False ) if im_weighted_group else None pathways_group . setExpanded ( False ) pathways_group . setItemVisibilityCheckedRecursive ( False ) # Add scenario result layer to the canvas with styling layer_file = scenario_result . analysis_output . get ( \"OUTPUT\" ) layer_name = ( f \" { SCENARIO_OUTPUT_LAYER_NAME } _\" f ' { datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' ) scenario_result . output_layer_name = layer_name layer = QgsRasterLayer ( layer_file , layer_name , QGIS_GDAL_PROVIDER ) scenario_layer = qgis_instance . addMapLayer ( layer ) # Scenario result layer styling renderer = self . style_models_layer ( layer , task . analysis_weighted_ims ) layer . setRenderer ( renderer ) layer . triggerRepaint () \"\"\"A workaround to add a layer to a group. Adding it using group.insertChildNode or group.addLayer causes issues, but adding to the root is fine. This approach adds it to the root, and then moves it to the group. \"\"\" self . move_layer_to_group ( scenario_layer , scenario_group ) # Add implementation models and pathways im_index = 0 for im in list_models : im_name = im . name im_layer = QgsRasterLayer ( im . path , im . name ) im_layer . setCustomProperty ( MODEL_IDENTIFIER_PROPERTY , str ( im . uuid )) list_pathways = im . pathways # Add IM layer with styling, if available if im_layer : renderer = self . style_model_layer ( im_layer , im ) added_im_layer = qgis_instance . addMapLayer ( im_layer ) self . move_layer_to_group ( added_im_layer , im_group ) im_layer . setRenderer ( renderer ) im_layer . triggerRepaint () # Add IM pathways if len ( list_pathways ) > 0 : # im_pathway_group = pathways_group.addGroup(im_name) im_pathway_group = pathways_group . insertGroup ( im_index , im_name ) im_pathway_group . setExpanded ( False ) pw_index = 0 for pathway in list_pathways : try : # pathway_name = pathway.name pathway_layer = pathway . to_map_layer () added_pw_layer = qgis_instance . addMapLayer ( pathway_layer ) self . move_layer_to_group ( added_pw_layer , im_pathway_group ) pathway_layer . triggerRepaint () pw_index = pw_index + 1 except Exception as err : self . show_message ( tr ( \"An error occurred loading a pathway, \" \"check logs for more information\" ), level = Qgis . Info , ) log ( tr ( \"An error occurred loading a pathway, \" 'scenario analysis, error message \" {} \"' . format ( err ) ) ) im_index = im_index + 1 weighted_ims = task . analysis_weighted_ims if task is not None else [] for model in weighted_ims : weighted_im_path = model . path weighted_im_name = Path ( weighted_im_path ) . stem if not weighted_im_path . endswith ( \".tif\" ): continue im_weighted_layer = QgsRasterLayer ( weighted_im_path , weighted_im_name , QGIS_GDAL_PROVIDER ) # Set UUID for easier retrieval im_weighted_layer . setCustomProperty ( MODEL_IDENTIFIER_PROPERTY , str ( model . uuid ) ) renderer = self . style_model_layer ( im_weighted_layer , model ) im_weighted_layer . setRenderer ( renderer ) im_weighted_layer . triggerRepaint () added_im_weighted_layer = qgis_instance . addMapLayer ( im_weighted_layer ) self . move_layer_to_group ( added_im_weighted_layer , im_weighted_group ) # Initiate report generation self . run_report ( progress_dialog , report_manager ) else : # Reinitializes variables if processing were cancelled by the user # Not doing this breaks the processing if a user tries to run # the processing after cancelling or if the processing fails self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () prepare_extent_box prepare_extent_box () Configure the spatial extent box with the initial settings. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 def prepare_extent_box ( self ): \"\"\"Configure the spatial extent box with the initial settings.\"\"\" self . extent_box . setOutputCrs ( QgsCoordinateReferenceSystem ( \"EPSG:4326\" )) map_canvas = iface . mapCanvas () self . extent_box . setCurrentExtent ( map_canvas . mapSettings () . destinationCrs () . bounds (), map_canvas . mapSettings () . destinationCrs (), ) self . extent_box . setOutputExtentFromCurrent () self . extent_box . setMapCanvas ( map_canvas ) extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) self . extent_box . setOutputExtentFromUser ( default_extent , QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), ) prepare_input prepare_input () Initializes plugin input widgets Source code in src/cplus_plugin/gui/qgis_cplus_main.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def prepare_input ( self ): \"\"\"Initializes plugin input widgets\"\"\" self . prepare_extent_box () self . grid_layout = QtWidgets . QGridLayout () self . message_bar = QgsMessageBar () self . prepare_message_bar () self . progress_dialog = None self . scenario_directory = None self . help_btn . clicked . connect ( self . open_help ) self . pilot_area_btn . clicked . connect ( self . zoom_pilot_area ) self . run_scenario_btn . clicked . connect ( self . run_analysis ) self . options_btn . clicked . connect ( self . open_settings ) self . restore_scenario () self . scenario_name . textChanged . connect ( self . save_scenario ) self . scenario_description . textChanged . connect ( self . save_scenario ) self . extent_box . extentChanged . connect ( self . save_scenario ) # Monitors if current extents are within the pilot AOI self . extent_box . extentChanged . connect ( self . on_extent_changed ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) add_layer_icon = QtGui . QIcon ( ADD_LAYER_ICON_PATH ) self . layer_add_btn . setIcon ( add_layer_icon ) remove_layer_icon = QtGui . QIcon ( REMOVE_LAYER_ICON_PATH ) self . layer_remove_btn . setIcon ( remove_layer_icon ) self . layer_add_btn . clicked . connect ( self . add_priority_layer_group ) self . layer_remove_btn . clicked . connect ( self . remove_priority_layer_group ) # Priority groups buttons self . add_group_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . edit_group_btn . setIcon ( FileUtils . get_icon ( \"mActionToggleEditing.svg\" )) self . remove_group_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . add_group_btn . clicked . connect ( self . add_priority_group ) self . edit_group_btn . clicked . connect ( self . edit_priority_group ) self . remove_group_btn . clicked . connect ( self . remove_priority_group ) # Priority layers buttons self . add_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . edit_pwl_btn . setIcon ( FileUtils . get_icon ( \"mActionToggleEditing.svg\" )) self . remove_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . add_pwl_btn . clicked . connect ( self . add_priority_layer ) self . edit_pwl_btn . clicked . connect ( self . edit_priority_layer ) self . remove_pwl_btn . clicked . connect ( self . remove_priority_layer ) self . priority_layers_list . itemDoubleClicked . connect ( self . _on_double_click_priority_layer ) # Add priority groups list into the groups frame self . priority_groups_list = CustomTreeWidget () self . priority_groups_list . setHeaderHidden ( True ) self . priority_groups_list . setDragEnabled ( True ) self . priority_groups_list . setDragDropOverwriteMode ( True ) self . priority_groups_list . viewport () . setAcceptDrops ( True ) self . priority_groups_list . setDragDropMode ( QtWidgets . QAbstractItemView . DropOnly ) self . priority_groups_list . child_dragged_dropped . connect ( self . priority_groups_update ) layout = QtWidgets . QVBoxLayout () layout . setSpacing ( 0 ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) layout . addWidget ( self . priority_groups_list ) self . priority_groups_frame . setLayout ( layout ) # Scenario analysis variables self . analysis_scenario_name = None self . analysis_scenario_description = None self . analysis_extent = None self . analysis_implementation_models = None self . analysis_weighted_ims = [] self . analysis_priority_layers_groups = [] prepare_message_bar prepare_message_bar () Initializes the widget message bar settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 794 795 796 797 798 799 800 801 802 def prepare_message_bar ( self ): \"\"\"Initializes the widget message bar settings\"\"\" self . message_bar . setSizePolicy ( QtWidgets . QSizePolicy . Minimum , QtWidgets . QSizePolicy . Fixed ) self . grid_layout . addWidget ( self . message_bar , 0 , 0 , 1 , 1 , alignment = QtCore . Qt . AlignTop ) self . dock_widget_contents . layout () . insertLayout ( 0 , self . grid_layout ) priority_groups_update priority_groups_update ( target_item , selected_items ) Updates the priority groups list item with the passed selected layer items. Parameters: Name Type Description Default target_item QTreeWidgetItem The priority group tree widget item that is to be updated required selected_items list Priority layers items from the list widget required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def priority_groups_update ( self , target_item , selected_items ): \"\"\"Updates the priority groups list item with the passed selected layer items. :param target_item: The priority group tree widget item that is to be updated :type target_item: QTreeWidgetItem :param selected_items: Priority layers items from the list widget :type selected_items: list \"\"\" self . priority_groups_list . setCurrentItem ( target_item ) for item in selected_items : self . add_priority_layer_group ( target_item , item ) remove_priority_group remove_priority_group () Removes the current active priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 def remove_priority_group ( self ): \"\"\"Removes the current active priority group.\"\"\" if self . priority_groups_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority group from the groups list\" ), Qgis . Critical , ) return group_identifier = self . priority_groups_list . currentItem () . data ( 0 , QtCore . Qt . UserRole ) group = settings_manager . get_priority_group ( group_identifier ) current_text = group . get ( \"name\" ) if group_identifier is None or group_identifier == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority group for editing.\" ), Qgis . Critical , ) return reply = QtWidgets . QMessageBox . warning ( self , tr ( \"QGIS CPLUS PLUGIN\" ), tr ( 'Remove the priority group \" {} \"?' ) . format ( current_text ), QtWidgets . QMessageBox . Yes , QtWidgets . QMessageBox . No , ) if reply == QtWidgets . QMessageBox . Yes : settings_manager . delete_priority_group ( group_identifier ) self . update_priority_groups () remove_priority_layer remove_priority_layer () Removes the current active priority layer. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 def remove_priority_layer ( self ): \"\"\"Removes the current active priority layer.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority \" \"weighting layer from the layers list.\" ), Qgis . Critical , ) return current_text = self . priority_layers_list . currentItem () . data ( QtCore . Qt . DisplayRole ) if current_text == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . Critical , ) return layer = settings_manager . find_layer_by_name ( current_text ) reply = QtWidgets . QMessageBox . warning ( self , tr ( \"QGIS CPLUS PLUGIN\" ), tr ( 'Remove the priority layer \" {} \"?' ) . format ( current_text ), QtWidgets . QMessageBox . Yes , QtWidgets . QMessageBox . No , ) if reply == QtWidgets . QMessageBox . Yes : settings_manager . delete_priority_layer ( layer . get ( \"uuid\" )) self . update_priority_layers ( update_groups = False ) remove_priority_layer_group remove_priority_layer_group () Remove the current select priority layer from the current priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 def remove_priority_layer_group ( self ): \"\"\"Remove the current select priority layer from the current priority group.\"\"\" selected_group = self . priority_groups_list . currentItem () parent_item = selected_group . parent () if selected_group is not None else None if parent_item : priority_layer = settings_manager . find_layer_by_name ( selected_group . text ( 0 )) group_widget = self . priority_groups_list . itemWidget ( parent_item , 0 ) groups = priority_layer . get ( \"groups\" ) new_groups = [] for group in groups : if group . get ( \"name\" ) == group_widget . group . get ( \"name\" ): continue new_groups . append ( group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer ) parent_item . removeChild ( selected_group ) report_job_is_for_current_scenario report_job_is_for_current_scenario ( scenario_id ) Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. Parameters: Name Type Description Default scenario_id str Scenario identifier usually from a signal raised by the report manager. required Returns: Type Description bool True if the scenario identifier matches the current scenario object in the results, else False. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 def report_job_is_for_current_scenario ( self , scenario_id : str ) -> bool : \"\"\"Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. :param scenario_id: Scenario identifier usually from a signal raised by the report manager. :type scenario_id: str :returns: True if the scenario identifier matches the current scenario object in the results, else False. :rtype: bool \"\"\" if self . scenario_result is None : return False current_scenario = self . scenario_result . scenario if current_scenario is None : return False if str ( current_scenario . uuid ) == scenario_id : return True return False reset_reporting_feedback reset_reporting_feedback ( progress_dialog ) Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required Returns: Type Description QgsFeedback Feedback instance to be used in storing processing status details. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 def reset_reporting_feedback ( self , progress_dialog ): \"\"\"Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :returns reporting_feedback: Feedback instance to be used in storing processing status details. :rtype reporting_feedback: QgsFeedback \"\"\" progress_changed = partial ( self . on_reporting_progress_changed , progress_dialog ) reporting_feedback = QgsFeedback ( self ) reporting_feedback . progressChanged . connect ( progress_changed ) return reporting_feedback restore_scenario restore_scenario () Update the first tab input with the last scenario details Source code in src/cplus_plugin/gui/qgis_cplus_main.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def restore_scenario ( self ): \"\"\"Update the first tab input with the last scenario details\"\"\" scenario_name = settings_manager . get_value ( Settings . SCENARIO_NAME ) scenario_description = settings_manager . get_value ( Settings . SCENARIO_DESCRIPTION ) extent = settings_manager . get_value ( Settings . SCENARIO_EXTENT ) self . scenario_name . setText ( scenario_name ) if scenario_name is not None else None self . scenario_description . setText ( scenario_description ) if scenario_description is not None else None if extent is not None : extent_rectangle = QgsRectangle ( float ( extent [ 0 ]), float ( extent [ 2 ]), float ( extent [ 1 ]), float ( extent [ 3 ]) ) self . extent_box . setOutputExtentFromUser ( extent_rectangle , QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), ) run_analysis run_analysis () Runs the plugin analysis Creates new QgsTask, progress dialog and report manager for each new scenario analysis. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 def run_analysis ( self ): \"\"\"Runs the plugin analysis Creates new QgsTask, progress dialog and report manager for each new scenario analysis. \"\"\" extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) passed_extent = self . extent_box . outputExtent () contains = default_extent == passed_extent or default_extent . contains ( passed_extent ) self . analysis_scenario_name = self . scenario_name . text () self . analysis_scenario_description = self . scenario_description . text () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () for group in settings_manager . get_priority_groups (): group_layer_dict = { \"name\" : group . get ( \"name\" ), \"value\" : group . get ( \"value\" ), \"layers\" : [], } for layer in settings_manager . get_priority_layers (): pwl_items = self . priority_layers_list . findItems ( layer . get ( \"name\" ), QtCore . Qt . MatchExactly ) if len ( pwl_items ) > 0 : # Exclude adding the PWL since its for a disabled default # item outside the pilot AOI. if pwl_items [ 0 ] . flags () == QtCore . Qt . NoItemFlags : continue group_names = [ group . get ( \"name\" ) for group in layer . get ( \"groups\" , [])] if group . get ( \"name\" ) in group_names : group_layer_dict [ \"layers\" ] . append ( layer . get ( \"name\" )) self . analysis_priority_layers_groups . append ( group_layer_dict ) self . analysis_implementation_models = [ item . implementation_model for item in self . implementation_model_widget . selected_im_items () if item . isEnabled () ] self . analysis_weighted_ims = [] base_dir = settings_manager . get_value ( Settings . BASE_DIR ) if self . analysis_scenario_name == \"\" or self . analysis_scenario_name is None : self . show_message ( tr ( f \"Scenario name cannot be blank.\" ), level = Qgis . Critical , ) return if ( self . analysis_scenario_description == \"\" or self . analysis_scenario_description is None ): self . show_message ( tr ( f \"Scenario description cannot be blank.\" ), level = Qgis . Critical , ) return if ( self . analysis_implementation_models == [] or self . analysis_implementation_models is None ): self . show_message ( tr ( \"Select at least one implementation models from step two.\" ), level = Qgis . Critical , ) return if not contains : self . show_message ( tr ( f \"Selected area of interest is outside the pilot area.\" ), level = Qgis . Info , ) default_ext = ( f \" { default_extent . xMinimum () } , { default_extent . xMaximum () } ,\" f \" { default_extent . yMinimum () } , { default_extent . yMaximum () } \" ) log ( f \"Outside the pilot area, passed extent \" f \" { passed_extent } \" f \"default extent { default_ext } \" ) if base_dir is None : self . show_message ( tr ( f \"Plugin base data directory is not set! \" f \"Go to plugin settings in order to set it.\" ), level = Qgis . Critial , ) return self . analysis_extent = SpatialExtent ( bbox = [ passed_extent . xMinimum (), passed_extent . xMaximum (), passed_extent . yMinimum (), passed_extent . yMaximum (), ] ) try : self . run_scenario_btn . setEnabled ( False ) scenario = Scenario ( uuid = uuid . uuid4 (), name = self . analysis_scenario_name , description = self . analysis_scenario_description , extent = self . analysis_extent , models = self . analysis_implementation_models , weighted_models = [], priority_layer_groups = self . analysis_priority_layers_groups , ) self . processing_cancelled = False # Creates and opens the progress dialog for the analysis progress_dialog = ProgressDialog ( minimum = 0 , maximum = 100 , main_widget = self , scenario_id = str ( scenario . uuid ), scenario_name = self . analysis_scenario_name , ) progress_dialog . analysis_cancelled . connect ( self . on_progress_dialog_cancelled ) progress_dialog . run_dialog () progress_dialog . change_status_message ( tr ( \"Raster calculation for models pathways\" ) ) selected_pathway = None pathway_found = False for model in self . analysis_implementation_models : if pathway_found : break for pathway in model . pathways : if pathway is not None : pathway_found = True selected_pathway = pathway break extent_box = QgsRectangle ( float ( self . analysis_extent . bbox [ 0 ]), float ( self . analysis_extent . bbox [ 2 ]), float ( self . analysis_extent . bbox [ 1 ]), float ( self . analysis_extent . bbox [ 3 ]), ) selected_pathway_layer = QgsRasterLayer ( selected_pathway . path , selected_pathway . name ) source_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) if selected_pathway_layer . crs () is not None : destination_crs = selected_pathway_layer . crs () else : destination_crs = QgsProject . instance () . crs () transformed_extent = self . transform_extent ( extent_box , source_crs , destination_crs ) self . analysis_extent . bbox = [ transformed_extent . xMinimum (), transformed_extent . xMaximum (), transformed_extent . yMinimum (), transformed_extent . yMaximum (), ] analysis_task = ScenarioAnalysisTask ( self . analysis_scenario_name , self . analysis_scenario_description , self . analysis_implementation_models , self . analysis_priority_layers_groups , self . analysis_extent , scenario , ) progress_changed = partial ( self . update_progress_bar , progress_dialog ) analysis_task . custom_progress_changed . connect ( progress_changed ) status_message_changed = partial ( self . update_progress_dialog , progress_dialog ) analysis_task . status_message_changed . connect ( status_message_changed ) analysis_task . info_message_changed . connect ( self . show_message ) progress_dialog . analysis_task = analysis_task progress_dialog . scenario_id = str ( scenario . uuid ) report_running = partial ( self . on_report_running , progress_dialog ) report_error = partial ( self . on_report_error , progress_dialog ) report_finished = partial ( self . on_report_finished , progress_dialog ) # Report manager scenario_report_manager = report_manager scenario_report_manager . generate_started . connect ( report_running ) scenario_report_manager . generate_error . connect ( report_error ) scenario_report_manager . generate_completed . connect ( report_finished ) analysis_complete = partial ( self . analysis_complete , analysis_task , scenario_report_manager , progress_dialog , ) analysis_task . taskCompleted . connect ( analysis_complete ) analysis_task . taskTerminated . connect ( self . task_terminated ) QgsApplication . taskManager () . addTask ( analysis_task ) except Exception as err : self . show_message ( tr ( \"An error occurred when preparing analysis task\" ), level = Qgis . Info , ) log ( tr ( \"An error occurred when preparing analysis task\" ', error message \" {} \"' . format ( err ) ) ) run_report run_report ( progress_dialog , report_manager ) Run report generation. This should be called after the analysis is complete. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required report_manager ReportManager Report manager used to generate analysis reports required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 def run_report ( self , progress_dialog , report_manager ): \"\"\"Run report generation. This should be called after the analysis is complete. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param report_manager: Report manager used to generate analysis reports :type report_manager: ReportManager \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return if self . scenario_result is None : log ( \"Cannot run report generation, scenario result is not defined\" , info = False , ) return reporting_feedback = self . reset_reporting_feedback ( progress_dialog ) self . reporting_feedback = reporting_feedback submit_result = report_manager . generate ( self . scenario_result , reporting_feedback ) if not submit_result . status : msg = self . tr ( \"Unable to submit report request for scenario\" ) self . show_message ( f \" { msg } { self . scenario_result . scenario . name } .\" ) save_scenario save_scenario () Save current scenario details into settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def save_scenario ( self ): \"\"\"Save current scenario details into settings\"\"\" scenario_name = self . scenario_name . text () scenario_description = self . scenario_description . text () extent = self . extent_box . outputExtent () extent_box = [ extent . xMinimum (), extent . xMaximum (), extent . yMinimum (), extent . yMaximum (), ] settings_manager . set_value ( Settings . SCENARIO_NAME , scenario_name ) settings_manager . set_value ( Settings . SCENARIO_DESCRIPTION , scenario_description ) settings_manager . set_value ( Settings . SCENARIO_EXTENT , extent_box ) scenario_results scenario_results ( task , report_manager , progress_dialog ) Called when the task ends. Sets the progress bar to 100 if it finished. Parameters: Name Type Description Default task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis reports required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 def scenario_results ( self , task , report_manager , progress_dialog ): \"\"\"Called when the task ends. Sets the progress bar to 100 if it finished. :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis reports :type report_manager: ReportManager \"\"\" if task . output is not None : self . update_progress_bar ( progress_dialog , 100 ) self . scenario_result . analysis_output = task . output self . scenario_result . state = ScenarioState . FINISHED self . post_analysis ( self . scenario_result , task , report_manager , progress_dialog ) else : status_message = \"No valid output from the processing results.\" task . set_status_message ( status_message ) log ( f \"No valid output from the processing results.\" ) show_message show_message ( message , level = Qgis . Warning ) Shows message on the main widget message bar. Parameters: Name Type Description Default message str Text message required level Qgis.MessageLevel Message level type Warning Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 def show_message ( self , message , level = Qgis . Warning ): \"\"\"Shows message on the main widget message bar. :param message: Text message :type message: str :param level: Message level type :type level: Qgis.MessageLevel \"\"\" self . message_bar . clearWidgets () self . message_bar . pushMessage ( message , level = level ) style_model_layer style_model_layer ( layer , model ) Applies the styling to the layer that contains the passed implementation model name. Parameters: Name Type Description Default layer QgsRasterLayer Raster layer to which to apply the symbology required model ImplementationModel Implementation model required Returns: Type Description QgsSingleBandPseudoColorRenderer Renderer for the symbology. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 def style_model_layer ( self , layer , model ): \"\"\"Applies the styling to the layer that contains the passed implementation model name. :param layer: Raster layer to which to apply the symbology :type layer: QgsRasterLayer :param model: Implementation model :type model: ImplementationModel :returns: Renderer for the symbology. :rtype: QgsSingleBandPseudoColorRenderer \"\"\" # Retrieves a build-in QGIS color ramp color_ramp = model . model_color_ramp () stats = layer . dataProvider () . bandStatistics ( 1 ) renderer = QgsSingleBandPseudoColorRenderer ( layer . dataProvider (), 1 ) renderer . setClassificationMin ( stats . minimumValue ) renderer . setClassificationMax ( stats . maximumValue ) renderer . createShader ( color_ramp , QgsColorRampShader . Interpolated , QgsColorRampShader . Continuous ) return renderer style_models_layer style_models_layer ( layer , models ) Applies the styling to the passed layer that contains the passed list of models. Parameters: Name Type Description Default layer QgsRasterLayer Layer to be styled required models list List which contains the implementation models that were passed to the highest position analysis tool required Returns: Type Description QgsPalettedRasterRenderer Renderer for the symbology. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 def style_models_layer ( self , layer , models ): \"\"\"Applies the styling to the passed layer that contains the passed list of models. :param layer: Layer to be styled :type layer: QgsRasterLayer :param models: List which contains the implementation models that were passed to the highest position analysis tool :type models: list :returns: Renderer for the symbology. :rtype: QgsPalettedRasterRenderer \"\"\" area_classes = [] for model in models : im_name = model . name raster_val = model . style_pixel_value color = model . scenario_fill_symbol () . color () color_ramp_shader = QgsColorRampShader . ColorRampItem ( float ( raster_val ), QtGui . QColor ( color ), im_name ) area_classes . append ( color_ramp_shader ) class_data = QgsPalettedRasterRenderer . colorTableToClassData ( area_classes ) renderer = QgsPalettedRasterRenderer ( layer . dataProvider (), 1 , class_data ) return renderer task_terminated task_terminated () Handles logging of the scenario analysis task status after it has been terminated. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1044 1045 1046 1047 1048 def task_terminated ( self ): \"\"\"Handles logging of the scenario analysis task status after it has been terminated. \"\"\" log ( f \"Main task terminated\" ) transform_extent transform_extent ( extent , source_crs , dest_crs ) Transforms the passed extent into the destination crs :param extent: Target extent Parameters: Name Type Description Default source_crs QgsCoordinateReferenceSystem Source CRS of the passed extent required dest_crs QgsCoordinateReferenceSystem Destination CRS required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 def transform_extent ( self , extent , source_crs , dest_crs ): \"\"\"Transforms the passed extent into the destination crs :param extent: Target extent :type extent: QgsRectangle :param source_crs: Source CRS of the passed extent :type source_crs: QgsCoordinateReferenceSystem :param dest_crs: Destination CRS :type dest_crs: QgsCoordinateReferenceSystem \"\"\" transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance ()) transformed_extent = transform . transformBoundingBox ( extent ) return transformed_extent update_message_bar update_message_bar ( message ) Changes the message in the message bar item. Parameters: Name Type Description Default message str Message to be updated required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1405 1406 1407 1408 1409 1410 1411 1412 def update_message_bar ( self , message ): \"\"\"Changes the message in the message bar item. :param message: Message to be updated :type message: str \"\"\" message_bar_item = self . message_bar . createMessage ( message ) self . message_bar . pushWidget ( message_bar_item , Qgis . Info ) update_priority_layers update_priority_layers ( update_groups = True ) Updates the priority weighting layers list in the UI. Parameters: Name Type Description Default update_groups bool Whether to update the priority groups list or not True Source code in src/cplus_plugin/gui/qgis_cplus_main.py 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 def update_priority_layers ( self , update_groups = True ): \"\"\"Updates the priority weighting layers list in the UI. :param update_groups: Whether to update the priority groups list or not :type update_groups: bool \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . UserRole , layer . get ( \"uuid\" )) self . priority_layers_list . addItem ( item ) if update_groups : for index in range ( self . priority_groups_list . topLevelItemCount ()): group = self . priority_groups_list . topLevelItem ( index ) if group . text ( 0 ) in layer . get ( \"groups\" ): self . add_priority_layer_group ( group , item ) else : group_children = group . takeChildren () children = [] for child in group_children : if child . text ( 0 ) == layer . get ( \"name\" ): continue children . append ( child ) group . addChildren ( children ) # Trigger check to enable/disable PWLs self . on_extent_changed ( self . extent_box . outputExtent ()) update_progress_bar update_progress_bar ( progress_dialog , value ) Sets the value of the progress bar Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 def update_progress_bar ( self , progress_dialog , value ): \"\"\"Sets the value of the progress bar :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param value: Value to be set on the progress bar :type value: float \"\"\" if progress_dialog and not self . processing_cancelled : try : progress_dialog . update_progress_bar ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False ) update_progress_dialog update_progress_dialog ( progress_dialog , message = None ) Run report generation. This should be called after the analysis is complete. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required message ReportManager Report manager used to generate analysis reports None Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 def update_progress_dialog ( self , progress_dialog , message = None , ): \"\"\"Run report generation. This should be called after the analysis is complete. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param message: Report manager used to generate analysis reports :type message: ReportManager \"\"\" progress_dialog . change_status_message ( message ) if message is not None else None update_pwl_layers update_pwl_layers ( notify = False ) Updates the priority layers path available in the store implementation models Parameters: Name Type Description Default notify bool Whether to show message to user about the update False Source code in src/cplus_plugin/gui/qgis_cplus_main.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def update_pwl_layers ( self , notify = False ): \"\"\"Updates the priority layers path available in the store implementation models :param notify: Whether to show message to user about the update :type notify: bool \"\"\" settings_manager . update_implementation_models () self . update_priority_layers () if notify : self . show_message ( tr ( \"Updated all the implementation models\" \" with their respective priority layers\" ), Qgis . Info , ) log ( tr ( \"Updated all the implementation models\" \" with their respective priority layers\" ) ) zoom_pilot_area zoom_pilot_area () Zoom the current main map canvas to the pilot area extent. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 def zoom_pilot_area ( self ): \"\"\"Zoom the current main map canvas to the pilot area extent.\"\"\" map_canvas = iface . mapCanvas () extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) zoom_extent = QgsRectangle ( extent_list [ 0 ] - 0.5 , extent_list [ 2 ], extent_list [ 1 ] + 0.5 , extent_list [ 3 ] ) canvas_crs = map_canvas . mapSettings () . destinationCrs () original_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) if canvas_crs . authid () != original_crs . authid (): zoom_extent = self . transform_extent ( zoom_extent , original_crs , canvas_crs ) default_extent = self . transform_extent ( default_extent , original_crs , canvas_crs ) aoi = QgsRubberBand ( iface . mapCanvas (), QgsWkbTypes . PolygonGeometry ) aoi . setFillColor ( QtGui . QColor ( 0 , 0 , 0 , 0 )) aoi . setStrokeColor ( QtGui . QColor ( 88 , 128 , 8 )) aoi . setWidth ( 3 ) aoi . setLineStyle ( QtCore . Qt . DashLine ) geom = QgsGeometry . fromRect ( default_extent ) aoi . setToGeometry ( geom , canvas_crs ) map_canvas . setExtent ( zoom_extent ) map_canvas . refresh ()","title":"GUI main"},{"location":"developer/api/gui/api_gui_main/#gui-main","text":"The plugin main window class.","title":"GUI main"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain","text":"QgisCplusMain ( iface , parent = None ) Bases: QDockWidget , WidgetUi Main plugin UI class Source code in src/cplus_plugin/gui/qgis_cplus_main.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self , iface , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . iface = iface self . progress_dialog = None self . task = None self . processing_cancelled = False self . prepare_input () # Insert widget for step 2 self . implementation_model_widget = ImplementationModelContainerWidget ( self , self . message_bar ) self . implementation_model_widget . ncs_reloaded . connect ( self . on_ncs_pathways_reloaded ) self . tab_widget . insertTab ( 1 , self . implementation_model_widget , self . tr ( \"Step 2\" ) ) self . tab_widget . currentChanged . connect ( self . on_tab_step_changed ) # Step 3, priority weighting layers initialization self . priority_groups_widgets = {} self . pwl_item_flags = None self . initialize_priority_layers () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () self . scenario_result = None self . analysis_finished . connect ( self . post_analysis )","title":"QgisCplusMain"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.add_priority_group","text":"add_priority_group () Adds a new priority group into the plugin, then updates the priority list to show the new added priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 653 654 655 656 657 658 659 def add_priority_group ( self ): \"\"\"Adds a new priority group into the plugin, then updates the priority list to show the new added priority group. \"\"\" group_dialog = PriorityGroupDialog () group_dialog . exec_ () self . update_priority_groups ()","title":"add_priority_group()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.add_priority_layer","text":"add_priority_layer () Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 720 721 722 723 724 725 726 def add_priority_layer ( self ): \"\"\"Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. \"\"\" layer_dialog = PriorityLayerDialog () layer_dialog . exec_ () self . update_priority_layers ( update_groups = False )","title":"add_priority_layer()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.add_priority_layer_group","text":"add_priority_layer_group ( target_group = None , priority_layer = None ) Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. Parameters: Name Type Description Default target_group dict Priority group where layer will be added to None priority_layer dict Priority weighting layer to be added None Source code in src/cplus_plugin/gui/qgis_cplus_main.py 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 def add_priority_layer_group ( self , target_group = None , priority_layer = None ): \"\"\"Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. :param target_group: Priority group where layer will be added to :type target_group: dict :param priority_layer: Priority weighting layer to be added :type priority_layer: dict \"\"\" selected_priority_layers = ( priority_layer or self . priority_layers_list . selectedItems () ) selected_priority_layers = ( [ selected_priority_layers ] if not isinstance ( selected_priority_layers , list ) else selected_priority_layers ) selected_group = target_group or self . priority_groups_list . currentItem () for selected_priority_layer in selected_priority_layers : if ( selected_group is not None and selected_group . parent () is None ) and selected_priority_layer is not None : children = selected_group . takeChildren () item_found = False text = selected_priority_layer . data ( QtCore . Qt . DisplayRole ) for child in children : if child . text ( 0 ) == text : item_found = True break selected_group . addChildren ( children ) if not item_found : selected_group . setExpanded ( True ) item = QtWidgets . QTreeWidgetItem ( selected_group ) item . setText ( 0 , text ) group_widget = self . priority_groups_list . itemWidget ( selected_group , 0 ) layer_id = selected_priority_layer . data ( QtCore . Qt . UserRole ) priority_layer = settings_manager . get_priority_layer ( layer_id ) item . setData ( 0 , QtCore . Qt . UserRole , priority_layer . get ( USER_DEFINED_ATTRIBUTE ), ) target_group_name = ( group_widget . group . get ( \"name\" ) if group_widget . group else None ) groups = priority_layer . get ( \"groups\" ) new_groups = [] group_found = False for group in groups : if target_group_name == group [ \"name\" ]: group_found = True new_group = settings_manager . find_group_by_name ( target_group_name ) else : new_group = group new_groups . append ( new_group ) if not group_found : searched_group = settings_manager . find_group_by_name ( target_group_name ) new_groups . append ( searched_group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer ) # Trigger check to enable/disable PWLs based on current extent self . on_extent_changed ( self . extent_box . outputExtent ())","title":"add_priority_layer_group()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.analysis_complete","text":"analysis_complete ( task , report_manager , progress_dialog ) Calls the responsible function for handling analysis results outputs Parameters: Name Type Description Default task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis reports required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def analysis_complete ( self , task , report_manager , progress_dialog ): \"\"\"Calls the responsible function for handling analysis results outputs :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis reports :type report_manager: ReportManager \"\"\" self . scenario_result = task . scenario_result self . scenario_results ( task , report_manager , progress_dialog )","title":"analysis_complete()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.cancel_processing_task","text":"cancel_processing_task () Cancels the current processing task. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1088 1089 1090 def cancel_processing_task ( self ): \"\"\"Cancels the current processing task.\"\"\" self . processing_cancelled = True","title":"cancel_processing_task()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.edit_priority_group","text":"edit_priority_group () Edits the current selected priority group and updates the group box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 def edit_priority_group ( self ): \"\"\"Edits the current selected priority group and updates the group box list.\"\"\" if self . priority_groups_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority group from the groups list.\" ), Qgis . Critical , ) return group_identifier = self . priority_groups_list . currentItem () . data ( 0 , QtCore . Qt . UserRole ) if group_identifier == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority groups for editing.\" ), Qgis . Critical , ) return group = settings_manager . get_priority_group ( group_identifier ) group_dialog = PriorityGroupDialog ( group ) group_dialog . exec_ () self . update_priority_groups ()","title":"edit_priority_group()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.edit_priority_layer","text":"edit_priority_layer () Edits the current selected priority layer and updates the layer box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 def edit_priority_layer ( self ): \"\"\"Edits the current selected priority layer and updates the layer box list.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority weighting layer from the layers list.\" ), Qgis . Critical , ) return layer_identifier = self . priority_layers_list . currentItem () . data ( QtCore . Qt . UserRole ) if layer_identifier == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . Critical , ) return self . _show_priority_layer_editor ( layer_identifier )","title":"edit_priority_layer()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.group_value_changed","text":"group_value_changed ( group_name , group_value ) Slot to handle priority group widget changes. Parameters: Name Type Description Default group_name str Group name required group_value int Group value required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 def group_value_changed ( self , group_name , group_value ): \"\"\"Slot to handle priority group widget changes. :param group_name: Group name :type group_name: str :param group_value: Group value :type group_value: int \"\"\" group = settings_manager . find_group_by_name ( group_name ) group [ \"value\" ] = group_value settings_manager . save_priority_group ( group ) for index in range ( self . priority_groups_list . topLevelItemCount ()): item = self . priority_groups_list . topLevelItem ( index ) for child_index in range ( item . childCount ()): child = item . child ( child_index ) layer = settings_manager . find_layer_by_name ( child . text ( 0 )) new_groups = [] for group in layer . get ( \"groups\" ): if group . get ( \"name\" ) == group_name : group [ \"value\" ] = group_value new_groups . append ( group ) layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( layer )","title":"group_value_changed()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.initialize_priority_layers","text":"initialize_priority_layers () Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def initialize_priority_layers ( self ): \"\"\"Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . UserRole , layer . get ( \"uuid\" )) if self . pwl_item_flags is None : self . pwl_item_flags = item . flags () self . priority_layers_list . addItem ( item ) list_items = [] items_only = [] stored_priority_groups = settings_manager . get_priority_groups () self . priority_groups_list . clear () for group in stored_priority_groups : group_widget = PriorityGroupWidget ( group , ) group_widget . input_value_changed . connect ( self . group_value_changed ) group_widget . slider_value_changed . connect ( self . group_value_changed ) self . priority_groups_widgets [ group [ \"name\" ]] = group_widget pw_layers = settings_manager . find_layers_by_group ( group [ \"name\" ]) item = QtWidgets . QTreeWidgetItem () item . setSizeHint ( 0 , group_widget . sizeHint ()) item . setExpanded ( True ) item . setData ( 0 , QtCore . Qt . UserRole , group . get ( \"uuid\" )) # Add priority layers into the group as a child items. item . setExpanded ( True ) if len ( pw_layers ) > 0 else None for layer in pw_layers : if item . parent () is None : layer_item = QtWidgets . QTreeWidgetItem ( item ) layer_item . setText ( 0 , layer . get ( \"name\" )) layer_item . setData ( 0 , QtCore . Qt . UserRole , layer . get ( USER_DEFINED_ATTRIBUTE ) ) list_items . append (( item , group_widget )) items_only . append ( item ) self . priority_groups_list . addTopLevelItems ( items_only ) for item in list_items : self . priority_groups_list . setItemWidget ( item [ 0 ], 0 , item [ 1 ]) # Trigger process to enable/disable PWLs based on current extents self . on_extent_changed ( self . extent_box . outputExtent ())","title":"initialize_priority_layers()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.main_task","text":"main_task () Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1081 1082 1083 1084 1085 1086 def main_task ( self ): \"\"\"Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. \"\"\" log ( \"Running from main task.\" )","title":"main_task()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.move_layer_to_group","text":"move_layer_to_group ( layer , group ) Moves a layer open in QGIS to another group. Parameters: Name Type Description Default layer QgsRasterLayer Raster layer to move required group QgsLayerTreeGroup Group to which the raster should be moved required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 def move_layer_to_group ( self , layer , group ) -> None : \"\"\"Moves a layer open in QGIS to another group. :param layer: Raster layer to move :type layer: QgsRasterLayer :param group: Group to which the raster should be moved :type group: QgsLayerTreeGroup \"\"\" if layer : instance_root = QgsProject . instance () . layerTreeRoot () layer = instance_root . findLayer ( layer . id ()) layer_clone = layer . clone () parent = layer . parent () group . insertChildNode ( 0 , layer_clone ) # Add to top of group parent . removeChildNode ( layer )","title":"move_layer_to_group()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_extent_changed","text":"on_extent_changed ( new_extent ) Slot raised when scenario extents have changed. Used to enable/disable default model items if they are within or outside the pilot AOI. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 def on_extent_changed ( self , new_extent : QgsRectangle ): \"\"\"Slot raised when scenario extents have changed. Used to enable/disable default model items if they are within or outside the pilot AOI. \"\"\" within_pilot_area = extent_within_pilot ( new_extent , self . extent_box . outputCrs ()) if not within_pilot_area : msg = tr ( \"Area of interest is outside the pilot area. Please use your \" \"own NCS pathways, implementation models and PWLs.\" ) self . show_message ( msg , Qgis . Info ) else : self . message_bar . clearWidgets () self . implementation_model_widget . enable_default_items ( within_pilot_area ) # Enable/disable PWL items for i in range ( self . priority_layers_list . count ()): pwl_item = self . priority_layers_list . item ( i ) uuid_str = pwl_item . data ( QtCore . Qt . UserRole ) if not uuid_str : continue pwl_uuid = uuid . UUID ( uuid_str ) pwl = settings_manager . get_priority_layer ( pwl_uuid ) if USER_DEFINED_ATTRIBUTE not in pwl : continue is_user_defined = pwl . get ( USER_DEFINED_ATTRIBUTE ) if is_user_defined : continue if within_pilot_area : pwl_item . setFlags ( self . pwl_item_flags ) else : pwl_item . setFlags ( QtCore . Qt . NoItemFlags ) # Enable/disable PWL items already defined under the priority groups for i in range ( self . priority_groups_list . topLevelItemCount ()): group_item = self . priority_groups_list . topLevelItem ( i ) for c in range ( group_item . childCount ()): pwl_tree_item = group_item . child ( c ) is_user_defined = pwl_tree_item . data ( 0 , QtCore . Qt . UserRole ) if is_user_defined : continue if within_pilot_area : pwl_tree_item . setFlags ( self . pwl_item_flags ) else : pwl_tree_item . setFlags ( QtCore . Qt . NoItemFlags )","title":"on_extent_changed()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_ncs_pathways_reloaded","text":"on_ncs_pathways_reloaded () Slot raised when NCS pathways have been reloaded in the view. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 382 383 384 385 386 387 def on_ncs_pathways_reloaded ( self ): \"\"\"Slot raised when NCS pathways have been reloaded in the view.\"\"\" within_pilot_area = extent_within_pilot ( self . extent_box . outputExtent (), self . extent_box . outputCrs () ) self . implementation_model_widget . enable_default_items ( within_pilot_area )","title":"on_ncs_pathways_reloaded()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_progress_dialog_cancelled","text":"on_progress_dialog_cancelled () Slot raised when analysis has been cancelled in progress dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1657 1658 1659 1660 def on_progress_dialog_cancelled ( self ): \"\"\"Slot raised when analysis has been cancelled in progress dialog.\"\"\" if not self . run_scenario_btn . isEnabled (): self . run_scenario_btn . setEnabled ( True )","title":"on_progress_dialog_cancelled()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_report_error","text":"on_report_error ( progress_dialog , message ) Slot raised when report task error has occured. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 def on_report_error ( self , progress_dialog , message : str ): \"\"\"Slot raised when report task error has occured. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog \"\"\" progress_dialog . report_running = True progress_dialog . change_status_message ( tr ( \"Error generating report, see logs for more info.\" ) ) log ( message ) self . run_scenario_btn . setEnabled ( True )","title":"on_report_error()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_report_finished","text":"on_report_finished ( progress_dialog , scenario_id ) Slot raised when report task has finished. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required scenario_id str Scenario analysis id required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 def on_report_finished ( self , progress_dialog , scenario_id : str ): \"\"\"Slot raised when report task has finished. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param scenario_id: Scenario analysis id :type scenario_id: str \"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return progress_dialog . set_report_complete () progress_dialog . change_status_message ( tr ( \"Report generation complete\" )) self . run_scenario_btn . setEnabled ( True )","title":"on_report_finished()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_report_running","text":"on_report_running ( progress_dialog , scenario_id ) Slot raised when report task has started. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required scenario_id str Scenario analysis id required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 def on_report_running ( self , progress_dialog , scenario_id : str ): \"\"\"Slot raised when report task has started. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param scenario_id: Scenario analysis id :type scenario_id: str \"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return progress_dialog . update_progress_bar ( 0 ) progress_dialog . report_running = True progress_dialog . change_status_message ( tr ( \"Generating report for the analysis output\" ) )","title":"on_report_running()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_reporting_progress_changed","text":"on_reporting_progress_changed ( progress_dialog , progress ) Slot raised when the reporting progress has changed. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required progress float Analysis progress value between 0 and 100 required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 def on_reporting_progress_changed ( self , progress_dialog , progress : float ): \"\"\"Slot raised when the reporting progress has changed. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param progress: Analysis progress value between 0 and 100 :type progress: float \"\"\" progress_dialog . update_progress_bar ( progress )","title":"on_reporting_progress_changed()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_tab_step_changed","text":"on_tab_step_changed ( index ) Slot raised when the current tab changes. Parameters: Name Type Description Default index int Zero-based index position of new current tab required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 def on_tab_step_changed ( self , index : int ): \"\"\"Slot raised when the current tab changes. :param index: Zero-based index position of new current tab :type index: int \"\"\" if index == 1 : self . implementation_model_widget . can_show_error_messages = True self . implementation_model_widget . load () elif index == 2 : # Validate implementation model selection selected_implementation_models = ( self . implementation_model_widget . selected_im_items () ) if len ( selected_implementation_models ) == 0 : msg = self . tr ( \"Please select at least one implementation model.\" ) self . show_message ( msg ) self . tab_widget . setCurrentIndex ( 1 ) else : self . message_bar . clearWidgets ()","title":"on_tab_step_changed()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.open_help","text":"open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/qgis_cplus_main.py 649 650 651 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.open_settings","text":"open_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1505 1506 1507 def open_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE )","title":"open_settings()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.post_analysis","text":"post_analysis ( scenario_result , task , report_manager , progress_dialog ) Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the implementation models to the canvas with styling. Adds each IMs pathways to the canvas. Parameters: Name Type Description Default scenario_result ScenarioResult ScenarioResult of output results required task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis reports required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 def post_analysis ( self , scenario_result , task , report_manager , progress_dialog ): \"\"\"Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the implementation models to the canvas with styling. Adds each IMs pathways to the canvas. :param scenario_result: ScenarioResult of output results :type scenario_result: ScenarioResult :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis reports :type report_manager: ReportManager \"\"\" # If the processing were stopped, no file will be added if not self . processing_cancelled : list_models = scenario_result . scenario . models raster = scenario_result . analysis_output [ \"OUTPUT\" ] im_weighted_dir = os . path . join ( os . path . dirname ( raster ), \"weighted_ims\" ) scenario_name = scenario_result . scenario . name qgis_instance = QgsProject . instance () instance_root = qgis_instance . layerTreeRoot () # Check if there are other groups for the scenario # and assign a suffix. counter = 1 group_name = scenario_name # Control to prevent infinite loop max_limit = 100 while True and counter <= max_limit : scenario_grp = instance_root . findGroup ( group_name ) if scenario_grp is None : break group_name = f \" { scenario_name } { counter !s} \" counter += 1 # Groups scenario_group = instance_root . insertGroup ( 0 , group_name ) im_group = scenario_group . addGroup ( tr ( IM_GROUP_LAYER_NAME )) im_weighted_group = ( scenario_group . addGroup ( tr ( IM_WEIGHTED_GROUP_NAME )) if os . path . exists ( im_weighted_dir ) else None ) pathways_group = scenario_group . addGroup ( tr ( NCS_PATHWAYS_GROUP_LAYER_NAME )) # Group settings im_group . setExpanded ( False ) im_weighted_group . setExpanded ( False ) if im_weighted_group else None pathways_group . setExpanded ( False ) pathways_group . setItemVisibilityCheckedRecursive ( False ) # Add scenario result layer to the canvas with styling layer_file = scenario_result . analysis_output . get ( \"OUTPUT\" ) layer_name = ( f \" { SCENARIO_OUTPUT_LAYER_NAME } _\" f ' { datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' ) scenario_result . output_layer_name = layer_name layer = QgsRasterLayer ( layer_file , layer_name , QGIS_GDAL_PROVIDER ) scenario_layer = qgis_instance . addMapLayer ( layer ) # Scenario result layer styling renderer = self . style_models_layer ( layer , task . analysis_weighted_ims ) layer . setRenderer ( renderer ) layer . triggerRepaint () \"\"\"A workaround to add a layer to a group. Adding it using group.insertChildNode or group.addLayer causes issues, but adding to the root is fine. This approach adds it to the root, and then moves it to the group. \"\"\" self . move_layer_to_group ( scenario_layer , scenario_group ) # Add implementation models and pathways im_index = 0 for im in list_models : im_name = im . name im_layer = QgsRasterLayer ( im . path , im . name ) im_layer . setCustomProperty ( MODEL_IDENTIFIER_PROPERTY , str ( im . uuid )) list_pathways = im . pathways # Add IM layer with styling, if available if im_layer : renderer = self . style_model_layer ( im_layer , im ) added_im_layer = qgis_instance . addMapLayer ( im_layer ) self . move_layer_to_group ( added_im_layer , im_group ) im_layer . setRenderer ( renderer ) im_layer . triggerRepaint () # Add IM pathways if len ( list_pathways ) > 0 : # im_pathway_group = pathways_group.addGroup(im_name) im_pathway_group = pathways_group . insertGroup ( im_index , im_name ) im_pathway_group . setExpanded ( False ) pw_index = 0 for pathway in list_pathways : try : # pathway_name = pathway.name pathway_layer = pathway . to_map_layer () added_pw_layer = qgis_instance . addMapLayer ( pathway_layer ) self . move_layer_to_group ( added_pw_layer , im_pathway_group ) pathway_layer . triggerRepaint () pw_index = pw_index + 1 except Exception as err : self . show_message ( tr ( \"An error occurred loading a pathway, \" \"check logs for more information\" ), level = Qgis . Info , ) log ( tr ( \"An error occurred loading a pathway, \" 'scenario analysis, error message \" {} \"' . format ( err ) ) ) im_index = im_index + 1 weighted_ims = task . analysis_weighted_ims if task is not None else [] for model in weighted_ims : weighted_im_path = model . path weighted_im_name = Path ( weighted_im_path ) . stem if not weighted_im_path . endswith ( \".tif\" ): continue im_weighted_layer = QgsRasterLayer ( weighted_im_path , weighted_im_name , QGIS_GDAL_PROVIDER ) # Set UUID for easier retrieval im_weighted_layer . setCustomProperty ( MODEL_IDENTIFIER_PROPERTY , str ( model . uuid ) ) renderer = self . style_model_layer ( im_weighted_layer , model ) im_weighted_layer . setRenderer ( renderer ) im_weighted_layer . triggerRepaint () added_im_weighted_layer = qgis_instance . addMapLayer ( im_weighted_layer ) self . move_layer_to_group ( added_im_weighted_layer , im_weighted_group ) # Initiate report generation self . run_report ( progress_dialog , report_manager ) else : # Reinitializes variables if processing were cancelled by the user # Not doing this breaks the processing if a user tries to run # the processing after cancelling or if the processing fails self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext ()","title":"post_analysis()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.prepare_extent_box","text":"prepare_extent_box () Configure the spatial extent box with the initial settings. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 def prepare_extent_box ( self ): \"\"\"Configure the spatial extent box with the initial settings.\"\"\" self . extent_box . setOutputCrs ( QgsCoordinateReferenceSystem ( \"EPSG:4326\" )) map_canvas = iface . mapCanvas () self . extent_box . setCurrentExtent ( map_canvas . mapSettings () . destinationCrs () . bounds (), map_canvas . mapSettings () . destinationCrs (), ) self . extent_box . setOutputExtentFromCurrent () self . extent_box . setMapCanvas ( map_canvas ) extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) self . extent_box . setOutputExtentFromUser ( default_extent , QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), )","title":"prepare_extent_box()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.prepare_input","text":"prepare_input () Initializes plugin input widgets Source code in src/cplus_plugin/gui/qgis_cplus_main.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def prepare_input ( self ): \"\"\"Initializes plugin input widgets\"\"\" self . prepare_extent_box () self . grid_layout = QtWidgets . QGridLayout () self . message_bar = QgsMessageBar () self . prepare_message_bar () self . progress_dialog = None self . scenario_directory = None self . help_btn . clicked . connect ( self . open_help ) self . pilot_area_btn . clicked . connect ( self . zoom_pilot_area ) self . run_scenario_btn . clicked . connect ( self . run_analysis ) self . options_btn . clicked . connect ( self . open_settings ) self . restore_scenario () self . scenario_name . textChanged . connect ( self . save_scenario ) self . scenario_description . textChanged . connect ( self . save_scenario ) self . extent_box . extentChanged . connect ( self . save_scenario ) # Monitors if current extents are within the pilot AOI self . extent_box . extentChanged . connect ( self . on_extent_changed ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) add_layer_icon = QtGui . QIcon ( ADD_LAYER_ICON_PATH ) self . layer_add_btn . setIcon ( add_layer_icon ) remove_layer_icon = QtGui . QIcon ( REMOVE_LAYER_ICON_PATH ) self . layer_remove_btn . setIcon ( remove_layer_icon ) self . layer_add_btn . clicked . connect ( self . add_priority_layer_group ) self . layer_remove_btn . clicked . connect ( self . remove_priority_layer_group ) # Priority groups buttons self . add_group_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . edit_group_btn . setIcon ( FileUtils . get_icon ( \"mActionToggleEditing.svg\" )) self . remove_group_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . add_group_btn . clicked . connect ( self . add_priority_group ) self . edit_group_btn . clicked . connect ( self . edit_priority_group ) self . remove_group_btn . clicked . connect ( self . remove_priority_group ) # Priority layers buttons self . add_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . edit_pwl_btn . setIcon ( FileUtils . get_icon ( \"mActionToggleEditing.svg\" )) self . remove_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . add_pwl_btn . clicked . connect ( self . add_priority_layer ) self . edit_pwl_btn . clicked . connect ( self . edit_priority_layer ) self . remove_pwl_btn . clicked . connect ( self . remove_priority_layer ) self . priority_layers_list . itemDoubleClicked . connect ( self . _on_double_click_priority_layer ) # Add priority groups list into the groups frame self . priority_groups_list = CustomTreeWidget () self . priority_groups_list . setHeaderHidden ( True ) self . priority_groups_list . setDragEnabled ( True ) self . priority_groups_list . setDragDropOverwriteMode ( True ) self . priority_groups_list . viewport () . setAcceptDrops ( True ) self . priority_groups_list . setDragDropMode ( QtWidgets . QAbstractItemView . DropOnly ) self . priority_groups_list . child_dragged_dropped . connect ( self . priority_groups_update ) layout = QtWidgets . QVBoxLayout () layout . setSpacing ( 0 ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) layout . addWidget ( self . priority_groups_list ) self . priority_groups_frame . setLayout ( layout ) # Scenario analysis variables self . analysis_scenario_name = None self . analysis_scenario_description = None self . analysis_extent = None self . analysis_implementation_models = None self . analysis_weighted_ims = [] self . analysis_priority_layers_groups = []","title":"prepare_input()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.prepare_message_bar","text":"prepare_message_bar () Initializes the widget message bar settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 794 795 796 797 798 799 800 801 802 def prepare_message_bar ( self ): \"\"\"Initializes the widget message bar settings\"\"\" self . message_bar . setSizePolicy ( QtWidgets . QSizePolicy . Minimum , QtWidgets . QSizePolicy . Fixed ) self . grid_layout . addWidget ( self . message_bar , 0 , 0 , 1 , 1 , alignment = QtCore . Qt . AlignTop ) self . dock_widget_contents . layout () . insertLayout ( 0 , self . grid_layout )","title":"prepare_message_bar()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.priority_groups_update","text":"priority_groups_update ( target_item , selected_items ) Updates the priority groups list item with the passed selected layer items. Parameters: Name Type Description Default target_item QTreeWidgetItem The priority group tree widget item that is to be updated required selected_items list Priority layers items from the list widget required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def priority_groups_update ( self , target_item , selected_items ): \"\"\"Updates the priority groups list item with the passed selected layer items. :param target_item: The priority group tree widget item that is to be updated :type target_item: QTreeWidgetItem :param selected_items: Priority layers items from the list widget :type selected_items: list \"\"\" self . priority_groups_list . setCurrentItem ( target_item ) for item in selected_items : self . add_priority_layer_group ( target_item , item )","title":"priority_groups_update()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.remove_priority_group","text":"remove_priority_group () Removes the current active priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 def remove_priority_group ( self ): \"\"\"Removes the current active priority group.\"\"\" if self . priority_groups_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority group from the groups list\" ), Qgis . Critical , ) return group_identifier = self . priority_groups_list . currentItem () . data ( 0 , QtCore . Qt . UserRole ) group = settings_manager . get_priority_group ( group_identifier ) current_text = group . get ( \"name\" ) if group_identifier is None or group_identifier == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority group for editing.\" ), Qgis . Critical , ) return reply = QtWidgets . QMessageBox . warning ( self , tr ( \"QGIS CPLUS PLUGIN\" ), tr ( 'Remove the priority group \" {} \"?' ) . format ( current_text ), QtWidgets . QMessageBox . Yes , QtWidgets . QMessageBox . No , ) if reply == QtWidgets . QMessageBox . Yes : settings_manager . delete_priority_group ( group_identifier ) self . update_priority_groups ()","title":"remove_priority_group()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.remove_priority_layer","text":"remove_priority_layer () Removes the current active priority layer. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 def remove_priority_layer ( self ): \"\"\"Removes the current active priority layer.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority \" \"weighting layer from the layers list.\" ), Qgis . Critical , ) return current_text = self . priority_layers_list . currentItem () . data ( QtCore . Qt . DisplayRole ) if current_text == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . Critical , ) return layer = settings_manager . find_layer_by_name ( current_text ) reply = QtWidgets . QMessageBox . warning ( self , tr ( \"QGIS CPLUS PLUGIN\" ), tr ( 'Remove the priority layer \" {} \"?' ) . format ( current_text ), QtWidgets . QMessageBox . Yes , QtWidgets . QMessageBox . No , ) if reply == QtWidgets . QMessageBox . Yes : settings_manager . delete_priority_layer ( layer . get ( \"uuid\" )) self . update_priority_layers ( update_groups = False )","title":"remove_priority_layer()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.remove_priority_layer_group","text":"remove_priority_layer_group () Remove the current select priority layer from the current priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 def remove_priority_layer_group ( self ): \"\"\"Remove the current select priority layer from the current priority group.\"\"\" selected_group = self . priority_groups_list . currentItem () parent_item = selected_group . parent () if selected_group is not None else None if parent_item : priority_layer = settings_manager . find_layer_by_name ( selected_group . text ( 0 )) group_widget = self . priority_groups_list . itemWidget ( parent_item , 0 ) groups = priority_layer . get ( \"groups\" ) new_groups = [] for group in groups : if group . get ( \"name\" ) == group_widget . group . get ( \"name\" ): continue new_groups . append ( group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer ) parent_item . removeChild ( selected_group )","title":"remove_priority_layer_group()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.report_job_is_for_current_scenario","text":"report_job_is_for_current_scenario ( scenario_id ) Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. Parameters: Name Type Description Default scenario_id str Scenario identifier usually from a signal raised by the report manager. required Returns: Type Description bool True if the scenario identifier matches the current scenario object in the results, else False. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 def report_job_is_for_current_scenario ( self , scenario_id : str ) -> bool : \"\"\"Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. :param scenario_id: Scenario identifier usually from a signal raised by the report manager. :type scenario_id: str :returns: True if the scenario identifier matches the current scenario object in the results, else False. :rtype: bool \"\"\" if self . scenario_result is None : return False current_scenario = self . scenario_result . scenario if current_scenario is None : return False if str ( current_scenario . uuid ) == scenario_id : return True return False","title":"report_job_is_for_current_scenario()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.reset_reporting_feedback","text":"reset_reporting_feedback ( progress_dialog ) Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required Returns: Type Description QgsFeedback Feedback instance to be used in storing processing status details. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 def reset_reporting_feedback ( self , progress_dialog ): \"\"\"Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :returns reporting_feedback: Feedback instance to be used in storing processing status details. :rtype reporting_feedback: QgsFeedback \"\"\" progress_changed = partial ( self . on_reporting_progress_changed , progress_dialog ) reporting_feedback = QgsFeedback ( self ) reporting_feedback . progressChanged . connect ( progress_changed ) return reporting_feedback","title":"reset_reporting_feedback()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.restore_scenario","text":"restore_scenario () Update the first tab input with the last scenario details Source code in src/cplus_plugin/gui/qgis_cplus_main.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def restore_scenario ( self ): \"\"\"Update the first tab input with the last scenario details\"\"\" scenario_name = settings_manager . get_value ( Settings . SCENARIO_NAME ) scenario_description = settings_manager . get_value ( Settings . SCENARIO_DESCRIPTION ) extent = settings_manager . get_value ( Settings . SCENARIO_EXTENT ) self . scenario_name . setText ( scenario_name ) if scenario_name is not None else None self . scenario_description . setText ( scenario_description ) if scenario_description is not None else None if extent is not None : extent_rectangle = QgsRectangle ( float ( extent [ 0 ]), float ( extent [ 2 ]), float ( extent [ 1 ]), float ( extent [ 3 ]) ) self . extent_box . setOutputExtentFromUser ( extent_rectangle , QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), )","title":"restore_scenario()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_analysis","text":"run_analysis () Runs the plugin analysis Creates new QgsTask, progress dialog and report manager for each new scenario analysis. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 def run_analysis ( self ): \"\"\"Runs the plugin analysis Creates new QgsTask, progress dialog and report manager for each new scenario analysis. \"\"\" extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) passed_extent = self . extent_box . outputExtent () contains = default_extent == passed_extent or default_extent . contains ( passed_extent ) self . analysis_scenario_name = self . scenario_name . text () self . analysis_scenario_description = self . scenario_description . text () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () for group in settings_manager . get_priority_groups (): group_layer_dict = { \"name\" : group . get ( \"name\" ), \"value\" : group . get ( \"value\" ), \"layers\" : [], } for layer in settings_manager . get_priority_layers (): pwl_items = self . priority_layers_list . findItems ( layer . get ( \"name\" ), QtCore . Qt . MatchExactly ) if len ( pwl_items ) > 0 : # Exclude adding the PWL since its for a disabled default # item outside the pilot AOI. if pwl_items [ 0 ] . flags () == QtCore . Qt . NoItemFlags : continue group_names = [ group . get ( \"name\" ) for group in layer . get ( \"groups\" , [])] if group . get ( \"name\" ) in group_names : group_layer_dict [ \"layers\" ] . append ( layer . get ( \"name\" )) self . analysis_priority_layers_groups . append ( group_layer_dict ) self . analysis_implementation_models = [ item . implementation_model for item in self . implementation_model_widget . selected_im_items () if item . isEnabled () ] self . analysis_weighted_ims = [] base_dir = settings_manager . get_value ( Settings . BASE_DIR ) if self . analysis_scenario_name == \"\" or self . analysis_scenario_name is None : self . show_message ( tr ( f \"Scenario name cannot be blank.\" ), level = Qgis . Critical , ) return if ( self . analysis_scenario_description == \"\" or self . analysis_scenario_description is None ): self . show_message ( tr ( f \"Scenario description cannot be blank.\" ), level = Qgis . Critical , ) return if ( self . analysis_implementation_models == [] or self . analysis_implementation_models is None ): self . show_message ( tr ( \"Select at least one implementation models from step two.\" ), level = Qgis . Critical , ) return if not contains : self . show_message ( tr ( f \"Selected area of interest is outside the pilot area.\" ), level = Qgis . Info , ) default_ext = ( f \" { default_extent . xMinimum () } , { default_extent . xMaximum () } ,\" f \" { default_extent . yMinimum () } , { default_extent . yMaximum () } \" ) log ( f \"Outside the pilot area, passed extent \" f \" { passed_extent } \" f \"default extent { default_ext } \" ) if base_dir is None : self . show_message ( tr ( f \"Plugin base data directory is not set! \" f \"Go to plugin settings in order to set it.\" ), level = Qgis . Critial , ) return self . analysis_extent = SpatialExtent ( bbox = [ passed_extent . xMinimum (), passed_extent . xMaximum (), passed_extent . yMinimum (), passed_extent . yMaximum (), ] ) try : self . run_scenario_btn . setEnabled ( False ) scenario = Scenario ( uuid = uuid . uuid4 (), name = self . analysis_scenario_name , description = self . analysis_scenario_description , extent = self . analysis_extent , models = self . analysis_implementation_models , weighted_models = [], priority_layer_groups = self . analysis_priority_layers_groups , ) self . processing_cancelled = False # Creates and opens the progress dialog for the analysis progress_dialog = ProgressDialog ( minimum = 0 , maximum = 100 , main_widget = self , scenario_id = str ( scenario . uuid ), scenario_name = self . analysis_scenario_name , ) progress_dialog . analysis_cancelled . connect ( self . on_progress_dialog_cancelled ) progress_dialog . run_dialog () progress_dialog . change_status_message ( tr ( \"Raster calculation for models pathways\" ) ) selected_pathway = None pathway_found = False for model in self . analysis_implementation_models : if pathway_found : break for pathway in model . pathways : if pathway is not None : pathway_found = True selected_pathway = pathway break extent_box = QgsRectangle ( float ( self . analysis_extent . bbox [ 0 ]), float ( self . analysis_extent . bbox [ 2 ]), float ( self . analysis_extent . bbox [ 1 ]), float ( self . analysis_extent . bbox [ 3 ]), ) selected_pathway_layer = QgsRasterLayer ( selected_pathway . path , selected_pathway . name ) source_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) if selected_pathway_layer . crs () is not None : destination_crs = selected_pathway_layer . crs () else : destination_crs = QgsProject . instance () . crs () transformed_extent = self . transform_extent ( extent_box , source_crs , destination_crs ) self . analysis_extent . bbox = [ transformed_extent . xMinimum (), transformed_extent . xMaximum (), transformed_extent . yMinimum (), transformed_extent . yMaximum (), ] analysis_task = ScenarioAnalysisTask ( self . analysis_scenario_name , self . analysis_scenario_description , self . analysis_implementation_models , self . analysis_priority_layers_groups , self . analysis_extent , scenario , ) progress_changed = partial ( self . update_progress_bar , progress_dialog ) analysis_task . custom_progress_changed . connect ( progress_changed ) status_message_changed = partial ( self . update_progress_dialog , progress_dialog ) analysis_task . status_message_changed . connect ( status_message_changed ) analysis_task . info_message_changed . connect ( self . show_message ) progress_dialog . analysis_task = analysis_task progress_dialog . scenario_id = str ( scenario . uuid ) report_running = partial ( self . on_report_running , progress_dialog ) report_error = partial ( self . on_report_error , progress_dialog ) report_finished = partial ( self . on_report_finished , progress_dialog ) # Report manager scenario_report_manager = report_manager scenario_report_manager . generate_started . connect ( report_running ) scenario_report_manager . generate_error . connect ( report_error ) scenario_report_manager . generate_completed . connect ( report_finished ) analysis_complete = partial ( self . analysis_complete , analysis_task , scenario_report_manager , progress_dialog , ) analysis_task . taskCompleted . connect ( analysis_complete ) analysis_task . taskTerminated . connect ( self . task_terminated ) QgsApplication . taskManager () . addTask ( analysis_task ) except Exception as err : self . show_message ( tr ( \"An error occurred when preparing analysis task\" ), level = Qgis . Info , ) log ( tr ( \"An error occurred when preparing analysis task\" ', error message \" {} \"' . format ( err ) ) )","title":"run_analysis()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_report","text":"run_report ( progress_dialog , report_manager ) Run report generation. This should be called after the analysis is complete. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required report_manager ReportManager Report manager used to generate analysis reports required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 def run_report ( self , progress_dialog , report_manager ): \"\"\"Run report generation. This should be called after the analysis is complete. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param report_manager: Report manager used to generate analysis reports :type report_manager: ReportManager \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return if self . scenario_result is None : log ( \"Cannot run report generation, scenario result is not defined\" , info = False , ) return reporting_feedback = self . reset_reporting_feedback ( progress_dialog ) self . reporting_feedback = reporting_feedback submit_result = report_manager . generate ( self . scenario_result , reporting_feedback ) if not submit_result . status : msg = self . tr ( \"Unable to submit report request for scenario\" ) self . show_message ( f \" { msg } { self . scenario_result . scenario . name } .\" )","title":"run_report()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.save_scenario","text":"save_scenario () Save current scenario details into settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def save_scenario ( self ): \"\"\"Save current scenario details into settings\"\"\" scenario_name = self . scenario_name . text () scenario_description = self . scenario_description . text () extent = self . extent_box . outputExtent () extent_box = [ extent . xMinimum (), extent . xMaximum (), extent . yMinimum (), extent . yMaximum (), ] settings_manager . set_value ( Settings . SCENARIO_NAME , scenario_name ) settings_manager . set_value ( Settings . SCENARIO_DESCRIPTION , scenario_description ) settings_manager . set_value ( Settings . SCENARIO_EXTENT , extent_box )","title":"save_scenario()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.scenario_results","text":"scenario_results ( task , report_manager , progress_dialog ) Called when the task ends. Sets the progress bar to 100 if it finished. Parameters: Name Type Description Default task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis reports required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 def scenario_results ( self , task , report_manager , progress_dialog ): \"\"\"Called when the task ends. Sets the progress bar to 100 if it finished. :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis reports :type report_manager: ReportManager \"\"\" if task . output is not None : self . update_progress_bar ( progress_dialog , 100 ) self . scenario_result . analysis_output = task . output self . scenario_result . state = ScenarioState . FINISHED self . post_analysis ( self . scenario_result , task , report_manager , progress_dialog ) else : status_message = \"No valid output from the processing results.\" task . set_status_message ( status_message ) log ( f \"No valid output from the processing results.\" )","title":"scenario_results()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.show_message","text":"show_message ( message , level = Qgis . Warning ) Shows message on the main widget message bar. Parameters: Name Type Description Default message str Text message required level Qgis.MessageLevel Message level type Warning Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 def show_message ( self , message , level = Qgis . Warning ): \"\"\"Shows message on the main widget message bar. :param message: Text message :type message: str :param level: Message level type :type level: Qgis.MessageLevel \"\"\" self . message_bar . clearWidgets () self . message_bar . pushMessage ( message , level = level )","title":"show_message()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.style_model_layer","text":"style_model_layer ( layer , model ) Applies the styling to the layer that contains the passed implementation model name. Parameters: Name Type Description Default layer QgsRasterLayer Raster layer to which to apply the symbology required model ImplementationModel Implementation model required Returns: Type Description QgsSingleBandPseudoColorRenderer Renderer for the symbology. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 def style_model_layer ( self , layer , model ): \"\"\"Applies the styling to the layer that contains the passed implementation model name. :param layer: Raster layer to which to apply the symbology :type layer: QgsRasterLayer :param model: Implementation model :type model: ImplementationModel :returns: Renderer for the symbology. :rtype: QgsSingleBandPseudoColorRenderer \"\"\" # Retrieves a build-in QGIS color ramp color_ramp = model . model_color_ramp () stats = layer . dataProvider () . bandStatistics ( 1 ) renderer = QgsSingleBandPseudoColorRenderer ( layer . dataProvider (), 1 ) renderer . setClassificationMin ( stats . minimumValue ) renderer . setClassificationMax ( stats . maximumValue ) renderer . createShader ( color_ramp , QgsColorRampShader . Interpolated , QgsColorRampShader . Continuous ) return renderer","title":"style_model_layer()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.style_models_layer","text":"style_models_layer ( layer , models ) Applies the styling to the passed layer that contains the passed list of models. Parameters: Name Type Description Default layer QgsRasterLayer Layer to be styled required models list List which contains the implementation models that were passed to the highest position analysis tool required Returns: Type Description QgsPalettedRasterRenderer Renderer for the symbology. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 def style_models_layer ( self , layer , models ): \"\"\"Applies the styling to the passed layer that contains the passed list of models. :param layer: Layer to be styled :type layer: QgsRasterLayer :param models: List which contains the implementation models that were passed to the highest position analysis tool :type models: list :returns: Renderer for the symbology. :rtype: QgsPalettedRasterRenderer \"\"\" area_classes = [] for model in models : im_name = model . name raster_val = model . style_pixel_value color = model . scenario_fill_symbol () . color () color_ramp_shader = QgsColorRampShader . ColorRampItem ( float ( raster_val ), QtGui . QColor ( color ), im_name ) area_classes . append ( color_ramp_shader ) class_data = QgsPalettedRasterRenderer . colorTableToClassData ( area_classes ) renderer = QgsPalettedRasterRenderer ( layer . dataProvider (), 1 , class_data ) return renderer","title":"style_models_layer()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.task_terminated","text":"task_terminated () Handles logging of the scenario analysis task status after it has been terminated. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1044 1045 1046 1047 1048 def task_terminated ( self ): \"\"\"Handles logging of the scenario analysis task status after it has been terminated. \"\"\" log ( f \"Main task terminated\" )","title":"task_terminated()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.transform_extent","text":"transform_extent ( extent , source_crs , dest_crs ) Transforms the passed extent into the destination crs :param extent: Target extent Parameters: Name Type Description Default source_crs QgsCoordinateReferenceSystem Source CRS of the passed extent required dest_crs QgsCoordinateReferenceSystem Destination CRS required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 def transform_extent ( self , extent , source_crs , dest_crs ): \"\"\"Transforms the passed extent into the destination crs :param extent: Target extent :type extent: QgsRectangle :param source_crs: Source CRS of the passed extent :type source_crs: QgsCoordinateReferenceSystem :param dest_crs: Destination CRS :type dest_crs: QgsCoordinateReferenceSystem \"\"\" transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance ()) transformed_extent = transform . transformBoundingBox ( extent ) return transformed_extent","title":"transform_extent()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_message_bar","text":"update_message_bar ( message ) Changes the message in the message bar item. Parameters: Name Type Description Default message str Message to be updated required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1405 1406 1407 1408 1409 1410 1411 1412 def update_message_bar ( self , message ): \"\"\"Changes the message in the message bar item. :param message: Message to be updated :type message: str \"\"\" message_bar_item = self . message_bar . createMessage ( message ) self . message_bar . pushWidget ( message_bar_item , Qgis . Info )","title":"update_message_bar()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_priority_layers","text":"update_priority_layers ( update_groups = True ) Updates the priority weighting layers list in the UI. Parameters: Name Type Description Default update_groups bool Whether to update the priority groups list or not True Source code in src/cplus_plugin/gui/qgis_cplus_main.py 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 def update_priority_layers ( self , update_groups = True ): \"\"\"Updates the priority weighting layers list in the UI. :param update_groups: Whether to update the priority groups list or not :type update_groups: bool \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . UserRole , layer . get ( \"uuid\" )) self . priority_layers_list . addItem ( item ) if update_groups : for index in range ( self . priority_groups_list . topLevelItemCount ()): group = self . priority_groups_list . topLevelItem ( index ) if group . text ( 0 ) in layer . get ( \"groups\" ): self . add_priority_layer_group ( group , item ) else : group_children = group . takeChildren () children = [] for child in group_children : if child . text ( 0 ) == layer . get ( \"name\" ): continue children . append ( child ) group . addChildren ( children ) # Trigger check to enable/disable PWLs self . on_extent_changed ( self . extent_box . outputExtent ())","title":"update_priority_layers()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_progress_bar","text":"update_progress_bar ( progress_dialog , value ) Sets the value of the progress bar Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 def update_progress_bar ( self , progress_dialog , value ): \"\"\"Sets the value of the progress bar :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param value: Value to be set on the progress bar :type value: float \"\"\" if progress_dialog and not self . processing_cancelled : try : progress_dialog . update_progress_bar ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False )","title":"update_progress_bar()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_progress_dialog","text":"update_progress_dialog ( progress_dialog , message = None ) Run report generation. This should be called after the analysis is complete. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required message ReportManager Report manager used to generate analysis reports None Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 def update_progress_dialog ( self , progress_dialog , message = None , ): \"\"\"Run report generation. This should be called after the analysis is complete. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param message: Report manager used to generate analysis reports :type message: ReportManager \"\"\" progress_dialog . change_status_message ( message ) if message is not None else None","title":"update_progress_dialog()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_pwl_layers","text":"update_pwl_layers ( notify = False ) Updates the priority layers path available in the store implementation models Parameters: Name Type Description Default notify bool Whether to show message to user about the update False Source code in src/cplus_plugin/gui/qgis_cplus_main.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def update_pwl_layers ( self , notify = False ): \"\"\"Updates the priority layers path available in the store implementation models :param notify: Whether to show message to user about the update :type notify: bool \"\"\" settings_manager . update_implementation_models () self . update_priority_layers () if notify : self . show_message ( tr ( \"Updated all the implementation models\" \" with their respective priority layers\" ), Qgis . Info , ) log ( tr ( \"Updated all the implementation models\" \" with their respective priority layers\" ) )","title":"update_pwl_layers()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.zoom_pilot_area","text":"zoom_pilot_area () Zoom the current main map canvas to the pilot area extent. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 def zoom_pilot_area ( self ): \"\"\"Zoom the current main map canvas to the pilot area extent.\"\"\" map_canvas = iface . mapCanvas () extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) zoom_extent = QgsRectangle ( extent_list [ 0 ] - 0.5 , extent_list [ 2 ], extent_list [ 1 ] + 0.5 , extent_list [ 3 ] ) canvas_crs = map_canvas . mapSettings () . destinationCrs () original_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) if canvas_crs . authid () != original_crs . authid (): zoom_extent = self . transform_extent ( zoom_extent , original_crs , canvas_crs ) default_extent = self . transform_extent ( default_extent , original_crs , canvas_crs ) aoi = QgsRubberBand ( iface . mapCanvas (), QgsWkbTypes . PolygonGeometry ) aoi . setFillColor ( QtGui . QColor ( 0 , 0 , 0 , 0 )) aoi . setStrokeColor ( QtGui . QColor ( 88 , 128 , 8 )) aoi . setWidth ( 3 ) aoi . setLineStyle ( QtCore . Qt . DashLine ) geom = QgsGeometry . fromRect ( default_extent ) aoi . setToGeometry ( geom , canvas_crs ) map_canvas . setExtent ( zoom_extent ) map_canvas . refresh ()","title":"zoom_pilot_area()"},{"location":"developer/api/gui/api_im_editor_dialog/","text":"Implementation model editor Dialog for creating or editing an implementation model. ImplementationModelEditorDialog ImplementationModelEditorDialog ( parent = None , implementation_model = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an implementation model entry. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , parent = None , implementation_model = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . style_btn . setSymbolType ( Qgis . SymbolType . Fill ) self . btn_color_ramp . setShowNull ( False ) self . btn_color_ramp . setRandomColorRamp () self . btn_color_ramp . setColorRampDialogTitle ( self . tr ( \"Set Color Ramp for Output Implementation Model\" ) ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_select_file . clicked . connect ( self . _on_select_file ) self . btn_help . clicked . connect ( self . open_help ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . cbo_layer . setFilters ( QgsMapLayerProxyModel . Filter . RasterLayer ) self . _edit_mode = False self . _layer = None self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _implementation_model = implementation_model if self . _implementation_model is not None : self . _edit_mode = True self . _layer = self . _implementation_model . to_map_layer () self . _update_controls () help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon ) self . txt_description . textChanged . connect ( self . description_changed ) # Hide map layer handling self . layer_gb . setVisible ( False ) edit_mode property edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing ImplementationModel object, else False if its creating a new object. implementation_model property implementation_model Returns a reference to the ImplementationModel object. Returns: Type Description ImplementationModel Reference to the ImplementationModel object. layer property layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set. description_changed description_changed () Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 124 125 126 127 128 129 130 131 132 def description_changed ( self ): \"\"\"Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description \"\"\" description = self . txt_description . toPlainText () if len ( description ) > 300 : self . txt_description . setPlainText ( description [: 300 ]) open_help open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 326 327 328 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) output_layer_color_ramp output_layer_color_ramp () Returns the selected color ramp. Returns: Type Description QgsColorRamp The color ramp selected by the user. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 316 317 318 319 320 321 322 323 324 def output_layer_color_ramp ( self ) -> QgsColorRamp : \"\"\"Returns the selected color ramp. :returns: The color ramp selected by the user. :rtype: QgsColorRamp \"\"\" color_ramp = self . btn_color_ramp . colorRamp () return color_ramp scenario_fill_symbol_layer scenario_fill_symbol_layer () Gets the first fill symbol layer in the symbol as set in the button. It checks to ensure that there is at least one fill symbol layer contained in the symbol. Returns: Type Description QgsFillSymbolLayer Fill symbol layer to be used in the implementation model. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 def scenario_fill_symbol_layer ( self ) -> QgsFillSymbolLayer : \"\"\"Gets the first fill symbol layer in the symbol as set in the button. It checks to ensure that there is at least one fill symbol layer contained in the symbol. :returns: Fill symbol layer to be used in the implementation model. :rtype: QgsFillSymbolLayer \"\"\" fill_symbol_layer = None btn_symbol = self . style_btn . symbol () for i in range ( btn_symbol . symbolLayerCount ()): symbol_layer = btn_symbol . symbolLayer ( i ) if isinstance ( symbol_layer , QgsFillSymbolLayer ): fill_symbol_layer = symbol_layer break return fill_symbol_layer validate validate () Validates if name has been specified. Returns: Type Description True True if the name have been set. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def validate ( self ) -> bool : \"\"\"Validates if name has been specified. :returns: True if the name have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"Implementation model name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . toPlainText (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False layer = self . _get_selected_map_layer () if layer and not layer . isValid (): msg = tr ( \"Map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False fill_symbol_layer = self . scenario_fill_symbol_layer () if fill_symbol_layer is None : msg = tr ( \"No fill symbol defined for the scenario layer.\" ) self . _show_warning_message ( msg ) status = False output_model_color_ramp = self . btn_color_ramp . colorRamp () if output_model_color_ramp is None : msg = tr ( \"No color ramp defined for the output model layer.\" ) self . _show_warning_message ( msg ) status = False return status","title":"Implementation model editor"},{"location":"developer/api/gui/api_im_editor_dialog/#implementation-model-editor","text":"Dialog for creating or editing an implementation model.","title":"Implementation model editor"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog","text":"ImplementationModelEditorDialog ( parent = None , implementation_model = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an implementation model entry. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , parent = None , implementation_model = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . style_btn . setSymbolType ( Qgis . SymbolType . Fill ) self . btn_color_ramp . setShowNull ( False ) self . btn_color_ramp . setRandomColorRamp () self . btn_color_ramp . setColorRampDialogTitle ( self . tr ( \"Set Color Ramp for Output Implementation Model\" ) ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_select_file . clicked . connect ( self . _on_select_file ) self . btn_help . clicked . connect ( self . open_help ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . cbo_layer . setFilters ( QgsMapLayerProxyModel . Filter . RasterLayer ) self . _edit_mode = False self . _layer = None self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _implementation_model = implementation_model if self . _implementation_model is not None : self . _edit_mode = True self . _layer = self . _implementation_model . to_map_layer () self . _update_controls () help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon ) self . txt_description . textChanged . connect ( self . description_changed ) # Hide map layer handling self . layer_gb . setVisible ( False )","title":"ImplementationModelEditorDialog"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.edit_mode","text":"edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing ImplementationModel object, else False if its creating a new object.","title":"edit_mode"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.implementation_model","text":"implementation_model Returns a reference to the ImplementationModel object. Returns: Type Description ImplementationModel Reference to the ImplementationModel object.","title":"implementation_model"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.layer","text":"layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set.","title":"layer"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.description_changed","text":"description_changed () Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 124 125 126 127 128 129 130 131 132 def description_changed ( self ): \"\"\"Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description \"\"\" description = self . txt_description . toPlainText () if len ( description ) > 300 : self . txt_description . setPlainText ( description [: 300 ])","title":"description_changed()"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.open_help","text":"open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 326 327 328 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help()"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.output_layer_color_ramp","text":"output_layer_color_ramp () Returns the selected color ramp. Returns: Type Description QgsColorRamp The color ramp selected by the user. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 316 317 318 319 320 321 322 323 324 def output_layer_color_ramp ( self ) -> QgsColorRamp : \"\"\"Returns the selected color ramp. :returns: The color ramp selected by the user. :rtype: QgsColorRamp \"\"\" color_ramp = self . btn_color_ramp . colorRamp () return color_ramp","title":"output_layer_color_ramp()"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.scenario_fill_symbol_layer","text":"scenario_fill_symbol_layer () Gets the first fill symbol layer in the symbol as set in the button. It checks to ensure that there is at least one fill symbol layer contained in the symbol. Returns: Type Description QgsFillSymbolLayer Fill symbol layer to be used in the implementation model. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 def scenario_fill_symbol_layer ( self ) -> QgsFillSymbolLayer : \"\"\"Gets the first fill symbol layer in the symbol as set in the button. It checks to ensure that there is at least one fill symbol layer contained in the symbol. :returns: Fill symbol layer to be used in the implementation model. :rtype: QgsFillSymbolLayer \"\"\" fill_symbol_layer = None btn_symbol = self . style_btn . symbol () for i in range ( btn_symbol . symbolLayerCount ()): symbol_layer = btn_symbol . symbolLayer ( i ) if isinstance ( symbol_layer , QgsFillSymbolLayer ): fill_symbol_layer = symbol_layer break return fill_symbol_layer","title":"scenario_fill_symbol_layer()"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.validate","text":"validate () Validates if name has been specified. Returns: Type Description True True if the name have been set. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def validate ( self ) -> bool : \"\"\"Validates if name has been specified. :returns: True if the name have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"Implementation model name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . toPlainText (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False layer = self . _get_selected_map_layer () if layer and not layer . isValid (): msg = tr ( \"Map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False fill_symbol_layer = self . scenario_fill_symbol_layer () if fill_symbol_layer is None : msg = tr ( \"No fill symbol defined for the scenario layer.\" ) self . _show_warning_message ( msg ) status = False output_model_color_ramp = self . btn_color_ramp . colorRamp () if output_model_color_ramp is None : msg = tr ( \"No color ramp defined for the output model layer.\" ) self . _show_warning_message ( msg ) status = False return status","title":"validate()"},{"location":"developer/api/gui/api_im_widget/","text":"Implementation model widget Container widget for configuring the implementation widget. ImplementationModelContainerWidget ImplementationModelContainerWidget ( parent = None , message_bar = None ) Bases: QWidget , WidgetUi Widget for configuring the implementation model. Source code in src/cplus_plugin/gui/implementation_model_widget.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , parent : QtWidgets . QWidget = None , message_bar : QgsMessageBar = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _message_bar = message_bar self . _items_loaded = False self . btn_add_one . setIcon ( FileUtils . get_icon ( \"cplus_right_arrow.svg\" )) self . btn_add_one . setToolTip ( self . tr ( \"Add selected NCS pathway\" )) self . btn_add_one . clicked . connect ( self . _on_add_ncs_pathway ) self . btn_add_all . setIcon ( FileUtils . get_icon ( \"cplus_double_right_arrows.svg\" )) self . btn_add_all . setToolTip ( self . tr ( \"Add all NCS pathways\" )) self . btn_add_all . clicked . connect ( self . _on_add_all_ncs_pathways ) # NCS pathway view self . ncs_pathway_view = NcsComponentWidget () self . ncs_pathway_view . title = self . tr ( \"NCS Pathways\" ) self . ncs_layout . addWidget ( self . ncs_pathway_view ) # Implementation model view self . implementation_model_view = ImplementationModelComponentWidget () self . ipm_layout . addWidget ( self . implementation_model_view ) self . implementation_model_view . title = self . tr ( \"Implementation Models\" ) settings_manager . settings_updated [ str , object ] . connect ( self . on_settings_changed ) self . ncs_pathway_view . ncs_pathway_updated . connect ( self . on_ncs_pathway_updated ) self . ncs_pathway_view . ncs_pathway_removed . connect ( self . on_ncs_pathway_removed ) self . ncs_pathway_view . items_reloaded . connect ( self . _on_ncs_pathways_reloaded ) self . load () enable_default_items enable_default_items ( enable ) Enable or disable default NCS pathway and implementation model items. Parameters: Name Type Description Default enable bool True to enable or False to disable default items. required Source code in src/cplus_plugin/gui/implementation_model_widget.py 137 138 139 140 141 142 143 144 145 146 147 def enable_default_items ( self , enable : bool ): \"\"\"Enable or disable default NCS pathway and implementation model items. :param enable: True to enable or False to disable default items. :type enable: bool \"\"\" if not self . _items_loaded : return self . ncs_pathway_view . enable_default_items ( enable ) self . implementation_model_view . enable_default_items ( enable ) implementation_models implementation_models () Returns the user-defined implementation models in the Implementation Models view. Returns: Type Description list User-defined implementation models for the current scenario. Source code in src/cplus_plugin/gui/implementation_model_widget.py 93 94 95 96 97 98 99 100 def implementation_models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns the user-defined implementation models in the Implementation Models view. :returns: User-defined implementation models for the current scenario. :rtype: list \"\"\" return self . implementation_model_view . models () is_valid is_valid () Check if the user input is valid. This checks if there is one implementation model defined with at least one NCS pathway under it. Returns: Type Description bool True if the implementation model configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. Source code in src/cplus_plugin/gui/implementation_model_widget.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def is_valid ( self ) -> bool : \"\"\"Check if the user input is valid. This checks if there is one implementation model defined with at least one NCS pathway under it. :returns: True if the implementation model configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. :rtype: bool \"\"\" implementation_models = self . implementation_models () if len ( implementation_models ) == 0 : return False status = False for im in implementation_models : if len ( im . pathways ) > 0 or im . to_map_layer () is not None : status = True break return status load load () Load NCS pathways and implementation models to the views. This function is idempotent as items will only be loaded once on initial call. Source code in src/cplus_plugin/gui/implementation_model_widget.py 74 75 76 77 78 79 80 81 82 83 def load ( self ): \"\"\"Load NCS pathways and implementation models to the views. This function is idempotent as items will only be loaded once on initial call. \"\"\" if not self . _items_loaded : self . ncs_pathway_view . load () self . implementation_model_view . load () self . _items_loaded = True ncs_pathways ncs_pathways () Gets the NCS pathway objects in the NCS Pathways view. Returns: Type Description list NCS pathway objects, both default and user-defined. Source code in src/cplus_plugin/gui/implementation_model_widget.py 85 86 87 88 89 90 91 def ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Gets the NCS pathway objects in the NCS Pathways view. :returns: NCS pathway objects, both default and user-defined. :rtype: list \"\"\" return self . ncs_pathway_view . pathways () on_ncs_pathway_removed on_ncs_pathway_removed ( ncs_pathway_uuid ) Slot raised when an NCS pathway has been removed. Parameters: Name Type Description Default ncs_pathway_uuid str Unique identified of the removed NCS pathway item. required Source code in src/cplus_plugin/gui/implementation_model_widget.py 129 130 131 132 133 134 135 def on_ncs_pathway_removed ( self , ncs_pathway_uuid : str ): \"\"\"Slot raised when an NCS pathway has been removed. :param ncs_pathway_uuid: Unique identified of the removed NCS pathway item. :type ncs_pathway_uuid: str \"\"\" self . implementation_model_view . remove_ncs_pathway_items ( ncs_pathway_uuid ) on_ncs_pathway_updated on_ncs_pathway_updated ( ncs_pathway ) Slot raised when an NCS pathway has been updated. Source code in src/cplus_plugin/gui/implementation_model_widget.py 125 126 127 def on_ncs_pathway_updated ( self , ncs_pathway : NcsPathway ): \"\"\"Slot raised when an NCS pathway has been updated.\"\"\" self . implementation_model_view . update_ncs_pathway_items ( ncs_pathway ) on_settings_changed on_settings_changed ( name , value ) Slot raised when settings has been changed. Parameters: Name Type Description Default name str Name of the setting that has changed. required value Any New value for the given settings name. required Source code in src/cplus_plugin/gui/implementation_model_widget.py 164 165 166 167 168 169 170 171 172 173 174 175 176 def on_settings_changed ( self , name : str , value : typing . Any ): \"\"\"Slot raised when settings has been changed. :param name: Name of the setting that has changed. :type name: str :param value: New value for the given settings name. :type value: Any \"\"\" # Update the NCS pathway and carbon layer paths when # BASE_DIR has been updated. if name == Settings . BASE_DIR . value : self . ncs_pathway_view . load () selected_im_items selected_im_items () Returns the currently selected instances of ImplementationModelItem. If an item is disabled then it will be excluded from the selection. Returns: Type Description list Currently selected instances of ImplementationModelItem or an empty list if there is no selection of IM items. Source code in src/cplus_plugin/gui/implementation_model_widget.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def selected_im_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns the currently selected instances of ImplementationModelItem. If an item is disabled then it will be excluded from the selection. :returns: Currently selected instances of ImplementationModelItem or an empty list if there is no selection of IM items. :rtype: list \"\"\" return [ item for item in self . selected_items () if isinstance ( item , ImplementationModelItem ) ] selected_items selected_items () Returns the selected model component item types which could be NCS pathway or implementation model items. If an item is disabled then it will be excluded from the selection. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. Returns: Type Description list Selected model component items. Source code in src/cplus_plugin/gui/implementation_model_widget.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected model component item types which could be NCS pathway or implementation model items. If an item is disabled then it will be excluded from the selection. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. :returns: Selected model component items. :rtype: list \"\"\" ref_items = self . implementation_model_view . selected_items () cloned_items = [] for ref_item in ref_items : if not ref_item . isEnabled (): continue clone_item = ref_item . clone () cloned_items . append ( clone_item ) return cloned_items show_message show_message ( message , level = Qgis . Warning ) Shows message if message bar has been specified. Parameters: Name Type Description Default message str Text to display in the message bar. required level Qgis.MessageLevel Message level type Warning Source code in src/cplus_plugin/gui/implementation_model_widget.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def show_message ( self , message , level = Qgis . Warning ): \"\"\"Shows message if message bar has been specified. :param message: Text to display in the message bar. :type message: str :param level: Message level type :type level: Qgis.MessageLevel \"\"\" if self . _message_bar is None : return self . _message_bar . clearWidgets () self . _message_bar . pushMessage ( message , level = level )","title":"Implementation model widget"},{"location":"developer/api/gui/api_im_widget/#implementation-model-widget","text":"Container widget for configuring the implementation widget.","title":"Implementation model widget"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget","text":"ImplementationModelContainerWidget ( parent = None , message_bar = None ) Bases: QWidget , WidgetUi Widget for configuring the implementation model. Source code in src/cplus_plugin/gui/implementation_model_widget.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , parent : QtWidgets . QWidget = None , message_bar : QgsMessageBar = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _message_bar = message_bar self . _items_loaded = False self . btn_add_one . setIcon ( FileUtils . get_icon ( \"cplus_right_arrow.svg\" )) self . btn_add_one . setToolTip ( self . tr ( \"Add selected NCS pathway\" )) self . btn_add_one . clicked . connect ( self . _on_add_ncs_pathway ) self . btn_add_all . setIcon ( FileUtils . get_icon ( \"cplus_double_right_arrows.svg\" )) self . btn_add_all . setToolTip ( self . tr ( \"Add all NCS pathways\" )) self . btn_add_all . clicked . connect ( self . _on_add_all_ncs_pathways ) # NCS pathway view self . ncs_pathway_view = NcsComponentWidget () self . ncs_pathway_view . title = self . tr ( \"NCS Pathways\" ) self . ncs_layout . addWidget ( self . ncs_pathway_view ) # Implementation model view self . implementation_model_view = ImplementationModelComponentWidget () self . ipm_layout . addWidget ( self . implementation_model_view ) self . implementation_model_view . title = self . tr ( \"Implementation Models\" ) settings_manager . settings_updated [ str , object ] . connect ( self . on_settings_changed ) self . ncs_pathway_view . ncs_pathway_updated . connect ( self . on_ncs_pathway_updated ) self . ncs_pathway_view . ncs_pathway_removed . connect ( self . on_ncs_pathway_removed ) self . ncs_pathway_view . items_reloaded . connect ( self . _on_ncs_pathways_reloaded ) self . load ()","title":"ImplementationModelContainerWidget"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.enable_default_items","text":"enable_default_items ( enable ) Enable or disable default NCS pathway and implementation model items. Parameters: Name Type Description Default enable bool True to enable or False to disable default items. required Source code in src/cplus_plugin/gui/implementation_model_widget.py 137 138 139 140 141 142 143 144 145 146 147 def enable_default_items ( self , enable : bool ): \"\"\"Enable or disable default NCS pathway and implementation model items. :param enable: True to enable or False to disable default items. :type enable: bool \"\"\" if not self . _items_loaded : return self . ncs_pathway_view . enable_default_items ( enable ) self . implementation_model_view . enable_default_items ( enable )","title":"enable_default_items()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.implementation_models","text":"implementation_models () Returns the user-defined implementation models in the Implementation Models view. Returns: Type Description list User-defined implementation models for the current scenario. Source code in src/cplus_plugin/gui/implementation_model_widget.py 93 94 95 96 97 98 99 100 def implementation_models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns the user-defined implementation models in the Implementation Models view. :returns: User-defined implementation models for the current scenario. :rtype: list \"\"\" return self . implementation_model_view . models ()","title":"implementation_models()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.is_valid","text":"is_valid () Check if the user input is valid. This checks if there is one implementation model defined with at least one NCS pathway under it. Returns: Type Description bool True if the implementation model configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. Source code in src/cplus_plugin/gui/implementation_model_widget.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def is_valid ( self ) -> bool : \"\"\"Check if the user input is valid. This checks if there is one implementation model defined with at least one NCS pathway under it. :returns: True if the implementation model configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. :rtype: bool \"\"\" implementation_models = self . implementation_models () if len ( implementation_models ) == 0 : return False status = False for im in implementation_models : if len ( im . pathways ) > 0 or im . to_map_layer () is not None : status = True break return status","title":"is_valid()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.load","text":"load () Load NCS pathways and implementation models to the views. This function is idempotent as items will only be loaded once on initial call. Source code in src/cplus_plugin/gui/implementation_model_widget.py 74 75 76 77 78 79 80 81 82 83 def load ( self ): \"\"\"Load NCS pathways and implementation models to the views. This function is idempotent as items will only be loaded once on initial call. \"\"\" if not self . _items_loaded : self . ncs_pathway_view . load () self . implementation_model_view . load () self . _items_loaded = True","title":"load()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.ncs_pathways","text":"ncs_pathways () Gets the NCS pathway objects in the NCS Pathways view. Returns: Type Description list NCS pathway objects, both default and user-defined. Source code in src/cplus_plugin/gui/implementation_model_widget.py 85 86 87 88 89 90 91 def ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Gets the NCS pathway objects in the NCS Pathways view. :returns: NCS pathway objects, both default and user-defined. :rtype: list \"\"\" return self . ncs_pathway_view . pathways ()","title":"ncs_pathways()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.on_ncs_pathway_removed","text":"on_ncs_pathway_removed ( ncs_pathway_uuid ) Slot raised when an NCS pathway has been removed. Parameters: Name Type Description Default ncs_pathway_uuid str Unique identified of the removed NCS pathway item. required Source code in src/cplus_plugin/gui/implementation_model_widget.py 129 130 131 132 133 134 135 def on_ncs_pathway_removed ( self , ncs_pathway_uuid : str ): \"\"\"Slot raised when an NCS pathway has been removed. :param ncs_pathway_uuid: Unique identified of the removed NCS pathway item. :type ncs_pathway_uuid: str \"\"\" self . implementation_model_view . remove_ncs_pathway_items ( ncs_pathway_uuid )","title":"on_ncs_pathway_removed()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.on_ncs_pathway_updated","text":"on_ncs_pathway_updated ( ncs_pathway ) Slot raised when an NCS pathway has been updated. Source code in src/cplus_plugin/gui/implementation_model_widget.py 125 126 127 def on_ncs_pathway_updated ( self , ncs_pathway : NcsPathway ): \"\"\"Slot raised when an NCS pathway has been updated.\"\"\" self . implementation_model_view . update_ncs_pathway_items ( ncs_pathway )","title":"on_ncs_pathway_updated()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.on_settings_changed","text":"on_settings_changed ( name , value ) Slot raised when settings has been changed. Parameters: Name Type Description Default name str Name of the setting that has changed. required value Any New value for the given settings name. required Source code in src/cplus_plugin/gui/implementation_model_widget.py 164 165 166 167 168 169 170 171 172 173 174 175 176 def on_settings_changed ( self , name : str , value : typing . Any ): \"\"\"Slot raised when settings has been changed. :param name: Name of the setting that has changed. :type name: str :param value: New value for the given settings name. :type value: Any \"\"\" # Update the NCS pathway and carbon layer paths when # BASE_DIR has been updated. if name == Settings . BASE_DIR . value : self . ncs_pathway_view . load ()","title":"on_settings_changed()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.selected_im_items","text":"selected_im_items () Returns the currently selected instances of ImplementationModelItem. If an item is disabled then it will be excluded from the selection. Returns: Type Description list Currently selected instances of ImplementationModelItem or an empty list if there is no selection of IM items. Source code in src/cplus_plugin/gui/implementation_model_widget.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def selected_im_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns the currently selected instances of ImplementationModelItem. If an item is disabled then it will be excluded from the selection. :returns: Currently selected instances of ImplementationModelItem or an empty list if there is no selection of IM items. :rtype: list \"\"\" return [ item for item in self . selected_items () if isinstance ( item , ImplementationModelItem ) ]","title":"selected_im_items()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.selected_items","text":"selected_items () Returns the selected model component item types which could be NCS pathway or implementation model items. If an item is disabled then it will be excluded from the selection. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. Returns: Type Description list Selected model component items. Source code in src/cplus_plugin/gui/implementation_model_widget.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected model component item types which could be NCS pathway or implementation model items. If an item is disabled then it will be excluded from the selection. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. :returns: Selected model component items. :rtype: list \"\"\" ref_items = self . implementation_model_view . selected_items () cloned_items = [] for ref_item in ref_items : if not ref_item . isEnabled (): continue clone_item = ref_item . clone () cloned_items . append ( clone_item ) return cloned_items","title":"selected_items()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.show_message","text":"show_message ( message , level = Qgis . Warning ) Shows message if message bar has been specified. Parameters: Name Type Description Default message str Text to display in the message bar. required level Qgis.MessageLevel Message level type Warning Source code in src/cplus_plugin/gui/implementation_model_widget.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def show_message ( self , message , level = Qgis . Warning ): \"\"\"Shows message if message bar has been specified. :param message: Text to display in the message bar. :type message: str :param level: Message level type :type level: Qgis.MessageLevel \"\"\" if self . _message_bar is None : return self . _message_bar . clearWidgets () self . _message_bar . pushMessage ( message , level = level )","title":"show_message()"},{"location":"developer/api/gui/api_items_selection_dialog/","text":"Items selection dialog Item selection dialog file ItemsSelectionDialog ItemsSelectionDialog ( parent , parent_item = None , items = [], item_type = ImplementationModel ) Bases: QDialog , DialogUi Dialog for handling items selection Constructor Source code in src/cplus_plugin/gui/items_selection_dialog.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def __init__ ( self , parent , parent_item = None , items = [], item_type = ImplementationModel ): \"\"\"Constructor\"\"\" super () . __init__ () self . setupUi ( self ) self . parent = parent self . parent_item = parent_item self . item_type = item_type self . items = items select_all_btn = QtWidgets . QPushButton ( tr ( \"Select All\" )) select_all_btn . setToolTip ( tr ( \"Select the all listed items\" )) select_all_btn . clicked . connect ( self . select_all_clicked ) self . mButtonBox . addButton ( select_all_btn , QtWidgets . QDialogButtonBox . ActionRole ) clear_all_btn = QtWidgets . QPushButton ( tr ( \"Clear Selection\" )) clear_all_btn . setToolTip ( tr ( \"Clear the current selection\" )) clear_all_btn . clicked . connect ( self . clear_all_clicked ) self . mButtonBox . addButton ( clear_all_btn , QtWidgets . QDialogButtonBox . ActionRole ) toggle_selection_btn = QtWidgets . QPushButton ( tr ( \"Toggle Selection\" )) toggle_selection_btn . clicked . connect ( self . toggle_selection_clicked ) self . mButtonBox . addButton ( toggle_selection_btn , QtWidgets . QDialogButtonBox . ActionRole ) self . mButtonBox . accepted . connect ( self . accept ) self . set_items () for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) item_uuid = item . data ( QtCore . Qt . UserRole ) if self . item_type is ImplementationModel : model = settings_manager . get_implementation_model ( str ( item_uuid )) layer_model_uuids = [ item . uuid for item in self . items ] model_layer_uuids = [ layer . get ( \"uuid\" ) for layer in model . priority_layers if layer is not None ] if ( self . parent_item is not None and str ( self . parent_item . get ( \"uuid\" )) in model_layer_uuids ) or ( model . uuid in layer_model_uuids ): item . setCheckState ( QtCore . Qt . Checked ) else : layer = settings_manager . get_priority_layer ( str ( item_uuid )) group_uuids = [] for group in layer . get ( \"groups\" ): group = settings_manager . find_group_by_name ( group . get ( \"name\" )) if group is not None : group_uuids . append ( str ( group . get ( \"uuid\" ))) if self . parent_item . get ( \"uuid\" ) in group_uuids : item . setCheckState ( QtCore . Qt . Checked ) accept accept () Saves the item selection Source code in src/cplus_plugin/gui/items_selection_dialog.py 169 170 171 172 def accept ( self ): \"\"\"Saves the item selection\"\"\" self . parent . set_selected_items ( self . selected_items (), self . unselected_items ()) super () . accept () clear_all_clicked clear_all_clicked () Slot for handling clear fselection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 180 181 182 183 184 def clear_all_clicked ( self ): \"\"\"Slot for handling clear fselection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . Unchecked ) select_all_clicked select_all_clicked () Slot for handling selection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 174 175 176 177 178 def select_all_clicked ( self ): \"\"\"Slot for handling selection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . Checked ) selected_items selected_items () Returns the selected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def selected_items ( self ): \"\"\"Returns the selected items from the dialog\"\"\" if self . item_type is ImplementationModel : items = settings_manager . get_all_implementation_models () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . Checked : items_text . append ( item . text ()) item_names = \",\" . join ( items_text ) items = [ item for item in items if item . name in item_names ] return items set_items set_items () Sets the item list in the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def set_items ( self ): \"\"\"Sets the item list in the dialog\"\"\" if self . item_type is ImplementationModel : items = settings_manager . get_all_implementation_models () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) for item in items : list_widget_item = QtWidgets . QListWidgetItem ( item . name ) list_widget_item . setFlags ( list_widget_item . flags () | QtCore . Qt . ItemIsUserCheckable ) list_widget_item . setData ( QtCore . Qt . UserRole , item . uuid ) list_widget_item . setCheckState ( QtCore . Qt . Unchecked ) self . list_widget . addItem ( list_widget_item ) toggle_selection_clicked toggle_selection_clicked () Toggles all the current items selection. Source code in src/cplus_plugin/gui/items_selection_dialog.py 186 187 188 189 190 191 192 193 194 def toggle_selection_clicked ( self ): \"\"\"Toggles all the current items selection.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) state = item_item . checkState () if state == QtCore . Qt . Checked : item_item . setCheckState ( QtCore . Qt . Unchecked ) elif state == QtCore . Qt . Unchecked : item_item . setCheckState ( QtCore . Qt . Checked ) unselected_items unselected_items () Returns unselected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def unselected_items ( self ): \"\"\"Returns unselected items from the dialog\"\"\" if self . item_type is ImplementationModel : items = settings_manager . get_all_implementation_models () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . Unchecked : items_text . append ( item . text ()) item_names = \",\" . join ( items_text ) items = [ item for item in items if item . name in item_names ] return items","title":"Items selection dialog"},{"location":"developer/api/gui/api_items_selection_dialog/#items-selection-dialog","text":"Item selection dialog file","title":"Items selection dialog"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog","text":"ItemsSelectionDialog ( parent , parent_item = None , items = [], item_type = ImplementationModel ) Bases: QDialog , DialogUi Dialog for handling items selection Constructor Source code in src/cplus_plugin/gui/items_selection_dialog.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def __init__ ( self , parent , parent_item = None , items = [], item_type = ImplementationModel ): \"\"\"Constructor\"\"\" super () . __init__ () self . setupUi ( self ) self . parent = parent self . parent_item = parent_item self . item_type = item_type self . items = items select_all_btn = QtWidgets . QPushButton ( tr ( \"Select All\" )) select_all_btn . setToolTip ( tr ( \"Select the all listed items\" )) select_all_btn . clicked . connect ( self . select_all_clicked ) self . mButtonBox . addButton ( select_all_btn , QtWidgets . QDialogButtonBox . ActionRole ) clear_all_btn = QtWidgets . QPushButton ( tr ( \"Clear Selection\" )) clear_all_btn . setToolTip ( tr ( \"Clear the current selection\" )) clear_all_btn . clicked . connect ( self . clear_all_clicked ) self . mButtonBox . addButton ( clear_all_btn , QtWidgets . QDialogButtonBox . ActionRole ) toggle_selection_btn = QtWidgets . QPushButton ( tr ( \"Toggle Selection\" )) toggle_selection_btn . clicked . connect ( self . toggle_selection_clicked ) self . mButtonBox . addButton ( toggle_selection_btn , QtWidgets . QDialogButtonBox . ActionRole ) self . mButtonBox . accepted . connect ( self . accept ) self . set_items () for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) item_uuid = item . data ( QtCore . Qt . UserRole ) if self . item_type is ImplementationModel : model = settings_manager . get_implementation_model ( str ( item_uuid )) layer_model_uuids = [ item . uuid for item in self . items ] model_layer_uuids = [ layer . get ( \"uuid\" ) for layer in model . priority_layers if layer is not None ] if ( self . parent_item is not None and str ( self . parent_item . get ( \"uuid\" )) in model_layer_uuids ) or ( model . uuid in layer_model_uuids ): item . setCheckState ( QtCore . Qt . Checked ) else : layer = settings_manager . get_priority_layer ( str ( item_uuid )) group_uuids = [] for group in layer . get ( \"groups\" ): group = settings_manager . find_group_by_name ( group . get ( \"name\" )) if group is not None : group_uuids . append ( str ( group . get ( \"uuid\" ))) if self . parent_item . get ( \"uuid\" ) in group_uuids : item . setCheckState ( QtCore . Qt . Checked )","title":"ItemsSelectionDialog"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.accept","text":"accept () Saves the item selection Source code in src/cplus_plugin/gui/items_selection_dialog.py 169 170 171 172 def accept ( self ): \"\"\"Saves the item selection\"\"\" self . parent . set_selected_items ( self . selected_items (), self . unselected_items ()) super () . accept ()","title":"accept()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.clear_all_clicked","text":"clear_all_clicked () Slot for handling clear fselection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 180 181 182 183 184 def clear_all_clicked ( self ): \"\"\"Slot for handling clear fselection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . Unchecked )","title":"clear_all_clicked()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.select_all_clicked","text":"select_all_clicked () Slot for handling selection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 174 175 176 177 178 def select_all_clicked ( self ): \"\"\"Slot for handling selection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . Checked )","title":"select_all_clicked()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.selected_items","text":"selected_items () Returns the selected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def selected_items ( self ): \"\"\"Returns the selected items from the dialog\"\"\" if self . item_type is ImplementationModel : items = settings_manager . get_all_implementation_models () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . Checked : items_text . append ( item . text ()) item_names = \",\" . join ( items_text ) items = [ item for item in items if item . name in item_names ] return items","title":"selected_items()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.set_items","text":"set_items () Sets the item list in the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def set_items ( self ): \"\"\"Sets the item list in the dialog\"\"\" if self . item_type is ImplementationModel : items = settings_manager . get_all_implementation_models () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) for item in items : list_widget_item = QtWidgets . QListWidgetItem ( item . name ) list_widget_item . setFlags ( list_widget_item . flags () | QtCore . Qt . ItemIsUserCheckable ) list_widget_item . setData ( QtCore . Qt . UserRole , item . uuid ) list_widget_item . setCheckState ( QtCore . Qt . Unchecked ) self . list_widget . addItem ( list_widget_item )","title":"set_items()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.toggle_selection_clicked","text":"toggle_selection_clicked () Toggles all the current items selection. Source code in src/cplus_plugin/gui/items_selection_dialog.py 186 187 188 189 190 191 192 193 194 def toggle_selection_clicked ( self ): \"\"\"Toggles all the current items selection.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) state = item_item . checkState () if state == QtCore . Qt . Checked : item_item . setCheckState ( QtCore . Qt . Unchecked ) elif state == QtCore . Qt . Unchecked : item_item . setCheckState ( QtCore . Qt . Checked )","title":"toggle_selection_clicked()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.unselected_items","text":"unselected_items () Returns unselected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def unselected_items ( self ): \"\"\"Returns unselected items from the dialog\"\"\" if self . item_type is ImplementationModel : items = settings_manager . get_all_implementation_models () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . Unchecked : items_text . append ( item . text ()) item_names = \",\" . join ( items_text ) items = [ item for item in items if item . name in item_names ] return items","title":"unselected_items()"},{"location":"developer/api/gui/api_map_repeat_item_widget/","text":"Map repeat item widget Widget for the custom CPLUS layout map item. CplusMapLayoutItemGuiMetadata CplusMapLayoutItemGuiMetadata () Bases: QgsLayoutItemAbstractGuiMetadata GUI metadata for a CPLUS map layout item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 55 56 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , CPLUS_ITEM_NAME ) createItem createItem ( layout ) Factory override that returns the map item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 62 63 64 def createItem ( self , layout ) -> QgsLayoutItem : \"\"\"Factory override that returns the map item.\"\"\" return CplusMapRepeatItem ( layout ) createItemWidget createItemWidget ( item ) Factory override for the item widget. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 58 59 60 def createItemWidget ( self , item ) -> QtWidgets . QWidget : \"\"\"Factory override for the item widget.\"\"\" return CplusMapRepeatItemWidget ( None , item ) creationIcon creationIcon () Factory override for item icon. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 70 71 72 def creationIcon ( self ) -> QtGui . QIcon : \"\"\"Factory override for item icon.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus_add.svg\" ) newItemAddedToLayout newItemAddedToLayout ( map_repeat_item ) Define action that is called when the CplusMapItem is added to a layout through the GUI. Parameters: Name Type Description Default map_repeat_item CplusMapRepeatItem Map repeat item to be added to the layout. required Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def newItemAddedToLayout ( self , map_repeat_item : CplusMapRepeatItem ): \"\"\"Define action that is called when the CplusMapItem is added to a layout through the GUI. :param map_repeat_item: Map repeat item to be added to the layout. :type map_repeat_item: CplusMapRepeatItem \"\"\" items = map_repeat_item . layout () . items () counter = 1 for item in items : if isinstance ( item , CplusMapRepeatItem ): counter += 1 # Set frame properties map_repeat_item . setFrameEnabled ( True ) map_repeat_item . setFrameJoinStyle ( QtCore . Qt . MiterJoin ) map_repeat_item . setFrameStrokeColor ( QtGui . QColor ( 132 , 192 , 68 )) map_repeat_item . setFrameStrokeWidth ( QgsLayoutMeasurement ( 0.4 )) map_repeat_item . setId ( f \" { CPLUS_ITEM_NAME } { counter !s} \" ) visibleName visibleName () Override for user-visible name identifying the item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 66 67 68 def visibleName ( self ) -> str : \"\"\"Override for user-visible name identifying the item.\"\"\" return CPLUS_ITEM_NAME CplusMapRepeatItemWidget CplusMapRepeatItemWidget ( parent , layout_object ) Bases: QgsLayoutItemBaseWidget , WidgetUi Widget for configuring the CPLUS layout map repeatitem. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , parent , layout_object : CplusMapRepeatItem ): super () . __init__ ( parent , layout_object ) self . setupUi ( self ) self . _map_item = layout_object # Common item properties widget self . _prop_widget = QgsLayoutItemPropertiesWidget ( self , layout_object ) self . layout . addWidget ( self . _prop_widget , 2 , 0 , 1 , 2 ) self . cbo_map_type . addItem ( self . tr ( \"Implementation model\" ), ModelComponentType . IMPLEMENTATION_MODEL . value , )","title":"Map repeat item widget"},{"location":"developer/api/gui/api_map_repeat_item_widget/#map-repeat-item-widget","text":"Widget for the custom CPLUS layout map item.","title":"Map repeat item widget"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata","text":"CplusMapLayoutItemGuiMetadata () Bases: QgsLayoutItemAbstractGuiMetadata GUI metadata for a CPLUS map layout item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 55 56 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , CPLUS_ITEM_NAME )","title":"CplusMapLayoutItemGuiMetadata"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.createItem","text":"createItem ( layout ) Factory override that returns the map item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 62 63 64 def createItem ( self , layout ) -> QgsLayoutItem : \"\"\"Factory override that returns the map item.\"\"\" return CplusMapRepeatItem ( layout )","title":"createItem()"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.createItemWidget","text":"createItemWidget ( item ) Factory override for the item widget. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 58 59 60 def createItemWidget ( self , item ) -> QtWidgets . QWidget : \"\"\"Factory override for the item widget.\"\"\" return CplusMapRepeatItemWidget ( None , item )","title":"createItemWidget()"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.creationIcon","text":"creationIcon () Factory override for item icon. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 70 71 72 def creationIcon ( self ) -> QtGui . QIcon : \"\"\"Factory override for item icon.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus_add.svg\" )","title":"creationIcon()"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.newItemAddedToLayout","text":"newItemAddedToLayout ( map_repeat_item ) Define action that is called when the CplusMapItem is added to a layout through the GUI. Parameters: Name Type Description Default map_repeat_item CplusMapRepeatItem Map repeat item to be added to the layout. required Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def newItemAddedToLayout ( self , map_repeat_item : CplusMapRepeatItem ): \"\"\"Define action that is called when the CplusMapItem is added to a layout through the GUI. :param map_repeat_item: Map repeat item to be added to the layout. :type map_repeat_item: CplusMapRepeatItem \"\"\" items = map_repeat_item . layout () . items () counter = 1 for item in items : if isinstance ( item , CplusMapRepeatItem ): counter += 1 # Set frame properties map_repeat_item . setFrameEnabled ( True ) map_repeat_item . setFrameJoinStyle ( QtCore . Qt . MiterJoin ) map_repeat_item . setFrameStrokeColor ( QtGui . QColor ( 132 , 192 , 68 )) map_repeat_item . setFrameStrokeWidth ( QgsLayoutMeasurement ( 0.4 )) map_repeat_item . setId ( f \" { CPLUS_ITEM_NAME } { counter !s} \" )","title":"newItemAddedToLayout()"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.visibleName","text":"visibleName () Override for user-visible name identifying the item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 66 67 68 def visibleName ( self ) -> str : \"\"\"Override for user-visible name identifying the item.\"\"\" return CPLUS_ITEM_NAME","title":"visibleName()"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapRepeatItemWidget","text":"CplusMapRepeatItemWidget ( parent , layout_object ) Bases: QgsLayoutItemBaseWidget , WidgetUi Widget for configuring the CPLUS layout map repeatitem. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , parent , layout_object : CplusMapRepeatItem ): super () . __init__ ( parent , layout_object ) self . setupUi ( self ) self . _map_item = layout_object # Common item properties widget self . _prop_widget = QgsLayoutItemPropertiesWidget ( self , layout_object ) self . layout . addWidget ( self . _prop_widget , 2 , 0 , 1 , 2 ) self . cbo_map_type . addItem ( self . tr ( \"Implementation model\" ), ModelComponentType . IMPLEMENTATION_MODEL . value , )","title":"CplusMapRepeatItemWidget"},{"location":"developer/api/gui/api_model_component_widget/","text":"Model component widget Composite list view-based widgets for displaying implementation model and NCS pathway items. ImplementationModelComponentWidget ImplementationModelComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing implementation models. Source code in src/cplus_plugin/gui/model_component_widget.py 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . item_model = IMItemModel ( parent ) self . item_model . im_pathways_updated . connect ( self . on_pathways_updated ) self . lst_model_items . setAcceptDrops ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DropOnly ) self . lst_model_items . setDropIndicatorShown ( True ) self . btn_reload . setVisible ( False ) self . btn_pixel_editor = None self . add_auxiliary_widgets () add_auxiliary_widgets add_auxiliary_widgets () Adds additional action widgets for managing implementation models. Source code in src/cplus_plugin/gui/model_component_widget.py 516 517 518 519 520 521 522 523 524 525 def add_auxiliary_widgets ( self ): \"\"\"Adds additional action widgets for managing implementation models.\"\"\" self . btn_pixel_editor = QtWidgets . QToolButton ( self ) style_icon = FileUtils . get_icon ( \"rendererCategorizedSymbol.svg\" ) self . btn_pixel_editor . setIcon ( style_icon ) self . btn_pixel_editor . setToolTip ( self . tr ( \"Show dialog for ordering pixel values for styling.\" ) ) self . btn_pixel_editor . clicked . connect ( self . on_show_pixel_value_editor ) self . add_action_widget ( self . btn_pixel_editor ) add_implementation_model add_implementation_model ( implementation_model , layer = None ) Adds an implementation model object to the view with the option of specifying the layer. Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model object to be added to the view. required layer QgsMapLayer Optional map layer to be added to the model. None Returns: Type Description bool True if the implementation model was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 def add_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ): \"\"\"Adds an implementation model object to the view with the option of specifying the layer. :param implementation_model: Implementation model object to be added to the view. :type implementation_model: ImplementationModel :param layer: Optional map layer to be added to the model. :type layer: QgsMapLayer :returns: True if the implementation model was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_implementation_model ( implementation_model , layer ) add_ncs_pathway_items add_ncs_pathway_items ( ncs_items ) Adds an NCS pathway item to the collection. One, and only one, target implementation model item needs to have been selected. Parameters: Name Type Description Default ncs_items List [ NcsPathwayItem ] NCS pathway items to be added to the implementation model. required Returns: Type Description bool True if the item was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 def add_ncs_pathway_items ( self , ncs_items : typing . List [ NcsPathwayItem ]) -> bool : \"\"\"Adds an NCS pathway item to the collection. One, and only one, target implementation model item needs to have been selected. :param ncs_items: NCS pathway items to be added to the implementation model. :type ncs_items: list :returns: True if the item was successfully added, else False. :rtype: bool \"\"\" selected_models = self . selected_items () if len ( selected_models ) == 0 or len ( selected_models ) > 1 : return False sel_model = selected_models [ 0 ] item_type = sel_model . type () # Use the parent to add the NCS item if item_type == NCS_PATHWAY_TYPE : if sel_model . parent is None : return False sel_model = sel_model . parent elif item_type == LAYER_ITEM_TYPE : return False status = True for ncs_item in ncs_items : status = self . item_model . add_ncs_pathway ( ncs_item , sel_model ) return status clear clear () Removes all implementation model items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 572 573 574 575 576 def clear ( self ): \"\"\"Removes all implementation model items in the view.\"\"\" items = self . model_items () for item in items : self . item_model . remove_implementation_model ( item . uuid ) load load () Load implementation models from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 578 579 580 581 582 583 def load ( self ): \"\"\"Load implementation models from settings.\"\"\" self . clear () for imp_model in settings_manager . get_all_implementation_models (): self . add_implementation_model ( imp_model ) model_items model_items () Returns a collection of all ImplementationModelItem objects in the list view. Returns: Type Description list Collection of ImplementationModelItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 562 563 564 565 566 567 568 569 570 def model_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns a collection of all ImplementationModelItem objects in the list view. :returns: Collection of ImplementationModelItem objects in the list view. :rtype: list \"\"\" return self . item_model . model_items () model_names model_names () Gets the names of the implementation models in the item model. Returns: Type Description list Returns the names of implementation models in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 542 543 544 545 546 547 548 549 550 551 552 553 554 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the implementation models in the item model. :returns: Returns the names of implementation models in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . models () return [ mc . name . lower () for mc in model_components ] models models () Returns a collection of ImplementationModel objects in the list view. Returns: Type Description list Collection of ImplementationModel objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 506 507 508 509 510 511 512 513 514 def models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns a collection of ImplementationModel objects in the list view. :returns: Collection of ImplementationModel objects in the list view. :rtype: list \"\"\" return self . item_model . models () on_pathways_updated on_pathways_updated ( im_item ) Slot raised when the pathways of an ImplementationModelItem have been added or removed. Persist this information in settings. Source code in src/cplus_plugin/gui/model_component_widget.py 556 557 558 559 560 def on_pathways_updated ( self , im_item : ImplementationModelItem ): \"\"\"Slot raised when the pathways of an ImplementationModelItem have been added or removed. Persist this information in settings. \"\"\" self . _save_item ( im_item ) on_show_pixel_value_editor on_show_pixel_value_editor () Slot raised to show editor dialog for managing IM pixel values for styling. Source code in src/cplus_plugin/gui/model_component_widget.py 527 528 529 530 531 532 533 534 535 536 537 538 539 540 def on_show_pixel_value_editor ( self ): \"\"\"Slot raised to show editor dialog for managing IM pixel values for styling.\"\"\" pixel_dialog = PixelValueEditorDialog ( self ) if pixel_dialog . exec_ () == QtWidgets . QDialog . Accepted : # Update pixel values pixel_values = pixel_dialog . item_mapping for val , im_id in pixel_values . items (): imp_model = settings_manager . get_implementation_model ( im_id ) if not imp_model : continue imp_model . style_pixel_value = val settings_manager . update_implementation_model ( imp_model ) self . load () reassign_pixel_values reassign_pixel_values ( start_position ) Reassign the styling pixel values for implementation models from the given start position. It is important to call this function when the maximum pixel value does not match the number of implementation models such as when one or more implementation models have been deleted. Parameters: Name Type Description Default start_position int Position to start reassigning the pixel values. required Source code in src/cplus_plugin/gui/model_component_widget.py 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 def reassign_pixel_values ( self , start_position : int ): \"\"\"Reassign the styling pixel values for implementation models from the given start position. It is important to call this function when the maximum pixel value does not match the number of implementation models such as when one or more implementation models have been deleted. :param start_position: Position to start reassigning the pixel values. :type start_position: int \"\"\" sorted_models = sorted ( settings_manager . get_all_implementation_models (), key = lambda model : model . style_pixel_value , ) remap_models = sorted_models [ start_position - 1 :] for val , imp_model in enumerate ( remap_models , start = start_position ): imp_model . style_pixel_value = val settings_manager . update_implementation_model ( imp_model ) self . load () remove_ncs_pathway_items remove_ncs_pathway_items ( ncs_pathway_uuid ) Delete NCS pathway items used for IMs that are linked to the given NCS pathway. Parameters: Name Type Description Default ncs_pathway_uuid str NCS pathway whose corresponding items will be deleted in the implementation model items that contain it. required Source code in src/cplus_plugin/gui/model_component_widget.py 813 814 815 816 817 818 819 820 821 def remove_ncs_pathway_items ( self , ncs_pathway_uuid : str ): \"\"\"Delete NCS pathway items used for IMs that are linked to the given NCS pathway. :param ncs_pathway_uuid: NCS pathway whose corresponding items will be deleted in the implementation model items that contain it. :type ncs_pathway_uuid: str \"\"\" self . item_model . remove_ncs_pathway_items ( ncs_pathway_uuid ) update_ncs_pathway_items update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items used for IMs that are linked to the given NCS pathway. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway whose attribute values will be updated for the related pathways used in the IMs. required Returns: Type Description bool True if NCS pathway items were updated, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 800 801 802 803 804 805 806 807 808 809 810 811 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items used for IMs that are linked to the given NCS pathway. :param ncs_pathway: NCS pathway whose attribute values will be updated for the related pathways used in the IMs. :type ncs_pathway: NcsPathway :returns: True if NCS pathway items were updated, else False. :rtype: bool \"\"\" return self . item_model . update_ncs_pathway_items ( ncs_pathway ) ModelComponentWidget ModelComponentWidget ( parent = None , item_model = None ) Bases: QWidget , WidgetUi Widget for displaying and managing model items in a list view. Source code in src/cplus_plugin/gui/model_component_widget.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def __init__ ( self , parent = None , item_model = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _item_model = item_model if self . _item_model is not None : self . item_model = self . _item_model self . lst_model_items . doubleClicked . connect ( self . _on_double_click_item ) add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add . setIcon ( add_icon ) self . btn_add . clicked . connect ( self . _on_add_item ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_remove . setIcon ( remove_icon ) self . btn_remove . setEnabled ( False ) self . btn_remove . clicked . connect ( self . _on_remove_item ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit . setIcon ( edit_icon ) self . btn_edit . setEnabled ( False ) self . btn_edit . clicked . connect ( self . _on_edit_item ) reload_icon = FileUtils . get_icon ( \"mActionReload.svg\" ) self . btn_reload . setIcon ( reload_icon ) self . btn_reload . setToolTip ( self . tr ( \"Refresh view\" )) self . btn_reload . clicked . connect ( self . _on_reload ) self . btn_edit_description . setIcon ( edit_icon ) self . btn_edit_description . setToolTip ( self . tr ( \"Edit description\" )) self . btn_edit_description . setEnabled ( False ) self . btn_edit_description . clicked . connect ( self . _on_update_description ) item_model property writable item_model Returns the component item model for managing items the list view. Returns: Type Description ComponentItemModel Component item model for managing items the list view. selection_model property selection_model Gets the item's view selection model. Returns: Type Description QtCore.QItemSelectionModel The item's view selection model. title property writable title Returns the title of the view. Returns: Type Description str Title of the view. add_action_widget add_action_widget ( widget ) Adds an auxiliary widget below the list view from the left-hand side. Parameters: Name Type Description Default widget QWidget Widget to be added to the collection of controls below the list view. required Source code in src/cplus_plugin/gui/model_component_widget.py 325 326 327 328 329 330 331 332 def add_action_widget ( self , widget : QtWidgets . QWidget ): \"\"\"Adds an auxiliary widget below the list view from the left-hand side. :param widget: Widget to be added to the collection of controls below the list view. :type widget: QtWidgets.QWidget \"\"\" self . widget_container . addWidget ( widget ) clear clear () Remove all items in the view. To be implemented by subclasses. Source code in src/cplus_plugin/gui/model_component_widget.py 279 280 281 282 def clear ( self ): \"\"\"Remove all items in the view. To be implemented by subclasses.\"\"\" pass clear_description clear_description () Clears the content in the description text box. Source code in src/cplus_plugin/gui/model_component_widget.py 195 196 197 198 def clear_description ( self ): \"\"\"Clears the content in the description text box.\"\"\" self . txt_item_description . clear () self . txt_item_description . setToolTip ( \"\" ) enable_default_items enable_default_items ( state ) Enable or disable default model component items in the view. Parameters: Name Type Description Default state bool True to enable or False to disable default model component items. required Source code in src/cplus_plugin/gui/model_component_widget.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def enable_default_items ( self , state : bool ): \"\"\"Enable or disable default model component items in the view. :param state: True to enable or False to disable default model component items. :type state: bool \"\"\" self . _item_model . enable_default_items ( state ) # If false, deselect default items if not state : selection_model = self . lst_model_items . selectionModel () selected_idxs = selection_model . selectedRows () for sel_idx in selected_idxs : item = self . _item_model . item ( sel_idx . row (), 0 ) # If not enabled then deselect if not item . isEnabled (): selection_model . select ( sel_idx , QtCore . QItemSelectionModel . Deselect ) load load () Subclass to determine how to initialize the items. Source code in src/cplus_plugin/gui/model_component_widget.py 130 131 132 def load ( self ): \"\"\"Subclass to determine how to initialize the items.\"\"\" pass model_names model_names () Gets the names of the components in the item model. Returns: Type Description list Returns the model names in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 292 293 294 295 296 297 298 299 300 301 302 303 304 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the components in the item model. :returns: Returns the model names in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . model_components () return [ mc . name . lower () for mc in model_components ] selected_items selected_items () Returns the selected items in the list view. Returns: Type Description list A collection of the selected model component items. Returns an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected items in the list view. :returns: A collection of the selected model component items. Returns an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] selection_model = self . lst_model_items . selectionModel () idxs = selection_model . selectedRows () return [ self . _item_model . item ( idx . row ()) for idx in idxs ] set_description set_description ( description ) Updates the text for the selected item. Parameters: Name Type Description Default description str Description for the selected item. required Source code in src/cplus_plugin/gui/model_component_widget.py 186 187 188 189 190 191 192 193 def set_description ( self , description : str ): \"\"\"Updates the text for the selected item. :param description: Description for the selected item. :type description: str \"\"\" self . txt_item_description . setText ( description ) self . txt_item_description . setToolTip ( description ) NcsComponentWidget NcsComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing NCS pathways. Source code in src/cplus_plugin/gui/model_component_widget.py 342 343 344 345 346 347 348 349 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . item_model = NcsPathwayItemModel ( parent ) self . lst_model_items . setDragEnabled ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DragOnly ) self . lst_model_items . setAcceptDrops ( False ) add_ncs_pathway add_ncs_pathway ( ncs_pathway ) Adds an NCS pathway object to the view. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be added to the view. required Returns: Type Description bool Returns True if the NcsPathway was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 351 352 353 354 355 356 357 358 359 360 361 def add_ncs_pathway ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the view. :param ncs_pathway: NCS pathway object to be added to the view. :type ncs_pathway: NcsPathway :returns: Returns True if the NcsPathway was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_ncs_pathway ( ncs_pathway ) clear clear () Removes all NCS pathway items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 363 364 365 366 367 def clear ( self ): \"\"\"Removes all NCS pathway items in the view.\"\"\" items = self . ncs_items () for item in items : self . item_model . remove_ncs_pathway ( item . uuid ) load load () Load items from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 def load ( self ): \"\"\"Load items from settings.\"\"\" self . clear () settings_manager . update_ncs_pathways () ncs_pathways = settings_manager . get_all_ncs_pathways () progress_dialog = QtWidgets . QProgressDialog ( self ) progress_dialog . setWindowTitle ( self . tr ( \"Load NCS Pathways\" )) progress_dialog . setMinimum ( 0 ) progress_dialog . setMaximum ( len ( ncs_pathways )) progress_dialog . setLabelText ( self . tr ( \"Updating NCS pathways...\" )) for i , ncs in enumerate ( ncs_pathways , start = 1 ): progress_dialog . setValue ( i ) if progress_dialog . wasCanceled (): break self . add_ncs_pathway ( ncs ) ncs_items ncs_items () Returns a collection of all NcsPathwayItem objects in the list view. Returns: Type Description list Collection of NcsPathwayItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 381 382 383 384 385 386 387 388 def ncs_items ( self ) -> typing . List [ NcsPathwayItem ]: \"\"\"Returns a collection of all NcsPathwayItem objects in the list view. :returns: Collection of NcsPathwayItem objects in the list view. :rtype: list \"\"\" return self . item_model . model_component_items () pathways pathways ( valid_only = False ) Returns a collection of NcsPathway objects in the list view. Parameters: Name Type Description Default valid_only bool True to only return those NcsPathway objects that are valid, default is False. False Returns: Type Description list Collection of NcsPathway objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 369 370 371 372 373 374 375 376 377 378 379 def pathways ( self , valid_only = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns a collection of NcsPathway objects in the list view. :param valid_only: True to only return those NcsPathway objects that are valid, default is False. :type valid_only: bool :returns: Collection of NcsPathway objects in the list view. :rtype: list \"\"\" return self . item_model . pathways ( valid_only )","title":"Model component widget"},{"location":"developer/api/gui/api_model_component_widget/#model-component-widget","text":"Composite list view-based widgets for displaying implementation model and NCS pathway items.","title":"Model component widget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget","text":"ImplementationModelComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing implementation models. Source code in src/cplus_plugin/gui/model_component_widget.py 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . item_model = IMItemModel ( parent ) self . item_model . im_pathways_updated . connect ( self . on_pathways_updated ) self . lst_model_items . setAcceptDrops ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DropOnly ) self . lst_model_items . setDropIndicatorShown ( True ) self . btn_reload . setVisible ( False ) self . btn_pixel_editor = None self . add_auxiliary_widgets ()","title":"ImplementationModelComponentWidget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.add_auxiliary_widgets","text":"add_auxiliary_widgets () Adds additional action widgets for managing implementation models. Source code in src/cplus_plugin/gui/model_component_widget.py 516 517 518 519 520 521 522 523 524 525 def add_auxiliary_widgets ( self ): \"\"\"Adds additional action widgets for managing implementation models.\"\"\" self . btn_pixel_editor = QtWidgets . QToolButton ( self ) style_icon = FileUtils . get_icon ( \"rendererCategorizedSymbol.svg\" ) self . btn_pixel_editor . setIcon ( style_icon ) self . btn_pixel_editor . setToolTip ( self . tr ( \"Show dialog for ordering pixel values for styling.\" ) ) self . btn_pixel_editor . clicked . connect ( self . on_show_pixel_value_editor ) self . add_action_widget ( self . btn_pixel_editor )","title":"add_auxiliary_widgets()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.add_implementation_model","text":"add_implementation_model ( implementation_model , layer = None ) Adds an implementation model object to the view with the option of specifying the layer. Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model object to be added to the view. required layer QgsMapLayer Optional map layer to be added to the model. None Returns: Type Description bool True if the implementation model was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 def add_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ): \"\"\"Adds an implementation model object to the view with the option of specifying the layer. :param implementation_model: Implementation model object to be added to the view. :type implementation_model: ImplementationModel :param layer: Optional map layer to be added to the model. :type layer: QgsMapLayer :returns: True if the implementation model was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_implementation_model ( implementation_model , layer )","title":"add_implementation_model()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.add_ncs_pathway_items","text":"add_ncs_pathway_items ( ncs_items ) Adds an NCS pathway item to the collection. One, and only one, target implementation model item needs to have been selected. Parameters: Name Type Description Default ncs_items List [ NcsPathwayItem ] NCS pathway items to be added to the implementation model. required Returns: Type Description bool True if the item was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 def add_ncs_pathway_items ( self , ncs_items : typing . List [ NcsPathwayItem ]) -> bool : \"\"\"Adds an NCS pathway item to the collection. One, and only one, target implementation model item needs to have been selected. :param ncs_items: NCS pathway items to be added to the implementation model. :type ncs_items: list :returns: True if the item was successfully added, else False. :rtype: bool \"\"\" selected_models = self . selected_items () if len ( selected_models ) == 0 or len ( selected_models ) > 1 : return False sel_model = selected_models [ 0 ] item_type = sel_model . type () # Use the parent to add the NCS item if item_type == NCS_PATHWAY_TYPE : if sel_model . parent is None : return False sel_model = sel_model . parent elif item_type == LAYER_ITEM_TYPE : return False status = True for ncs_item in ncs_items : status = self . item_model . add_ncs_pathway ( ncs_item , sel_model ) return status","title":"add_ncs_pathway_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.clear","text":"clear () Removes all implementation model items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 572 573 574 575 576 def clear ( self ): \"\"\"Removes all implementation model items in the view.\"\"\" items = self . model_items () for item in items : self . item_model . remove_implementation_model ( item . uuid )","title":"clear()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.load","text":"load () Load implementation models from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 578 579 580 581 582 583 def load ( self ): \"\"\"Load implementation models from settings.\"\"\" self . clear () for imp_model in settings_manager . get_all_implementation_models (): self . add_implementation_model ( imp_model )","title":"load()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.model_items","text":"model_items () Returns a collection of all ImplementationModelItem objects in the list view. Returns: Type Description list Collection of ImplementationModelItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 562 563 564 565 566 567 568 569 570 def model_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns a collection of all ImplementationModelItem objects in the list view. :returns: Collection of ImplementationModelItem objects in the list view. :rtype: list \"\"\" return self . item_model . model_items ()","title":"model_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.model_names","text":"model_names () Gets the names of the implementation models in the item model. Returns: Type Description list Returns the names of implementation models in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 542 543 544 545 546 547 548 549 550 551 552 553 554 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the implementation models in the item model. :returns: Returns the names of implementation models in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . models () return [ mc . name . lower () for mc in model_components ]","title":"model_names()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.models","text":"models () Returns a collection of ImplementationModel objects in the list view. Returns: Type Description list Collection of ImplementationModel objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 506 507 508 509 510 511 512 513 514 def models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns a collection of ImplementationModel objects in the list view. :returns: Collection of ImplementationModel objects in the list view. :rtype: list \"\"\" return self . item_model . models ()","title":"models()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.on_pathways_updated","text":"on_pathways_updated ( im_item ) Slot raised when the pathways of an ImplementationModelItem have been added or removed. Persist this information in settings. Source code in src/cplus_plugin/gui/model_component_widget.py 556 557 558 559 560 def on_pathways_updated ( self , im_item : ImplementationModelItem ): \"\"\"Slot raised when the pathways of an ImplementationModelItem have been added or removed. Persist this information in settings. \"\"\" self . _save_item ( im_item )","title":"on_pathways_updated()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.on_show_pixel_value_editor","text":"on_show_pixel_value_editor () Slot raised to show editor dialog for managing IM pixel values for styling. Source code in src/cplus_plugin/gui/model_component_widget.py 527 528 529 530 531 532 533 534 535 536 537 538 539 540 def on_show_pixel_value_editor ( self ): \"\"\"Slot raised to show editor dialog for managing IM pixel values for styling.\"\"\" pixel_dialog = PixelValueEditorDialog ( self ) if pixel_dialog . exec_ () == QtWidgets . QDialog . Accepted : # Update pixel values pixel_values = pixel_dialog . item_mapping for val , im_id in pixel_values . items (): imp_model = settings_manager . get_implementation_model ( im_id ) if not imp_model : continue imp_model . style_pixel_value = val settings_manager . update_implementation_model ( imp_model ) self . load ()","title":"on_show_pixel_value_editor()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.reassign_pixel_values","text":"reassign_pixel_values ( start_position ) Reassign the styling pixel values for implementation models from the given start position. It is important to call this function when the maximum pixel value does not match the number of implementation models such as when one or more implementation models have been deleted. Parameters: Name Type Description Default start_position int Position to start reassigning the pixel values. required Source code in src/cplus_plugin/gui/model_component_widget.py 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 def reassign_pixel_values ( self , start_position : int ): \"\"\"Reassign the styling pixel values for implementation models from the given start position. It is important to call this function when the maximum pixel value does not match the number of implementation models such as when one or more implementation models have been deleted. :param start_position: Position to start reassigning the pixel values. :type start_position: int \"\"\" sorted_models = sorted ( settings_manager . get_all_implementation_models (), key = lambda model : model . style_pixel_value , ) remap_models = sorted_models [ start_position - 1 :] for val , imp_model in enumerate ( remap_models , start = start_position ): imp_model . style_pixel_value = val settings_manager . update_implementation_model ( imp_model ) self . load ()","title":"reassign_pixel_values()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.remove_ncs_pathway_items","text":"remove_ncs_pathway_items ( ncs_pathway_uuid ) Delete NCS pathway items used for IMs that are linked to the given NCS pathway. Parameters: Name Type Description Default ncs_pathway_uuid str NCS pathway whose corresponding items will be deleted in the implementation model items that contain it. required Source code in src/cplus_plugin/gui/model_component_widget.py 813 814 815 816 817 818 819 820 821 def remove_ncs_pathway_items ( self , ncs_pathway_uuid : str ): \"\"\"Delete NCS pathway items used for IMs that are linked to the given NCS pathway. :param ncs_pathway_uuid: NCS pathway whose corresponding items will be deleted in the implementation model items that contain it. :type ncs_pathway_uuid: str \"\"\" self . item_model . remove_ncs_pathway_items ( ncs_pathway_uuid )","title":"remove_ncs_pathway_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.update_ncs_pathway_items","text":"update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items used for IMs that are linked to the given NCS pathway. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway whose attribute values will be updated for the related pathways used in the IMs. required Returns: Type Description bool True if NCS pathway items were updated, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 800 801 802 803 804 805 806 807 808 809 810 811 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items used for IMs that are linked to the given NCS pathway. :param ncs_pathway: NCS pathway whose attribute values will be updated for the related pathways used in the IMs. :type ncs_pathway: NcsPathway :returns: True if NCS pathway items were updated, else False. :rtype: bool \"\"\" return self . item_model . update_ncs_pathway_items ( ncs_pathway )","title":"update_ncs_pathway_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget","text":"ModelComponentWidget ( parent = None , item_model = None ) Bases: QWidget , WidgetUi Widget for displaying and managing model items in a list view. Source code in src/cplus_plugin/gui/model_component_widget.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def __init__ ( self , parent = None , item_model = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _item_model = item_model if self . _item_model is not None : self . item_model = self . _item_model self . lst_model_items . doubleClicked . connect ( self . _on_double_click_item ) add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add . setIcon ( add_icon ) self . btn_add . clicked . connect ( self . _on_add_item ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_remove . setIcon ( remove_icon ) self . btn_remove . setEnabled ( False ) self . btn_remove . clicked . connect ( self . _on_remove_item ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit . setIcon ( edit_icon ) self . btn_edit . setEnabled ( False ) self . btn_edit . clicked . connect ( self . _on_edit_item ) reload_icon = FileUtils . get_icon ( \"mActionReload.svg\" ) self . btn_reload . setIcon ( reload_icon ) self . btn_reload . setToolTip ( self . tr ( \"Refresh view\" )) self . btn_reload . clicked . connect ( self . _on_reload ) self . btn_edit_description . setIcon ( edit_icon ) self . btn_edit_description . setToolTip ( self . tr ( \"Edit description\" )) self . btn_edit_description . setEnabled ( False ) self . btn_edit_description . clicked . connect ( self . _on_update_description )","title":"ModelComponentWidget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.item_model","text":"item_model Returns the component item model for managing items the list view. Returns: Type Description ComponentItemModel Component item model for managing items the list view.","title":"item_model"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.selection_model","text":"selection_model Gets the item's view selection model. Returns: Type Description QtCore.QItemSelectionModel The item's view selection model.","title":"selection_model"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.title","text":"title Returns the title of the view. Returns: Type Description str Title of the view.","title":"title"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.add_action_widget","text":"add_action_widget ( widget ) Adds an auxiliary widget below the list view from the left-hand side. Parameters: Name Type Description Default widget QWidget Widget to be added to the collection of controls below the list view. required Source code in src/cplus_plugin/gui/model_component_widget.py 325 326 327 328 329 330 331 332 def add_action_widget ( self , widget : QtWidgets . QWidget ): \"\"\"Adds an auxiliary widget below the list view from the left-hand side. :param widget: Widget to be added to the collection of controls below the list view. :type widget: QtWidgets.QWidget \"\"\" self . widget_container . addWidget ( widget )","title":"add_action_widget()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.clear","text":"clear () Remove all items in the view. To be implemented by subclasses. Source code in src/cplus_plugin/gui/model_component_widget.py 279 280 281 282 def clear ( self ): \"\"\"Remove all items in the view. To be implemented by subclasses.\"\"\" pass","title":"clear()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.clear_description","text":"clear_description () Clears the content in the description text box. Source code in src/cplus_plugin/gui/model_component_widget.py 195 196 197 198 def clear_description ( self ): \"\"\"Clears the content in the description text box.\"\"\" self . txt_item_description . clear () self . txt_item_description . setToolTip ( \"\" )","title":"clear_description()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.enable_default_items","text":"enable_default_items ( state ) Enable or disable default model component items in the view. Parameters: Name Type Description Default state bool True to enable or False to disable default model component items. required Source code in src/cplus_plugin/gui/model_component_widget.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def enable_default_items ( self , state : bool ): \"\"\"Enable or disable default model component items in the view. :param state: True to enable or False to disable default model component items. :type state: bool \"\"\" self . _item_model . enable_default_items ( state ) # If false, deselect default items if not state : selection_model = self . lst_model_items . selectionModel () selected_idxs = selection_model . selectedRows () for sel_idx in selected_idxs : item = self . _item_model . item ( sel_idx . row (), 0 ) # If not enabled then deselect if not item . isEnabled (): selection_model . select ( sel_idx , QtCore . QItemSelectionModel . Deselect )","title":"enable_default_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.load","text":"load () Subclass to determine how to initialize the items. Source code in src/cplus_plugin/gui/model_component_widget.py 130 131 132 def load ( self ): \"\"\"Subclass to determine how to initialize the items.\"\"\" pass","title":"load()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.model_names","text":"model_names () Gets the names of the components in the item model. Returns: Type Description list Returns the model names in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 292 293 294 295 296 297 298 299 300 301 302 303 304 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the components in the item model. :returns: Returns the model names in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . model_components () return [ mc . name . lower () for mc in model_components ]","title":"model_names()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.selected_items","text":"selected_items () Returns the selected items in the list view. Returns: Type Description list A collection of the selected model component items. Returns an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected items in the list view. :returns: A collection of the selected model component items. Returns an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] selection_model = self . lst_model_items . selectionModel () idxs = selection_model . selectedRows () return [ self . _item_model . item ( idx . row ()) for idx in idxs ]","title":"selected_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.set_description","text":"set_description ( description ) Updates the text for the selected item. Parameters: Name Type Description Default description str Description for the selected item. required Source code in src/cplus_plugin/gui/model_component_widget.py 186 187 188 189 190 191 192 193 def set_description ( self , description : str ): \"\"\"Updates the text for the selected item. :param description: Description for the selected item. :type description: str \"\"\" self . txt_item_description . setText ( description ) self . txt_item_description . setToolTip ( description )","title":"set_description()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget","text":"NcsComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing NCS pathways. Source code in src/cplus_plugin/gui/model_component_widget.py 342 343 344 345 346 347 348 349 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . item_model = NcsPathwayItemModel ( parent ) self . lst_model_items . setDragEnabled ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DragOnly ) self . lst_model_items . setAcceptDrops ( False )","title":"NcsComponentWidget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.add_ncs_pathway","text":"add_ncs_pathway ( ncs_pathway ) Adds an NCS pathway object to the view. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be added to the view. required Returns: Type Description bool Returns True if the NcsPathway was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 351 352 353 354 355 356 357 358 359 360 361 def add_ncs_pathway ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the view. :param ncs_pathway: NCS pathway object to be added to the view. :type ncs_pathway: NcsPathway :returns: Returns True if the NcsPathway was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_ncs_pathway ( ncs_pathway )","title":"add_ncs_pathway()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.clear","text":"clear () Removes all NCS pathway items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 363 364 365 366 367 def clear ( self ): \"\"\"Removes all NCS pathway items in the view.\"\"\" items = self . ncs_items () for item in items : self . item_model . remove_ncs_pathway ( item . uuid )","title":"clear()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.load","text":"load () Load items from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 def load ( self ): \"\"\"Load items from settings.\"\"\" self . clear () settings_manager . update_ncs_pathways () ncs_pathways = settings_manager . get_all_ncs_pathways () progress_dialog = QtWidgets . QProgressDialog ( self ) progress_dialog . setWindowTitle ( self . tr ( \"Load NCS Pathways\" )) progress_dialog . setMinimum ( 0 ) progress_dialog . setMaximum ( len ( ncs_pathways )) progress_dialog . setLabelText ( self . tr ( \"Updating NCS pathways...\" )) for i , ncs in enumerate ( ncs_pathways , start = 1 ): progress_dialog . setValue ( i ) if progress_dialog . wasCanceled (): break self . add_ncs_pathway ( ncs )","title":"load()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.ncs_items","text":"ncs_items () Returns a collection of all NcsPathwayItem objects in the list view. Returns: Type Description list Collection of NcsPathwayItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 381 382 383 384 385 386 387 388 def ncs_items ( self ) -> typing . List [ NcsPathwayItem ]: \"\"\"Returns a collection of all NcsPathwayItem objects in the list view. :returns: Collection of NcsPathwayItem objects in the list view. :rtype: list \"\"\" return self . item_model . model_component_items ()","title":"ncs_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.pathways","text":"pathways ( valid_only = False ) Returns a collection of NcsPathway objects in the list view. Parameters: Name Type Description Default valid_only bool True to only return those NcsPathway objects that are valid, default is False. False Returns: Type Description list Collection of NcsPathway objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 369 370 371 372 373 374 375 376 377 378 379 def pathways ( self , valid_only = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns a collection of NcsPathway objects in the list view. :param valid_only: True to only return those NcsPathway objects that are valid, default is False. :type valid_only: bool :returns: Collection of NcsPathway objects in the list view. :rtype: list \"\"\" return self . item_model . pathways ( valid_only )","title":"pathways()"},{"location":"developer/api/gui/api_ncs_pathway_editor/","text":"NCS pathway editor Dialog for creating or editing an NCS pathway entry. NcsPathwayEditorDialog NcsPathwayEditorDialog ( parent = None , ncs_pathway = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an NCS pathway entry. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , parent = None , ncs_pathway = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . _carbon_model = CarbonLayerModel ( self ) self . lst_carbon_layers . setModel ( self . _carbon_model ) self . lst_carbon_layers . selectionModel () . selectionChanged . connect ( self . _on_selection_changed ) self . txt_description . textChanged . connect ( self . description_changed ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_add_layer . clicked . connect ( self . _on_select_file ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon ) self . btn_help . clicked . connect ( self . open_help ) add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add_carbon . setIcon ( add_icon ) self . btn_add_carbon . clicked . connect ( self . _on_add_carbon_layer ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_delete_carbon . setIcon ( remove_icon ) self . btn_delete_carbon . setEnabled ( False ) self . btn_delete_carbon . clicked . connect ( self . _on_remove_carbon_layer ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit_carbon . setIcon ( edit_icon ) self . btn_edit_carbon . setEnabled ( False ) self . btn_edit_carbon . clicked . connect ( self . _on_edit_carbon_layer ) self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _edit_mode = False self . _layer = None self . _ncs_pathway = ncs_pathway if self . _ncs_pathway is not None : self . _edit_mode = True self . _layer = self . _ncs_pathway . to_map_layer () self . _update_controls () edit_mode property edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing NcsPathway object, else False if its creating a new object. layer property layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set. ncs_pathway property ncs_pathway Returns a reference to the NcsPathway object. Returns: Type Description NcsPathway Reference to the NcsPathway object. description_changed description_changed () Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 114 115 116 117 118 119 120 121 122 def description_changed ( self ): \"\"\"Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description \"\"\" description = self . txt_description . toPlainText () if len ( description ) > 300 : self . txt_description . setPlainText ( description [: 300 ]) open_help open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 340 341 342 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) selected_carbon_items selected_carbon_items () Returns the selected carbon items in the list view. Returns: Type Description list A collection of the selected carbon items. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 239 240 241 242 243 244 245 246 247 248 def selected_carbon_items ( self ) -> typing . List [ CarbonLayerItem ]: \"\"\"Returns the selected carbon items in the list view. :returns: A collection of the selected carbon items. :rtype: list \"\"\" selection_model = self . lst_carbon_layers . selectionModel () idxs = selection_model . selectedRows () return [ self . _carbon_model . item ( idx . row ()) for idx in idxs ] validate validate () Validates if name and layer have been specified. Returns: Type Description True True if user input (i.e. name and layer) have been set. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def validate ( self ) -> bool : \"\"\"Validates if name and layer have been specified. :returns: True if user input (i.e. name and layer) have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"NCS pathway name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . toPlainText (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False layer = self . _get_selected_map_layer () if layer is None : msg = tr ( \"Map layer not specified.\" ) self . _show_warning_message ( msg ) status = False if layer and not layer . isValid (): msg = tr ( \"Map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False return status","title":"NCS Pathway editor"},{"location":"developer/api/gui/api_ncs_pathway_editor/#ncs-pathway-editor","text":"Dialog for creating or editing an NCS pathway entry.","title":"NCS pathway editor"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog","text":"NcsPathwayEditorDialog ( parent = None , ncs_pathway = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an NCS pathway entry. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , parent = None , ncs_pathway = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . _carbon_model = CarbonLayerModel ( self ) self . lst_carbon_layers . setModel ( self . _carbon_model ) self . lst_carbon_layers . selectionModel () . selectionChanged . connect ( self . _on_selection_changed ) self . txt_description . textChanged . connect ( self . description_changed ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_add_layer . clicked . connect ( self . _on_select_file ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon ) self . btn_help . clicked . connect ( self . open_help ) add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add_carbon . setIcon ( add_icon ) self . btn_add_carbon . clicked . connect ( self . _on_add_carbon_layer ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_delete_carbon . setIcon ( remove_icon ) self . btn_delete_carbon . setEnabled ( False ) self . btn_delete_carbon . clicked . connect ( self . _on_remove_carbon_layer ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit_carbon . setIcon ( edit_icon ) self . btn_edit_carbon . setEnabled ( False ) self . btn_edit_carbon . clicked . connect ( self . _on_edit_carbon_layer ) self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _edit_mode = False self . _layer = None self . _ncs_pathway = ncs_pathway if self . _ncs_pathway is not None : self . _edit_mode = True self . _layer = self . _ncs_pathway . to_map_layer () self . _update_controls ()","title":"NcsPathwayEditorDialog"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.edit_mode","text":"edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing NcsPathway object, else False if its creating a new object.","title":"edit_mode"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.layer","text":"layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set.","title":"layer"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.ncs_pathway","text":"ncs_pathway Returns a reference to the NcsPathway object. Returns: Type Description NcsPathway Reference to the NcsPathway object.","title":"ncs_pathway"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.description_changed","text":"description_changed () Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 114 115 116 117 118 119 120 121 122 def description_changed ( self ): \"\"\"Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description \"\"\" description = self . txt_description . toPlainText () if len ( description ) > 300 : self . txt_description . setPlainText ( description [: 300 ])","title":"description_changed()"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.open_help","text":"open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 340 341 342 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help()"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.selected_carbon_items","text":"selected_carbon_items () Returns the selected carbon items in the list view. Returns: Type Description list A collection of the selected carbon items. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 239 240 241 242 243 244 245 246 247 248 def selected_carbon_items ( self ) -> typing . List [ CarbonLayerItem ]: \"\"\"Returns the selected carbon items in the list view. :returns: A collection of the selected carbon items. :rtype: list \"\"\" selection_model = self . lst_carbon_layers . selectionModel () idxs = selection_model . selectedRows () return [ self . _carbon_model . item ( idx . row ()) for idx in idxs ]","title":"selected_carbon_items()"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.validate","text":"validate () Validates if name and layer have been specified. Returns: Type Description True True if user input (i.e. name and layer) have been set. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def validate ( self ) -> bool : \"\"\"Validates if name and layer have been specified. :returns: True if user input (i.e. name and layer) have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"NCS pathway name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . toPlainText (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False layer = self . _get_selected_map_layer () if layer is None : msg = tr ( \"Map layer not specified.\" ) self . _show_warning_message ( msg ) status = False if layer and not layer . isValid (): msg = tr ( \"Map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False return status","title":"validate()"},{"location":"developer/api/gui/api_pixel_value_editor/","text":"Style pixel value editor Dialog for setting the pixel value for styling IMs. PixelValueEditorDialog PixelValueEditorDialog ( parent = None ) Bases: QDialog , WidgetUi Dialog for setting the pixel value for styling IMs. Source code in src/cplus_plugin/gui/pixel_value_editor_dialog.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon ) self . btn_help . clicked . connect ( self . open_help ) self . _item_model = QtGui . QStandardItemModel ( self ) self . _item_model . setColumnCount ( 1 ) self . tv_implementation_model . setModel ( self . _item_model ) self . tv_implementation_model . setDragEnabled ( True ) self . tv_implementation_model . setAcceptDrops ( True ) self . tv_implementation_model . setShowGrid ( False ) self . tv_implementation_model . setDragDropOverwriteMode ( False ) self . tv_implementation_model . setDragDropMode ( QtWidgets . QAbstractItemView . InternalMove ) self . tv_implementation_model . horizontalHeader () . setSectionResizeMode ( QtWidgets . QHeaderView . Stretch ) self . _load_items () item_mapping property item_mapping Returns a mapping of the implementation model position in the table and its corresponding unique identifier. We are using an OrderedDict to ensure consistency across different Python versions in the different platforms that QGIS runs on. Returns: Type Description OrderedDict The mapping of the implementation model position in the table and its corresponding unique identifier. open_help open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/pixel_value_editor_dialog.py 70 71 72 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"Pixel Values editor"},{"location":"developer/api/gui/api_pixel_value_editor/#style-pixel-value-editor","text":"Dialog for setting the pixel value for styling IMs.","title":"Style pixel value editor"},{"location":"developer/api/gui/api_pixel_value_editor/#src.cplus_plugin.gui.pixel_value_editor_dialog.PixelValueEditorDialog","text":"PixelValueEditorDialog ( parent = None ) Bases: QDialog , WidgetUi Dialog for setting the pixel value for styling IMs. Source code in src/cplus_plugin/gui/pixel_value_editor_dialog.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon ) self . btn_help . clicked . connect ( self . open_help ) self . _item_model = QtGui . QStandardItemModel ( self ) self . _item_model . setColumnCount ( 1 ) self . tv_implementation_model . setModel ( self . _item_model ) self . tv_implementation_model . setDragEnabled ( True ) self . tv_implementation_model . setAcceptDrops ( True ) self . tv_implementation_model . setShowGrid ( False ) self . tv_implementation_model . setDragDropOverwriteMode ( False ) self . tv_implementation_model . setDragDropMode ( QtWidgets . QAbstractItemView . InternalMove ) self . tv_implementation_model . horizontalHeader () . setSectionResizeMode ( QtWidgets . QHeaderView . Stretch ) self . _load_items ()","title":"PixelValueEditorDialog"},{"location":"developer/api/gui/api_pixel_value_editor/#src.cplus_plugin.gui.pixel_value_editor_dialog.PixelValueEditorDialog.item_mapping","text":"item_mapping Returns a mapping of the implementation model position in the table and its corresponding unique identifier. We are using an OrderedDict to ensure consistency across different Python versions in the different platforms that QGIS runs on. Returns: Type Description OrderedDict The mapping of the implementation model position in the table and its corresponding unique identifier.","title":"item_mapping"},{"location":"developer/api/gui/api_pixel_value_editor/#src.cplus_plugin.gui.pixel_value_editor_dialog.PixelValueEditorDialog.open_help","text":"open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/pixel_value_editor_dialog.py 70 71 72 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help()"},{"location":"developer/api/gui/api_priority_group/","text":"Priority group Priority group item widget PriorityGroupWidget PriorityGroupWidget ( group , parent = None ) Bases: QWidget , WidgetUi Widget that provide UI for priority group details. Source code in src/cplus_plugin/gui/priority_group_widget.py 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , group , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . group = group self . initialize_ui () group_value group_value () Returns: name (dict): Priority group value Source code in src/cplus_plugin/gui/priority_group_widget.py 72 73 74 75 76 77 def group_value ( self ): \"\"\" Returns: name (dict): Priority group value \"\"\" return self . group_slider . value () initialize_ui initialize_ui () Populate UI inputs when loading the widget Source code in src/cplus_plugin/gui/priority_group_widget.py 40 41 42 43 44 45 46 47 48 49 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the widget\"\"\" if self . group is not None : self . group_la . setText ( self . group . get ( \"name\" )) self . group_slider . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_spin_box . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_slider . valueChanged . connect ( self . update_spin_box ) self . group_spin_box . valueChanged . connect ( self . update_slider ) name name () Returns: name (dict): Priority group name Source code in src/cplus_plugin/gui/priority_group_widget.py 65 66 67 68 69 70 def name ( self ): \"\"\" Returns: name (dict): Priority group name \"\"\" return self . group . get ( \"name\" ) set_group set_group ( group ) Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group Source code in src/cplus_plugin/gui/priority_group_widget.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def set_group ( self , group ): \"\"\"Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group \"\"\" if group is not None : self . group = group self . group_la . setText ( group . get ( \"name\" )) self . group_slider . setValue ( int ( group [ \"value\" ])) self . group_spin_box . setValue ( int ( group [ \"value\" ])) update_slider update_slider ( value ) Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 79 80 81 82 83 84 85 86 87 88 89 90 91 def update_slider ( self , value ): \"\"\"Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal \"\"\" if self . group is not None : self . input_value_changed . emit ( self . group [ \"name\" ], value ) self . group_slider . blockSignals ( True ) self . group_slider . setValue ( value ) self . group_slider . blockSignals ( False ) update_spin_box update_spin_box ( value ) Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def update_spin_box ( self , value ): \"\"\"Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal \"\"\" if self . group is not None : self . slider_value_changed . emit ( self . group [ \"name\" ], value ) self . group_spin_box . blockSignals ( True ) self . group_spin_box . setValue ( value ) self . group_spin_box . blockSignals ( False ) widgets widgets () Returns widget_list (list): List of component widgets for the priority group widget Source code in src/cplus_plugin/gui/priority_group_widget.py 108 109 110 111 112 113 114 def widgets ( self ) -> typing . List [ QtWidgets . QWidget ]: \"\"\" Returns widget_list (list): List of component widgets for the priority group widget \"\"\" return [ self . group_la , self . group_slider , self . group_spin_box ]","title":"Priority group"},{"location":"developer/api/gui/api_priority_group/#priority-group","text":"Priority group item widget","title":"Priority group"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget","text":"PriorityGroupWidget ( group , parent = None ) Bases: QWidget , WidgetUi Widget that provide UI for priority group details. Source code in src/cplus_plugin/gui/priority_group_widget.py 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , group , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . group = group self . initialize_ui ()","title":"PriorityGroupWidget"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.group_value","text":"group_value () Returns: name (dict): Priority group value Source code in src/cplus_plugin/gui/priority_group_widget.py 72 73 74 75 76 77 def group_value ( self ): \"\"\" Returns: name (dict): Priority group value \"\"\" return self . group_slider . value ()","title":"group_value()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.initialize_ui","text":"initialize_ui () Populate UI inputs when loading the widget Source code in src/cplus_plugin/gui/priority_group_widget.py 40 41 42 43 44 45 46 47 48 49 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the widget\"\"\" if self . group is not None : self . group_la . setText ( self . group . get ( \"name\" )) self . group_slider . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_spin_box . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_slider . valueChanged . connect ( self . update_spin_box ) self . group_spin_box . valueChanged . connect ( self . update_slider )","title":"initialize_ui()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.name","text":"name () Returns: name (dict): Priority group name Source code in src/cplus_plugin/gui/priority_group_widget.py 65 66 67 68 69 70 def name ( self ): \"\"\" Returns: name (dict): Priority group name \"\"\" return self . group . get ( \"name\" )","title":"name()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.set_group","text":"set_group ( group ) Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group Source code in src/cplus_plugin/gui/priority_group_widget.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def set_group ( self , group ): \"\"\"Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group \"\"\" if group is not None : self . group = group self . group_la . setText ( group . get ( \"name\" )) self . group_slider . setValue ( int ( group [ \"value\" ])) self . group_spin_box . setValue ( int ( group [ \"value\" ]))","title":"set_group()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.update_slider","text":"update_slider ( value ) Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 79 80 81 82 83 84 85 86 87 88 89 90 91 def update_slider ( self , value ): \"\"\"Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal \"\"\" if self . group is not None : self . input_value_changed . emit ( self . group [ \"name\" ], value ) self . group_slider . blockSignals ( True ) self . group_slider . setValue ( value ) self . group_slider . blockSignals ( False )","title":"update_slider()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.update_spin_box","text":"update_spin_box ( value ) Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def update_spin_box ( self , value ): \"\"\"Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal \"\"\" if self . group is not None : self . slider_value_changed . emit ( self . group [ \"name\" ], value ) self . group_spin_box . blockSignals ( True ) self . group_spin_box . setValue ( value ) self . group_spin_box . blockSignals ( False )","title":"update_spin_box()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.widgets","text":"widgets () Returns widget_list (list): List of component widgets for the priority group widget Source code in src/cplus_plugin/gui/priority_group_widget.py 108 109 110 111 112 113 114 def widgets ( self ) -> typing . List [ QtWidgets . QWidget ]: \"\"\" Returns widget_list (list): List of component widgets for the priority group widget \"\"\" return [ self . group_la , self . group_slider , self . group_spin_box ]","title":"widgets()"},{"location":"developer/api/gui/api_priority_layer/","text":"Priority weighting layer dialog Priority layer dialog PriorityLayerDialog PriorityLayerDialog ( layer = None , parent = None ) Bases: QDialog , DialogUi Dialog that provide UI for priority layer details. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def __init__ ( self , layer = None , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . layer = layer self . button_box . button ( QtWidgets . QDialogButtonBox . Ok ) . setEnabled ( False ) self . map_layer_box . layerChanged . connect ( self . map_layer_changed ) ok_signals = [ self . layer_name . textChanged , self . layer_description . textChanged , self . map_layer_file_widget . fileChanged , self . map_layer_box . layerChanged , ] for signal in ok_signals : signal . connect ( self . update_ok_buttons ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . _user_defined = True self . models = [] self . initialize_ui () accept accept () Handles logic for adding new priority layer and edit existing one Source code in src/cplus_plugin/gui/priority_layer_dialog.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def accept ( self ): \"\"\"Handles logic for adding new priority layer and edit existing one\"\"\" layer_id = uuid . uuid4 () layer_groups = [] layer = {} if self . layer is not None : layer_id = self . layer . get ( \"uuid\" ) layer_groups = self . layer . get ( \"groups\" , []) layer [ \"uuid\" ] = str ( layer_id ) layer [ \"name\" ] = self . layer_name . text () layer [ \"description\" ] = self . layer_description . toPlainText () layer [ \"groups\" ] = layer_groups layer [ \"path\" ] = self . map_layer_file_widget . filePath () layer [ USER_DEFINED_ATTRIBUTE ] = self . _user_defined settings_manager . save_priority_layer ( layer ) self . layer = layer self . set_selected_items ( self . models ) super () . accept () initialize_ui initialize_ui () Populate UI inputs when loading the dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the dialog\"\"\" self . btn_help . setIcon ( FileUtils . get_icon ( \"mActionHelpContents.svg\" )) self . btn_help . clicked . connect ( self . open_help ) self . map_layer_file_widget . setStorageMode ( QgsFileWidget . StorageMode . GetFile ) self . select_models_btn . clicked . connect ( self . open_layer_select_dialog ) if self . layer is not None : layer_path = self . layer . get ( \"path\" ) layer_uuids = [ layer . get ( \"uuid\" ) for layer in PRIORITY_LAYERS ] if not os . path . isabs ( layer_path ) and self . layer . get ( \"uuid\" ) in layer_uuids : base_dir = settings_manager . get_value ( Settings . BASE_DIR ) layer_path = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } / { layer_path } \" self . layer_name . setText ( self . layer [ \"name\" ]) self . layer_description . setText ( self . layer [ \"description\" ]) self . map_layer_file_widget . setFilePath ( layer_path ) all_models = settings_manager . get_all_implementation_models () for model in all_models : model_layer_uuids = [ layer . get ( \"uuid\" ) for layer in model . priority_layers if layer is not None ] if str ( self . layer . get ( \"uuid\" )) in model_layer_uuids : self . models . append ( model ) self . set_selected_items ( self . models ) self . _user_defined = self . layer . get ( USER_DEFINED_ATTRIBUTE , True ) map_layer_changed map_layer_changed ( layer ) Sets the file path of the selected layer in file path input Parameters: Name Type Description Default layer QgsMapLayer Qgis map layer required Source code in src/cplus_plugin/gui/priority_layer_dialog.py 66 67 68 69 70 71 72 73 def map_layer_changed ( self , layer ): \"\"\"Sets the file path of the selected layer in file path input :param layer: Qgis map layer :type layer: QgsMapLayer \"\"\" if layer is not None : self . map_layer_file_widget . setFilePath ( layer . source ()) open_help open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/priority_layer_dialog.py 217 218 219 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) open_layer_select_dialog open_layer_select_dialog () Opens priority layer item selection dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 130 131 132 133 def open_layer_select_dialog ( self ): \"\"\"Opens priority layer item selection dialog\"\"\" model_select_dialog = ItemsSelectionDialog ( self , self . layer , self . models ) model_select_dialog . exec_ () set_selected_items set_selected_items ( models , removed_models = []) Adds this dialog layer into the passed models and removes it from the unselected models passed as removed_models. Parameters: Name Type Description Default models list Selected implementation models required removed_models list Implementation models that dialog layer should be removed from. [] Source code in src/cplus_plugin/gui/priority_layer_dialog.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def set_selected_items ( self , models , removed_models = []): \"\"\"Adds this dialog layer into the passed models and removes it from the unselected models passed as removed_models. :param models: Selected implementation models :type models: list :param removed_models: Implementation models that dialog layer should be removed from. :type removed_models: list \"\"\" self . models = models models_names = [ model . name for model in models ] self . selected_models_le . setText ( \" , \" . join ( models_names )) if not self . layer : return if len ( removed_models ) <= 0 : all_models = settings_manager . get_all_implementation_models () removed_models = [ model for model in all_models if model . name not in models_names ] for model in models : models_layer_uuids = [ str ( layer . get ( \"uuid\" )) for layer in model . priority_layers if layer is not None ] if ( self . layer is not None and str ( self . layer . get ( \"uuid\" )) not in models_layer_uuids ): model . priority_layers . append ( self . layer ) settings_manager . save_implementation_model ( model ) # remove redundant priority layers for layer in model . priority_layers : if layer is not None : layer_settings = settings_manager . get_priority_layer ( str ( layer . get ( \"uuid\" )) ) if layer_settings is None : model . priority_layers . remove ( layer ) settings_manager . save_implementation_model ( model ) for model in removed_models : for layer in model . priority_layers : if layer is None : continue if str ( layer . get ( \"uuid\" )) == str ( self . layer . get ( \"uuid\" )): model . priority_layers . remove ( layer ) settings_manager . save_implementation_model ( model ) update_ok_buttons update_ok_buttons () Responsible for changing the state of the dialog OK button. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def update_ok_buttons ( self ): \"\"\"Responsible for changing the state of the dialog OK button. \"\"\" enabled_state = ( self . layer_name . text () != \"\" and self . layer_description . toPlainText () != \"\" and ( self . map_layer_box . currentLayer () is not None or ( self . map_layer_file_widget . filePath () is not None and self . map_layer_file_widget . filePath () is not \"\" ) ) ) self . button_box . button ( QtWidgets . QDialogButtonBox . Ok ) . setEnabled ( enabled_state )","title":"Priority layer dialog"},{"location":"developer/api/gui/api_priority_layer/#priority-weighting-layer-dialog","text":"Priority layer dialog","title":"Priority weighting layer dialog"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog","text":"PriorityLayerDialog ( layer = None , parent = None ) Bases: QDialog , DialogUi Dialog that provide UI for priority layer details. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def __init__ ( self , layer = None , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . layer = layer self . button_box . button ( QtWidgets . QDialogButtonBox . Ok ) . setEnabled ( False ) self . map_layer_box . layerChanged . connect ( self . map_layer_changed ) ok_signals = [ self . layer_name . textChanged , self . layer_description . textChanged , self . map_layer_file_widget . fileChanged , self . map_layer_box . layerChanged , ] for signal in ok_signals : signal . connect ( self . update_ok_buttons ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . _user_defined = True self . models = [] self . initialize_ui ()","title":"PriorityLayerDialog"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.accept","text":"accept () Handles logic for adding new priority layer and edit existing one Source code in src/cplus_plugin/gui/priority_layer_dialog.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def accept ( self ): \"\"\"Handles logic for adding new priority layer and edit existing one\"\"\" layer_id = uuid . uuid4 () layer_groups = [] layer = {} if self . layer is not None : layer_id = self . layer . get ( \"uuid\" ) layer_groups = self . layer . get ( \"groups\" , []) layer [ \"uuid\" ] = str ( layer_id ) layer [ \"name\" ] = self . layer_name . text () layer [ \"description\" ] = self . layer_description . toPlainText () layer [ \"groups\" ] = layer_groups layer [ \"path\" ] = self . map_layer_file_widget . filePath () layer [ USER_DEFINED_ATTRIBUTE ] = self . _user_defined settings_manager . save_priority_layer ( layer ) self . layer = layer self . set_selected_items ( self . models ) super () . accept ()","title":"accept()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.initialize_ui","text":"initialize_ui () Populate UI inputs when loading the dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the dialog\"\"\" self . btn_help . setIcon ( FileUtils . get_icon ( \"mActionHelpContents.svg\" )) self . btn_help . clicked . connect ( self . open_help ) self . map_layer_file_widget . setStorageMode ( QgsFileWidget . StorageMode . GetFile ) self . select_models_btn . clicked . connect ( self . open_layer_select_dialog ) if self . layer is not None : layer_path = self . layer . get ( \"path\" ) layer_uuids = [ layer . get ( \"uuid\" ) for layer in PRIORITY_LAYERS ] if not os . path . isabs ( layer_path ) and self . layer . get ( \"uuid\" ) in layer_uuids : base_dir = settings_manager . get_value ( Settings . BASE_DIR ) layer_path = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } / { layer_path } \" self . layer_name . setText ( self . layer [ \"name\" ]) self . layer_description . setText ( self . layer [ \"description\" ]) self . map_layer_file_widget . setFilePath ( layer_path ) all_models = settings_manager . get_all_implementation_models () for model in all_models : model_layer_uuids = [ layer . get ( \"uuid\" ) for layer in model . priority_layers if layer is not None ] if str ( self . layer . get ( \"uuid\" )) in model_layer_uuids : self . models . append ( model ) self . set_selected_items ( self . models ) self . _user_defined = self . layer . get ( USER_DEFINED_ATTRIBUTE , True )","title":"initialize_ui()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.map_layer_changed","text":"map_layer_changed ( layer ) Sets the file path of the selected layer in file path input Parameters: Name Type Description Default layer QgsMapLayer Qgis map layer required Source code in src/cplus_plugin/gui/priority_layer_dialog.py 66 67 68 69 70 71 72 73 def map_layer_changed ( self , layer ): \"\"\"Sets the file path of the selected layer in file path input :param layer: Qgis map layer :type layer: QgsMapLayer \"\"\" if layer is not None : self . map_layer_file_widget . setFilePath ( layer . source ())","title":"map_layer_changed()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.open_help","text":"open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/priority_layer_dialog.py 217 218 219 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.open_layer_select_dialog","text":"open_layer_select_dialog () Opens priority layer item selection dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 130 131 132 133 def open_layer_select_dialog ( self ): \"\"\"Opens priority layer item selection dialog\"\"\" model_select_dialog = ItemsSelectionDialog ( self , self . layer , self . models ) model_select_dialog . exec_ ()","title":"open_layer_select_dialog()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.set_selected_items","text":"set_selected_items ( models , removed_models = []) Adds this dialog layer into the passed models and removes it from the unselected models passed as removed_models. Parameters: Name Type Description Default models list Selected implementation models required removed_models list Implementation models that dialog layer should be removed from. [] Source code in src/cplus_plugin/gui/priority_layer_dialog.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def set_selected_items ( self , models , removed_models = []): \"\"\"Adds this dialog layer into the passed models and removes it from the unselected models passed as removed_models. :param models: Selected implementation models :type models: list :param removed_models: Implementation models that dialog layer should be removed from. :type removed_models: list \"\"\" self . models = models models_names = [ model . name for model in models ] self . selected_models_le . setText ( \" , \" . join ( models_names )) if not self . layer : return if len ( removed_models ) <= 0 : all_models = settings_manager . get_all_implementation_models () removed_models = [ model for model in all_models if model . name not in models_names ] for model in models : models_layer_uuids = [ str ( layer . get ( \"uuid\" )) for layer in model . priority_layers if layer is not None ] if ( self . layer is not None and str ( self . layer . get ( \"uuid\" )) not in models_layer_uuids ): model . priority_layers . append ( self . layer ) settings_manager . save_implementation_model ( model ) # remove redundant priority layers for layer in model . priority_layers : if layer is not None : layer_settings = settings_manager . get_priority_layer ( str ( layer . get ( \"uuid\" )) ) if layer_settings is None : model . priority_layers . remove ( layer ) settings_manager . save_implementation_model ( model ) for model in removed_models : for layer in model . priority_layers : if layer is None : continue if str ( layer . get ( \"uuid\" )) == str ( self . layer . get ( \"uuid\" )): model . priority_layers . remove ( layer ) settings_manager . save_implementation_model ( model )","title":"set_selected_items()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.update_ok_buttons","text":"update_ok_buttons () Responsible for changing the state of the dialog OK button. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def update_ok_buttons ( self ): \"\"\"Responsible for changing the state of the dialog OK button. \"\"\" enabled_state = ( self . layer_name . text () != \"\" and self . layer_description . toPlainText () != \"\" and ( self . map_layer_box . currentLayer () is not None or ( self . map_layer_file_widget . filePath () is not None and self . map_layer_file_widget . filePath () is not \"\" ) ) ) self . button_box . button ( QtWidgets . QDialogButtonBox . Ok ) . setEnabled ( enabled_state )","title":"update_ok_buttons()"},{"location":"developer/api/gui/api_progress_dialog/","text":"Progress dialog Analysis progress dialog file ProgressDialog ProgressDialog ( message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None ) Bases: QDialog , Ui_DlgProgress Progress dialog class Source code in src/cplus_plugin/gui/progress_dialog.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def __init__ ( self , message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . scenario_id = scenario_id self . scenario_name = scenario_name self . main_widget = main_widget self . report_manager = report_manager self . analysis_task = None # Dialog window flags flags = QtCore . Qt . WindowMinimizeButtonHint | QtCore . Qt . WindowCloseButtonHint self . setWindowFlags ( flags ) # Dialog statuses self . analysis_running = True if message is None : self . change_status_message ( tr ( \"Starting processing\" )) else : self . change_status_message ( message ) if scenario_name : self . title . setText ( f \" { self . title . text () } for scenario <b> { self . scenario_name } </b>\" ) # Report status self . report_running = False # Progress bar self . progress_bar . setAlignment ( QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter ) self . progress_bar . setMinimum ( minimum ) self . progress_bar . setMaximum ( maximum ) # Report menu self . menu = QMenu ( \"&View Report\" ) self . btn_view_report . setMenu ( self . menu ) self . btn_view_report . setIcon ( QIcon ( ICON_REPORT )) # Menu button to open report in Layout designer self . designer_action = QAction ( QIcon ( ICON_LAYOUT ), \"Layout designer\" , parent = self ) self . designer_action . triggered . connect ( self . view_report_layout_designer ) self . designer_action . setEnabled ( False ) self . menu . addAction ( self . designer_action ) # Open a PDF version of the report self . pdf_action = QAction ( QIcon ( ICON_PDF ), \"Open PDF\" , parent = self ) self . pdf_action . triggered . connect ( self . view_report_pdf ) self . pdf_action . setEnabled ( False ) self . menu . addAction ( self . pdf_action ) # Open a Help for reports action = QAction ( QIcon ( ICON_HELP ), \"Help\" , parent = self ) action . triggered . connect ( self . open_report_help ) action . setEnabled ( True ) self . menu . addAction ( action ) # Connections self . btn_cancel . clicked . connect ( self . cancel_clicked ) self . analysis_finished_message = tr ( \"Analysis has finished.\" ) cancel_clicked cancel_clicked () User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. Source code in src/cplus_plugin/gui/progress_dialog.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def cancel_clicked ( self ) -> None : \"\"\"User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. \"\"\" self . analysis_cancelled . emit () self . cancel_reporting () if self . analysis_running : # If cancelled is clicked self . stop_processing () try : if self . analysis_task : self . analysis_task . processing_cancelled = True self . analysis_task . cancel () except RuntimeError as e : # The analysis task should have been removed after # scenario analyis is done, this is the only way to find # out if the analysis has been completed. pass else : # If close has been clicked. In this case processing were already stopped super () . close () cancel_reporting cancel_reporting () Cancel the report generation process. Source code in src/cplus_plugin/gui/progress_dialog.py 223 224 225 226 def cancel_reporting ( self ): \"\"\"Cancel the report generation process.\"\"\" if self . report_running : self . report_manager . remove_report_task ( self . scenario_id ) change_status_message change_status_message ( message = None ) Updates the status message Parameters: Name Type Description Default message str Message to show on the status bar None Source code in src/cplus_plugin/gui/progress_dialog.py 146 147 148 149 150 151 152 153 154 def change_status_message ( self , message = None ) -> None : \"\"\"Updates the status message :param message: Message to show on the status bar :type message: str \"\"\" if message : self . lbl_status . setText ( message ) get_processing_status get_processing_status () Returns the status of the processing. Returns: Type Description bool Status of processing. Source code in src/cplus_plugin/gui/progress_dialog.py 116 117 118 119 120 121 122 123 def get_processing_status ( self ) -> bool : \"\"\"Returns the status of the processing. :returns: Status of processing. :rtype: bool \"\"\" return self . analysis_running get_progress_bar get_progress_bar () Returns a reference to the Progress bar object. Returns: Type Description QProgressBar Progress bar Source code in src/cplus_plugin/gui/progress_dialog.py 125 126 127 128 129 130 131 132 def get_progress_bar ( self ) -> QProgressBar : \"\"\"Returns a reference to the Progress bar object. :returns: Progress bar :rtype: QProgressBar \"\"\" return self . progress_bar open_report_help open_report_help () Opens the Report guide in a browser Source code in src/cplus_plugin/gui/progress_dialog.py 193 194 195 def open_report_help ( self ) -> None : \"\"\"Opens the Report guide in a browser\"\"\" open_documentation ( REPORT_DOCUMENTATION ) processing_cancelled processing_cancelled () Post-steps when processing were cancelled. Source code in src/cplus_plugin/gui/progress_dialog.py 259 260 261 262 263 264 265 266 def processing_cancelled ( self ) -> None : \"\"\"Post-steps when processing were cancelled.\"\"\" self . analysis_running = False # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( False ) processing_finished processing_finished () Post-steps when processing succeeded. Source code in src/cplus_plugin/gui/progress_dialog.py 268 269 270 271 272 273 274 275 276 277 278 def processing_finished ( self ) -> None : \"\"\"Post-steps when processing succeeded.\"\"\" self . analysis_running = False self . change_status_message ( self . analysis_finished_message ) # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( True ) icon = self . style () . standardIcon ( QStyle . SP_DialogCloseButton ) self . btn_cancel . setIcon ( icon ) reject reject () Called when the dialog is closed Source code in src/cplus_plugin/gui/progress_dialog.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def reject ( self ) -> None : \"\"\"Called when the dialog is closed\"\"\" self . analysis_cancelled . emit () if self . analysis_running : # Stops analysis if it is still running self . stop_processing () try : if self . analysis_task : self . analysis_task . processing_cancelled = True self . analysis_task . cancel () except RuntimeError as e : # The analysis task should have been removed after # scenario analyis is done, this is the only way to find # out if the analysis has been completed. pass self . cancel_reporting () super () . reject () run_dialog run_dialog () Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. Source code in src/cplus_plugin/gui/progress_dialog.py 108 109 110 111 112 113 114 def run_dialog ( self ): \"\"\"Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. \"\"\" self . setModal ( False ) self . show () set_report_complete set_report_complete () Enable layout designer and PDF report buttons. Source code in src/cplus_plugin/gui/progress_dialog.py 156 157 158 159 160 161 162 163 def set_report_complete ( self ): \"\"\"Enable layout designer and PDF report buttons.\"\"\" self . btn_view_report . setEnabled ( True ) self . designer_action . setEnabled ( True ) self . pdf_action . setEnabled ( True ) self . report_running = False self . processing_finished () stop_processing stop_processing () The user cancelled the processing. Source code in src/cplus_plugin/gui/progress_dialog.py 248 249 250 251 252 253 254 255 256 257 def stop_processing ( self ) -> None : \"\"\"The user cancelled the processing.\"\"\" self . change_status_message ( tr ( \"Processing has been cancelled by the user\" )) # Stops the processing task if self . main_widget : self . main_widget . cancel_processing_task () self . processing_cancelled () update_progress_bar update_progress_bar ( value ) Sets the value of the progress bar Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/progress_dialog.py 134 135 136 137 138 139 140 141 142 143 144 def update_progress_bar ( self , value ) -> None : \"\"\"Sets the value of the progress bar :param value: Value to be set on the progress bar :type value: float \"\"\" if self . progress_bar : try : self . progress_bar . setValue ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False ) view_report_layout_designer view_report_layout_designer () Opens the report in layout designer Source code in src/cplus_plugin/gui/progress_dialog.py 179 180 181 182 183 184 185 186 187 188 189 190 191 def view_report_layout_designer ( self ) -> None : \"\"\"Opens the report in layout designer\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = self . report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = self . report_manager . open_layout_designer ( result ) if not status : log ( \"Unable to open layout designer.\" ) view_report_pdf view_report_pdf () Opens a PDF version of the report Source code in src/cplus_plugin/gui/progress_dialog.py 165 166 167 168 169 170 171 172 173 174 175 176 177 def view_report_pdf ( self ) -> None : \"\"\"Opens a PDF version of the report\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = self . report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = self . report_manager . view_pdf ( result ) if not status : log ( \"Unable to open PDF report.\" )","title":"Progress dialog"},{"location":"developer/api/gui/api_progress_dialog/#progress-dialog","text":"Analysis progress dialog file","title":"Progress dialog"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog","text":"ProgressDialog ( message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None ) Bases: QDialog , Ui_DlgProgress Progress dialog class Source code in src/cplus_plugin/gui/progress_dialog.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def __init__ ( self , message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . scenario_id = scenario_id self . scenario_name = scenario_name self . main_widget = main_widget self . report_manager = report_manager self . analysis_task = None # Dialog window flags flags = QtCore . Qt . WindowMinimizeButtonHint | QtCore . Qt . WindowCloseButtonHint self . setWindowFlags ( flags ) # Dialog statuses self . analysis_running = True if message is None : self . change_status_message ( tr ( \"Starting processing\" )) else : self . change_status_message ( message ) if scenario_name : self . title . setText ( f \" { self . title . text () } for scenario <b> { self . scenario_name } </b>\" ) # Report status self . report_running = False # Progress bar self . progress_bar . setAlignment ( QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter ) self . progress_bar . setMinimum ( minimum ) self . progress_bar . setMaximum ( maximum ) # Report menu self . menu = QMenu ( \"&View Report\" ) self . btn_view_report . setMenu ( self . menu ) self . btn_view_report . setIcon ( QIcon ( ICON_REPORT )) # Menu button to open report in Layout designer self . designer_action = QAction ( QIcon ( ICON_LAYOUT ), \"Layout designer\" , parent = self ) self . designer_action . triggered . connect ( self . view_report_layout_designer ) self . designer_action . setEnabled ( False ) self . menu . addAction ( self . designer_action ) # Open a PDF version of the report self . pdf_action = QAction ( QIcon ( ICON_PDF ), \"Open PDF\" , parent = self ) self . pdf_action . triggered . connect ( self . view_report_pdf ) self . pdf_action . setEnabled ( False ) self . menu . addAction ( self . pdf_action ) # Open a Help for reports action = QAction ( QIcon ( ICON_HELP ), \"Help\" , parent = self ) action . triggered . connect ( self . open_report_help ) action . setEnabled ( True ) self . menu . addAction ( action ) # Connections self . btn_cancel . clicked . connect ( self . cancel_clicked ) self . analysis_finished_message = tr ( \"Analysis has finished.\" )","title":"ProgressDialog"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.cancel_clicked","text":"cancel_clicked () User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. Source code in src/cplus_plugin/gui/progress_dialog.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def cancel_clicked ( self ) -> None : \"\"\"User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. \"\"\" self . analysis_cancelled . emit () self . cancel_reporting () if self . analysis_running : # If cancelled is clicked self . stop_processing () try : if self . analysis_task : self . analysis_task . processing_cancelled = True self . analysis_task . cancel () except RuntimeError as e : # The analysis task should have been removed after # scenario analyis is done, this is the only way to find # out if the analysis has been completed. pass else : # If close has been clicked. In this case processing were already stopped super () . close ()","title":"cancel_clicked()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.cancel_reporting","text":"cancel_reporting () Cancel the report generation process. Source code in src/cplus_plugin/gui/progress_dialog.py 223 224 225 226 def cancel_reporting ( self ): \"\"\"Cancel the report generation process.\"\"\" if self . report_running : self . report_manager . remove_report_task ( self . scenario_id )","title":"cancel_reporting()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.change_status_message","text":"change_status_message ( message = None ) Updates the status message Parameters: Name Type Description Default message str Message to show on the status bar None Source code in src/cplus_plugin/gui/progress_dialog.py 146 147 148 149 150 151 152 153 154 def change_status_message ( self , message = None ) -> None : \"\"\"Updates the status message :param message: Message to show on the status bar :type message: str \"\"\" if message : self . lbl_status . setText ( message )","title":"change_status_message()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.get_processing_status","text":"get_processing_status () Returns the status of the processing. Returns: Type Description bool Status of processing. Source code in src/cplus_plugin/gui/progress_dialog.py 116 117 118 119 120 121 122 123 def get_processing_status ( self ) -> bool : \"\"\"Returns the status of the processing. :returns: Status of processing. :rtype: bool \"\"\" return self . analysis_running","title":"get_processing_status()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.get_progress_bar","text":"get_progress_bar () Returns a reference to the Progress bar object. Returns: Type Description QProgressBar Progress bar Source code in src/cplus_plugin/gui/progress_dialog.py 125 126 127 128 129 130 131 132 def get_progress_bar ( self ) -> QProgressBar : \"\"\"Returns a reference to the Progress bar object. :returns: Progress bar :rtype: QProgressBar \"\"\" return self . progress_bar","title":"get_progress_bar()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.open_report_help","text":"open_report_help () Opens the Report guide in a browser Source code in src/cplus_plugin/gui/progress_dialog.py 193 194 195 def open_report_help ( self ) -> None : \"\"\"Opens the Report guide in a browser\"\"\" open_documentation ( REPORT_DOCUMENTATION )","title":"open_report_help()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.processing_cancelled","text":"processing_cancelled () Post-steps when processing were cancelled. Source code in src/cplus_plugin/gui/progress_dialog.py 259 260 261 262 263 264 265 266 def processing_cancelled ( self ) -> None : \"\"\"Post-steps when processing were cancelled.\"\"\" self . analysis_running = False # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( False )","title":"processing_cancelled()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.processing_finished","text":"processing_finished () Post-steps when processing succeeded. Source code in src/cplus_plugin/gui/progress_dialog.py 268 269 270 271 272 273 274 275 276 277 278 def processing_finished ( self ) -> None : \"\"\"Post-steps when processing succeeded.\"\"\" self . analysis_running = False self . change_status_message ( self . analysis_finished_message ) # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( True ) icon = self . style () . standardIcon ( QStyle . SP_DialogCloseButton ) self . btn_cancel . setIcon ( icon )","title":"processing_finished()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.reject","text":"reject () Called when the dialog is closed Source code in src/cplus_plugin/gui/progress_dialog.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def reject ( self ) -> None : \"\"\"Called when the dialog is closed\"\"\" self . analysis_cancelled . emit () if self . analysis_running : # Stops analysis if it is still running self . stop_processing () try : if self . analysis_task : self . analysis_task . processing_cancelled = True self . analysis_task . cancel () except RuntimeError as e : # The analysis task should have been removed after # scenario analyis is done, this is the only way to find # out if the analysis has been completed. pass self . cancel_reporting () super () . reject ()","title":"reject()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.run_dialog","text":"run_dialog () Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. Source code in src/cplus_plugin/gui/progress_dialog.py 108 109 110 111 112 113 114 def run_dialog ( self ): \"\"\"Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. \"\"\" self . setModal ( False ) self . show ()","title":"run_dialog()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.set_report_complete","text":"set_report_complete () Enable layout designer and PDF report buttons. Source code in src/cplus_plugin/gui/progress_dialog.py 156 157 158 159 160 161 162 163 def set_report_complete ( self ): \"\"\"Enable layout designer and PDF report buttons.\"\"\" self . btn_view_report . setEnabled ( True ) self . designer_action . setEnabled ( True ) self . pdf_action . setEnabled ( True ) self . report_running = False self . processing_finished ()","title":"set_report_complete()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.stop_processing","text":"stop_processing () The user cancelled the processing. Source code in src/cplus_plugin/gui/progress_dialog.py 248 249 250 251 252 253 254 255 256 257 def stop_processing ( self ) -> None : \"\"\"The user cancelled the processing.\"\"\" self . change_status_message ( tr ( \"Processing has been cancelled by the user\" )) # Stops the processing task if self . main_widget : self . main_widget . cancel_processing_task () self . processing_cancelled ()","title":"stop_processing()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.update_progress_bar","text":"update_progress_bar ( value ) Sets the value of the progress bar Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/progress_dialog.py 134 135 136 137 138 139 140 141 142 143 144 def update_progress_bar ( self , value ) -> None : \"\"\"Sets the value of the progress bar :param value: Value to be set on the progress bar :type value: float \"\"\" if self . progress_bar : try : self . progress_bar . setValue ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False )","title":"update_progress_bar()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.view_report_layout_designer","text":"view_report_layout_designer () Opens the report in layout designer Source code in src/cplus_plugin/gui/progress_dialog.py 179 180 181 182 183 184 185 186 187 188 189 190 191 def view_report_layout_designer ( self ) -> None : \"\"\"Opens the report in layout designer\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = self . report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = self . report_manager . open_layout_designer ( result ) if not status : log ( \"Unable to open layout designer.\" )","title":"view_report_layout_designer()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.view_report_pdf","text":"view_report_pdf () Opens a PDF version of the report Source code in src/cplus_plugin/gui/progress_dialog.py 165 166 167 168 169 170 171 172 173 174 175 176 177 def view_report_pdf ( self ) -> None : \"\"\"Opens a PDF version of the report\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = self . report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = self . report_manager . view_pdf ( result ) if not status : log ( \"Unable to open PDF report.\" )","title":"view_report_pdf()"},{"location":"developer/api/models/api_base/","text":"Model base QGIS CPLUS plugin models. BaseModelComponent dataclass Base class for common model item properties. __eq__ __eq__ ( other ) Test equality of object with another BaseModelComponent object using the attributes. Parameters: Name Type Description Default other BaseModelComponent BaseModelComponent object to compare with this object. required Returns: Type Description bool True if the all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __eq__ ( self , other : \"BaseModelComponent\" ) -> bool : \"\"\"Test equality of object with another BaseModelComponent object using the attributes. :param other: BaseModelComponent object to compare with this object. :type other: BaseModelComponent :returns: True if the all the attribute values match, else False. :rtype: bool \"\"\" if self . uuid != other . uuid : return False if self . name != other . name : return False if self . description != other . description : return False return True ImplementationModel dataclass Bases: LayerModelComponent Contains information about the implementation model for a scenario. If the layer has been set then it will not be possible to add NCS pathways unless the layer is cleared. Priority will be given to the layer property. __post_init__ __post_init__ () Pre-checks on initialization. Source code in src/cplus_plugin/models/base.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def __post_init__ ( self ): \"\"\"Pre-checks on initialization.\"\"\" super () . __post_init__ () # Ensure there are no duplicate pathways. uuids = [ str ( p . uuid ) for p in self . pathways ] if len ( set ( uuids )) != len ( uuids ): msg = \"Duplicate pathways found in implementation model\" raise ValueError ( f \" { msg } { self . name } .\" ) # Reset pathways if layer has also been set. if self . to_map_layer () is not None and len ( self . pathways ) > 0 : self . pathways = [] add_ncs_pathway add_ncs_pathway ( ncs ) Adds an NCS pathway object to the collection. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to be added to the model. required Returns: Type Description bool True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. Source code in src/cplus_plugin/models/base.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the collection. :param ncs: NCS pathway to be added to the model. :type ncs: NcsPathway :returns: True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. \"\"\" if not ncs . is_valid (): return False if self . contains_pathway ( str ( ncs . uuid )): return False self . pathways . append ( ncs ) return True clear_layer clear_layer () Removes a reference to the layer URI defined in the path attribute. Source code in src/cplus_plugin/models/base.py 380 381 382 def clear_layer ( self ): \"\"\"Removes a reference to the layer URI defined in the path attribute.\"\"\" self . path = \"\" contains_pathway contains_pathway ( pathway_uuid ) Checks if there is an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID to search for in the collection. required Returns: Type Description bool True if there is a matching NCS pathway, else False. Source code in src/cplus_plugin/models/base.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 def contains_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Checks if there is an NCS pathway matching the given UUID. :param pathway_uuid: UUID to search for in the collection. :type pathway_uuid: str :returns: True if there is a matching NCS pathway, else False. :rtype: bool \"\"\" ncs_pathway = self . pathway_by_uuid ( pathway_uuid ) if ncs_pathway is None : return False return True is_pwls_valid is_pwls_valid () Checks if the priority layers are valid. Returns: Type Description bool True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. Source code in src/cplus_plugin/models/base.py 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def is_pwls_valid ( self ) -> bool : \"\"\"Checks if the priority layers are valid. :returns: True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. :rtype: bool \"\"\" is_valid = True for cl in self . pw_layers (): if not cl . isValid (): is_valid = False break return is_valid is_valid is_valid () Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. Source code in src/cplus_plugin/models/base.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 def is_valid ( self ) -> bool : \"\"\"Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. \"\"\" if self . to_map_layer () is not None : return super () . is_valid () else : if len ( self . pathways ) == 0 : return False if not self . is_pwls_valid (): return False return True model_color_ramp model_color_ramp () Create a color ramp for styling the implementation layer resulting from a scenario run. Returns: Type Description QgsColorRamp A color ramp for styling the implementation layer or None if there was no definition found. Source code in src/cplus_plugin/models/base.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def model_color_ramp ( self ) -> typing . Union [ QgsColorRamp , None ]: \"\"\"Create a color ramp for styling the implementation layer resulting from a scenario run. :returns: A color ramp for styling the implementation layer or None if there was no definition found. :rtype: QgsColorRamp \"\"\" model_layer_info = self . model_layer_style_info () if len ( model_layer_info ) == 0 : return None ramp_info = model_layer_info . get ( COLOR_RAMP_PROPERTIES_ATTRIBUTE , None ) if ramp_info is None or len ( ramp_info ) == 0 : return None ramp_type = model_layer_info . get ( COLOR_RAMP_TYPE_ATTRIBUTE , None ) if ramp_type is None : return None # New ramp types will need to be added here manually if ramp_type == QgsColorBrewerColorRamp . typeString (): return QgsColorBrewerColorRamp . create ( ramp_info ) elif ramp_type == QgsCptCityColorRamp . typeString (): return QgsCptCityColorRamp . create ( ramp_info ) elif ramp_type == QgsGradientColorRamp . typeString (): return QgsGradientColorRamp . create ( ramp_info ) elif ramp_type == QgsLimitedRandomColorRamp . typeString (): return QgsLimitedRandomColorRamp . create ( ramp_info ) elif ramp_type == QgsPresetSchemeColorRamp . typeString (): return QgsPresetSchemeColorRamp . create ( ramp_info ) elif ramp_type == QgsRandomColorRamp . typeString (): return QgsRandomColorRamp () return None model_layer_style_info model_layer_style_info () Returns the color ramp properties for styling the implementation layer resulting from a scenario run. Returns: Type Description dict Color ramp properties for the implementation model styling or an empty dictionary if there was no definition found in the root style. Source code in src/cplus_plugin/models/base.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def model_layer_style_info ( self ) -> dict : \"\"\"Returns the color ramp properties for styling the implementation layer resulting from a scenario run. :returns: Color ramp properties for the implementation model styling or an empty dictionary if there was no definition found in the root style. :rtype: dict \"\"\" if ( len ( self . layer_styles ) == 0 or IM_LAYER_STYLE_ATTRIBUTE not in self . layer_styles ): return dict () return self . layer_styles [ IM_LAYER_STYLE_ATTRIBUTE ] pathway_by_uuid pathway_by_uuid ( pathway_uuid ) Returns an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to retrieve. required Returns: Type Description NcsPathway NCS pathway object matching the given UUID else None if not found. Source code in src/cplus_plugin/models/base.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def pathway_by_uuid ( self , pathway_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Returns an NCS pathway matching the given UUID. :param pathway_uuid: UUID for the NCS pathway to retrieve. :type pathway_uuid: str :returns: NCS pathway object matching the given UUID else None if not found. :rtype: NcsPathway \"\"\" pathways = [ p for p in self . pathways if str ( p . uuid ) == pathway_uuid ] if len ( pathways ) == 0 : return None return pathways [ 0 ] pw_layers pw_layers () Returns the list of priority weighting layers wdefined under the :py:attr: ~priority_layers attribute. Returns: Type Description list Priority layers for the implementation or an empty list if the path is not defined. Source code in src/cplus_plugin/models/base.py 421 422 423 424 425 426 427 428 429 def pw_layers ( self ) -> typing . List [ QgsRasterLayer ]: \"\"\"Returns the list of priority weighting layers wdefined under the :py:attr:`~priority_layers` attribute. :returns: Priority layers for the implementation or an empty list if the path is not defined. :rtype: list \"\"\" return [ QgsRasterLayer ( layer . get ( \"path\" )) for layer in self . priority_layers ] remove_ncs_pathway remove_ncs_pathway ( pathway_uuid ) Removes the NCS pathway with a matching UUID from the collection. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to be removed. required Returns: Type Description bool True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. Source code in src/cplus_plugin/models/base.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 def remove_ncs_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Removes the NCS pathway with a matching UUID from the collection. :param pathway_uuid: UUID for the NCS pathway to be removed. :type pathway_uuid: str :returns: True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. :rtype: bool \"\"\" idxs = [ i for i , p in enumerate ( self . pathways ) if str ( p . uuid ) == pathway_uuid ] if len ( idxs ) == 0 : return False rem_idx = idxs [ 0 ] _ = self . pathways . pop ( rem_idx ) return True scenario_fill_symbol scenario_fill_symbol () Creates a fill symbol for the implementation model in the scenario. Returns: Type Description QgsFillSymbol Fill symbol for the implementation model in the scenario or None if there was no definition found. Source code in src/cplus_plugin/models/base.py 499 500 501 502 503 504 505 506 507 508 509 510 def scenario_fill_symbol ( self ) -> typing . Union [ QgsFillSymbol , None ]: \"\"\"Creates a fill symbol for the implementation model in the scenario. :returns: Fill symbol for the implementation model in the scenario or None if there was no definition found. :rtype: QgsFillSymbol \"\"\" scenario_style_info = self . scenario_layer_style_info () if len ( scenario_style_info ) == 0 : return None return QgsFillSymbol . createSimple ( scenario_style_info ) scenario_layer_style_info scenario_layer_style_info () Returns the fill symbol properties for styling the implementation layer in the final scenario result. Returns: Type Description dict Fill symbol properties for the implementation model styling in the scenario layer or an empty dictionary if there was no definition found in the root style. Source code in src/cplus_plugin/models/base.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 def scenario_layer_style_info ( self ) -> dict : \"\"\"Returns the fill symbol properties for styling the implementation layer in the final scenario result. :returns: Fill symbol properties for the implementation model styling in the scenario layer or an empty dictionary if there was no definition found in the root style. :rtype: dict \"\"\" if ( len ( self . layer_styles ) == 0 or IM_SCENARIO_STYLE_ATTRIBUTE not in self . layer_styles ): return dict () return self . layer_styles [ IM_SCENARIO_STYLE_ATTRIBUTE ] LayerModelComponent dataclass Bases: BaseModelComponent Base class for model components that support a map layer. __eq__ __eq__ ( other ) Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. Source code in src/cplus_plugin/models/base.py 198 199 200 201 202 def __eq__ ( self , other ) -> bool : \"\"\"Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. \"\"\" return super () . __eq__ ( other ) __post_init__ __post_init__ () Try to set the layer and layer type properties. Source code in src/cplus_plugin/models/base.py 141 142 143 def __post_init__ ( self ): \"\"\"Try to set the layer and layer type properties.\"\"\" self . update_layer_type () is_valid is_valid () Checks if the corresponding map layer is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/models/base.py 185 186 187 188 189 190 191 192 193 194 195 196 def is_valid ( self ) -> bool : \"\"\"Checks if the corresponding map layer is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" layer = self . to_map_layer () if layer is None : return False return layer . isValid () to_map_layer to_map_layer () Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. Returns: Type Description QgsMapLayer Map layer corresponding to the set layer property or specified path. Source code in src/cplus_plugin/models/base.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def to_map_layer ( self ) -> typing . Union [ QgsMapLayer , None ]: \"\"\"Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. :returns: Map layer corresponding to the set layer property or specified path. :rtype: QgsMapLayer \"\"\" if not os . path . exists ( self . path ): return None layer = None if self . layer_type == LayerType . RASTER : layer = QgsRasterLayer ( self . path , self . name ) elif self . layer_type == LayerType . VECTOR : layer = QgsVectorLayer ( self . path , self . name ) return layer update_layer_type update_layer_type () Update the layer type if either the layer or path properties have been set. Source code in src/cplus_plugin/models/base.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def update_layer_type ( self ): \"\"\"Update the layer type if either the layer or path properties have been set. \"\"\" layer = self . to_map_layer () if layer is None : return if not layer . isValid (): return if isinstance ( layer , QgsRasterLayer ): self . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . layer_type = LayerType . VECTOR LayerType Bases: IntEnum QGIS spatial layer type. ModelComponentType Bases: Enum Type of model component i.e. NCS pathway or implementation model. from_string staticmethod from_string ( str_enum ) Creates an enum from the corresponding string equivalent. Parameters: Name Type Description Default str_enum str String representing the model component type. required Returns: Type Description ModelComponentType Component type enum corresponding to the given string else unknown if not found. Source code in src/cplus_plugin/models/base.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @staticmethod def from_string ( str_enum : str ) -> \"ModelComponentType\" : \"\"\"Creates an enum from the corresponding string equivalent. :param str_enum: String representing the model component type. :type str_enum: str :returns: Component type enum corresponding to the given string else unknown if not found. :rtype: ModelComponentType \"\"\" if str_enum . lower () == \"ncs_pathway\" : return ModelComponentType . NCS_PATHWAY elif str_enum . lower () == \"implementation_model\" : return ModelComponentType . IMPLEMENTATION_MODEL return ModelComponentType . UNKNOWN NcsPathway dataclass Bases: LayerModelComponent Contains information about an NCS pathway layer. __eq__ __eq__ ( other ) Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. Parameters: Name Type Description Default other NcsPathway NcsPathway object to compare with this object. required Returns: Type Description bool True if all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def __eq__ ( self , other : \"NcsPathway\" ) -> bool : \"\"\"Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. :param other: NcsPathway object to compare with this object. :type other: NcsPathway :returns: True if all the attribute values match, else False. :rtype: bool \"\"\" base_equality = super () . __eq__ ( other ) if not base_equality : return False if self . path != other . path : return False if self . layer_type != other . layer_type : return False if self . user_defined != other . user_defined : return False return True add_carbon_path add_carbon_path ( carbon_path ) Add a carbon layer path. Checks if the path has already been defined or if it exists in the file system. Returns: Type Description bool True if the carbon layer path was successfully added, else False if the path has already been defined or does not exist in the file system. Source code in src/cplus_plugin/models/base.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def add_carbon_path ( self , carbon_path : str ) -> bool : \"\"\"Add a carbon layer path. Checks if the path has already been defined or if it exists in the file system. :returns: True if the carbon layer path was successfully added, else False if the path has already been defined or does not exist in the file system. :rtype: bool \"\"\" if carbon_path in self . carbon_paths : return False if not os . path . exists ( carbon_path ): return False self . carbon_paths . append ( carbon_path ) return True carbon_layers carbon_layers () Returns the list of carbon layers whose path is defined under the :py:attr: ~carbon_paths attribute. The caller should check the validity of the layers or use :py:meth: ~is_carbon_valid function. Returns: Type Description list Carbon layers for the NCS pathway or an empty list if the path is not defined. Source code in src/cplus_plugin/models/base.py 273 274 275 276 277 278 279 280 281 282 283 284 def carbon_layers ( self ) -> typing . List [ QgsRasterLayer ]: \"\"\"Returns the list of carbon layers whose path is defined under the :py:attr:`~carbon_paths` attribute. The caller should check the validity of the layers or use :py:meth:`~is_carbon_valid` function. :returns: Carbon layers for the NCS pathway or an empty list if the path is not defined. :rtype: list \"\"\" return [ QgsRasterLayer ( carbon_path ) for carbon_path in self . carbon_paths ] is_carbon_valid is_carbon_valid () Checks if the carbon layers are valid. Returns: Type Description bool True if all carbon layers are valid, else False if even one is invalid. If there are no carbon layers defined, it will always return True. Source code in src/cplus_plugin/models/base.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def is_carbon_valid ( self ) -> bool : \"\"\"Checks if the carbon layers are valid. :returns: True if all carbon layers are valid, else False if even one is invalid. If there are no carbon layers defined, it will always return True. :rtype: bool \"\"\" is_valid = True for cl in self . carbon_layers (): if not cl . isValid (): is_valid = False break return is_valid is_valid is_valid () Additional check to include validity of carbon layers. Source code in src/cplus_plugin/models/base.py 302 303 304 305 306 307 308 309 310 311 312 def is_valid ( self ) -> bool : \"\"\"Additional check to include validity of carbon layers.\"\"\" valid = super () . is_valid () if not valid : return False carbon_valid = self . is_carbon_valid () if not carbon_valid : return False return True PRIORITY_GROUP Bases: Enum Represents priority groups types PriorityLayer dataclass Bases: BaseModelComponent Base class for model components storing priority weighting layers. Scenario dataclass Bases: BaseModelComponent Object for the handling workflow scenario information. ScenarioResult dataclass Scenario result details. ScenarioState Bases: Enum Defines scenario analysis process states SpatialExtent dataclass Extent object that stores the coordinates of the area of interest","title":"Model base"},{"location":"developer/api/models/api_base/#model-base","text":"QGIS CPLUS plugin models.","title":"Model base"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.BaseModelComponent","text":"Base class for common model item properties.","title":"BaseModelComponent"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.BaseModelComponent.__eq__","text":"__eq__ ( other ) Test equality of object with another BaseModelComponent object using the attributes. Parameters: Name Type Description Default other BaseModelComponent BaseModelComponent object to compare with this object. required Returns: Type Description bool True if the all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __eq__ ( self , other : \"BaseModelComponent\" ) -> bool : \"\"\"Test equality of object with another BaseModelComponent object using the attributes. :param other: BaseModelComponent object to compare with this object. :type other: BaseModelComponent :returns: True if the all the attribute values match, else False. :rtype: bool \"\"\" if self . uuid != other . uuid : return False if self . name != other . name : return False if self . description != other . description : return False return True","title":"__eq__()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel","text":"Bases: LayerModelComponent Contains information about the implementation model for a scenario. If the layer has been set then it will not be possible to add NCS pathways unless the layer is cleared. Priority will be given to the layer property.","title":"ImplementationModel"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.__post_init__","text":"__post_init__ () Pre-checks on initialization. Source code in src/cplus_plugin/models/base.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def __post_init__ ( self ): \"\"\"Pre-checks on initialization.\"\"\" super () . __post_init__ () # Ensure there are no duplicate pathways. uuids = [ str ( p . uuid ) for p in self . pathways ] if len ( set ( uuids )) != len ( uuids ): msg = \"Duplicate pathways found in implementation model\" raise ValueError ( f \" { msg } { self . name } .\" ) # Reset pathways if layer has also been set. if self . to_map_layer () is not None and len ( self . pathways ) > 0 : self . pathways = []","title":"__post_init__()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.add_ncs_pathway","text":"add_ncs_pathway ( ncs ) Adds an NCS pathway object to the collection. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to be added to the model. required Returns: Type Description bool True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. Source code in src/cplus_plugin/models/base.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the collection. :param ncs: NCS pathway to be added to the model. :type ncs: NcsPathway :returns: True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. \"\"\" if not ncs . is_valid (): return False if self . contains_pathway ( str ( ncs . uuid )): return False self . pathways . append ( ncs ) return True","title":"add_ncs_pathway()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.clear_layer","text":"clear_layer () Removes a reference to the layer URI defined in the path attribute. Source code in src/cplus_plugin/models/base.py 380 381 382 def clear_layer ( self ): \"\"\"Removes a reference to the layer URI defined in the path attribute.\"\"\" self . path = \"\"","title":"clear_layer()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.contains_pathway","text":"contains_pathway ( pathway_uuid ) Checks if there is an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID to search for in the collection. required Returns: Type Description bool True if there is a matching NCS pathway, else False. Source code in src/cplus_plugin/models/base.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 def contains_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Checks if there is an NCS pathway matching the given UUID. :param pathway_uuid: UUID to search for in the collection. :type pathway_uuid: str :returns: True if there is a matching NCS pathway, else False. :rtype: bool \"\"\" ncs_pathway = self . pathway_by_uuid ( pathway_uuid ) if ncs_pathway is None : return False return True","title":"contains_pathway()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.is_pwls_valid","text":"is_pwls_valid () Checks if the priority layers are valid. Returns: Type Description bool True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. Source code in src/cplus_plugin/models/base.py 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def is_pwls_valid ( self ) -> bool : \"\"\"Checks if the priority layers are valid. :returns: True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. :rtype: bool \"\"\" is_valid = True for cl in self . pw_layers (): if not cl . isValid (): is_valid = False break return is_valid","title":"is_pwls_valid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.is_valid","text":"is_valid () Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. Source code in src/cplus_plugin/models/base.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 def is_valid ( self ) -> bool : \"\"\"Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. \"\"\" if self . to_map_layer () is not None : return super () . is_valid () else : if len ( self . pathways ) == 0 : return False if not self . is_pwls_valid (): return False return True","title":"is_valid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.model_color_ramp","text":"model_color_ramp () Create a color ramp for styling the implementation layer resulting from a scenario run. Returns: Type Description QgsColorRamp A color ramp for styling the implementation layer or None if there was no definition found. Source code in src/cplus_plugin/models/base.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def model_color_ramp ( self ) -> typing . Union [ QgsColorRamp , None ]: \"\"\"Create a color ramp for styling the implementation layer resulting from a scenario run. :returns: A color ramp for styling the implementation layer or None if there was no definition found. :rtype: QgsColorRamp \"\"\" model_layer_info = self . model_layer_style_info () if len ( model_layer_info ) == 0 : return None ramp_info = model_layer_info . get ( COLOR_RAMP_PROPERTIES_ATTRIBUTE , None ) if ramp_info is None or len ( ramp_info ) == 0 : return None ramp_type = model_layer_info . get ( COLOR_RAMP_TYPE_ATTRIBUTE , None ) if ramp_type is None : return None # New ramp types will need to be added here manually if ramp_type == QgsColorBrewerColorRamp . typeString (): return QgsColorBrewerColorRamp . create ( ramp_info ) elif ramp_type == QgsCptCityColorRamp . typeString (): return QgsCptCityColorRamp . create ( ramp_info ) elif ramp_type == QgsGradientColorRamp . typeString (): return QgsGradientColorRamp . create ( ramp_info ) elif ramp_type == QgsLimitedRandomColorRamp . typeString (): return QgsLimitedRandomColorRamp . create ( ramp_info ) elif ramp_type == QgsPresetSchemeColorRamp . typeString (): return QgsPresetSchemeColorRamp . create ( ramp_info ) elif ramp_type == QgsRandomColorRamp . typeString (): return QgsRandomColorRamp () return None","title":"model_color_ramp()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.model_layer_style_info","text":"model_layer_style_info () Returns the color ramp properties for styling the implementation layer resulting from a scenario run. Returns: Type Description dict Color ramp properties for the implementation model styling or an empty dictionary if there was no definition found in the root style. Source code in src/cplus_plugin/models/base.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def model_layer_style_info ( self ) -> dict : \"\"\"Returns the color ramp properties for styling the implementation layer resulting from a scenario run. :returns: Color ramp properties for the implementation model styling or an empty dictionary if there was no definition found in the root style. :rtype: dict \"\"\" if ( len ( self . layer_styles ) == 0 or IM_LAYER_STYLE_ATTRIBUTE not in self . layer_styles ): return dict () return self . layer_styles [ IM_LAYER_STYLE_ATTRIBUTE ]","title":"model_layer_style_info()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.pathway_by_uuid","text":"pathway_by_uuid ( pathway_uuid ) Returns an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to retrieve. required Returns: Type Description NcsPathway NCS pathway object matching the given UUID else None if not found. Source code in src/cplus_plugin/models/base.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def pathway_by_uuid ( self , pathway_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Returns an NCS pathway matching the given UUID. :param pathway_uuid: UUID for the NCS pathway to retrieve. :type pathway_uuid: str :returns: NCS pathway object matching the given UUID else None if not found. :rtype: NcsPathway \"\"\" pathways = [ p for p in self . pathways if str ( p . uuid ) == pathway_uuid ] if len ( pathways ) == 0 : return None return pathways [ 0 ]","title":"pathway_by_uuid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.pw_layers","text":"pw_layers () Returns the list of priority weighting layers wdefined under the :py:attr: ~priority_layers attribute. Returns: Type Description list Priority layers for the implementation or an empty list if the path is not defined. Source code in src/cplus_plugin/models/base.py 421 422 423 424 425 426 427 428 429 def pw_layers ( self ) -> typing . List [ QgsRasterLayer ]: \"\"\"Returns the list of priority weighting layers wdefined under the :py:attr:`~priority_layers` attribute. :returns: Priority layers for the implementation or an empty list if the path is not defined. :rtype: list \"\"\" return [ QgsRasterLayer ( layer . get ( \"path\" )) for layer in self . priority_layers ]","title":"pw_layers()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.remove_ncs_pathway","text":"remove_ncs_pathway ( pathway_uuid ) Removes the NCS pathway with a matching UUID from the collection. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to be removed. required Returns: Type Description bool True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. Source code in src/cplus_plugin/models/base.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 def remove_ncs_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Removes the NCS pathway with a matching UUID from the collection. :param pathway_uuid: UUID for the NCS pathway to be removed. :type pathway_uuid: str :returns: True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. :rtype: bool \"\"\" idxs = [ i for i , p in enumerate ( self . pathways ) if str ( p . uuid ) == pathway_uuid ] if len ( idxs ) == 0 : return False rem_idx = idxs [ 0 ] _ = self . pathways . pop ( rem_idx ) return True","title":"remove_ncs_pathway()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.scenario_fill_symbol","text":"scenario_fill_symbol () Creates a fill symbol for the implementation model in the scenario. Returns: Type Description QgsFillSymbol Fill symbol for the implementation model in the scenario or None if there was no definition found. Source code in src/cplus_plugin/models/base.py 499 500 501 502 503 504 505 506 507 508 509 510 def scenario_fill_symbol ( self ) -> typing . Union [ QgsFillSymbol , None ]: \"\"\"Creates a fill symbol for the implementation model in the scenario. :returns: Fill symbol for the implementation model in the scenario or None if there was no definition found. :rtype: QgsFillSymbol \"\"\" scenario_style_info = self . scenario_layer_style_info () if len ( scenario_style_info ) == 0 : return None return QgsFillSymbol . createSimple ( scenario_style_info )","title":"scenario_fill_symbol()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.scenario_layer_style_info","text":"scenario_layer_style_info () Returns the fill symbol properties for styling the implementation layer in the final scenario result. Returns: Type Description dict Fill symbol properties for the implementation model styling in the scenario layer or an empty dictionary if there was no definition found in the root style. Source code in src/cplus_plugin/models/base.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 def scenario_layer_style_info ( self ) -> dict : \"\"\"Returns the fill symbol properties for styling the implementation layer in the final scenario result. :returns: Fill symbol properties for the implementation model styling in the scenario layer or an empty dictionary if there was no definition found in the root style. :rtype: dict \"\"\" if ( len ( self . layer_styles ) == 0 or IM_SCENARIO_STYLE_ATTRIBUTE not in self . layer_styles ): return dict () return self . layer_styles [ IM_SCENARIO_STYLE_ATTRIBUTE ]","title":"scenario_layer_style_info()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent","text":"Bases: BaseModelComponent Base class for model components that support a map layer.","title":"LayerModelComponent"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.__eq__","text":"__eq__ ( other ) Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. Source code in src/cplus_plugin/models/base.py 198 199 200 201 202 def __eq__ ( self , other ) -> bool : \"\"\"Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. \"\"\" return super () . __eq__ ( other )","title":"__eq__()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.__post_init__","text":"__post_init__ () Try to set the layer and layer type properties. Source code in src/cplus_plugin/models/base.py 141 142 143 def __post_init__ ( self ): \"\"\"Try to set the layer and layer type properties.\"\"\" self . update_layer_type ()","title":"__post_init__()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.is_valid","text":"is_valid () Checks if the corresponding map layer is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/models/base.py 185 186 187 188 189 190 191 192 193 194 195 196 def is_valid ( self ) -> bool : \"\"\"Checks if the corresponding map layer is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" layer = self . to_map_layer () if layer is None : return False return layer . isValid ()","title":"is_valid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.to_map_layer","text":"to_map_layer () Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. Returns: Type Description QgsMapLayer Map layer corresponding to the set layer property or specified path. Source code in src/cplus_plugin/models/base.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def to_map_layer ( self ) -> typing . Union [ QgsMapLayer , None ]: \"\"\"Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. :returns: Map layer corresponding to the set layer property or specified path. :rtype: QgsMapLayer \"\"\" if not os . path . exists ( self . path ): return None layer = None if self . layer_type == LayerType . RASTER : layer = QgsRasterLayer ( self . path , self . name ) elif self . layer_type == LayerType . VECTOR : layer = QgsVectorLayer ( self . path , self . name ) return layer","title":"to_map_layer()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.update_layer_type","text":"update_layer_type () Update the layer type if either the layer or path properties have been set. Source code in src/cplus_plugin/models/base.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def update_layer_type ( self ): \"\"\"Update the layer type if either the layer or path properties have been set. \"\"\" layer = self . to_map_layer () if layer is None : return if not layer . isValid (): return if isinstance ( layer , QgsRasterLayer ): self . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . layer_type = LayerType . VECTOR","title":"update_layer_type()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerType","text":"Bases: IntEnum QGIS spatial layer type.","title":"LayerType"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ModelComponentType","text":"Bases: Enum Type of model component i.e. NCS pathway or implementation model.","title":"ModelComponentType"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ModelComponentType.from_string","text":"from_string ( str_enum ) Creates an enum from the corresponding string equivalent. Parameters: Name Type Description Default str_enum str String representing the model component type. required Returns: Type Description ModelComponentType Component type enum corresponding to the given string else unknown if not found. Source code in src/cplus_plugin/models/base.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @staticmethod def from_string ( str_enum : str ) -> \"ModelComponentType\" : \"\"\"Creates an enum from the corresponding string equivalent. :param str_enum: String representing the model component type. :type str_enum: str :returns: Component type enum corresponding to the given string else unknown if not found. :rtype: ModelComponentType \"\"\" if str_enum . lower () == \"ncs_pathway\" : return ModelComponentType . NCS_PATHWAY elif str_enum . lower () == \"implementation_model\" : return ModelComponentType . IMPLEMENTATION_MODEL return ModelComponentType . UNKNOWN","title":"from_string()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway","text":"Bases: LayerModelComponent Contains information about an NCS pathway layer.","title":"NcsPathway"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.__eq__","text":"__eq__ ( other ) Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. Parameters: Name Type Description Default other NcsPathway NcsPathway object to compare with this object. required Returns: Type Description bool True if all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def __eq__ ( self , other : \"NcsPathway\" ) -> bool : \"\"\"Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. :param other: NcsPathway object to compare with this object. :type other: NcsPathway :returns: True if all the attribute values match, else False. :rtype: bool \"\"\" base_equality = super () . __eq__ ( other ) if not base_equality : return False if self . path != other . path : return False if self . layer_type != other . layer_type : return False if self . user_defined != other . user_defined : return False return True","title":"__eq__()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.add_carbon_path","text":"add_carbon_path ( carbon_path ) Add a carbon layer path. Checks if the path has already been defined or if it exists in the file system. Returns: Type Description bool True if the carbon layer path was successfully added, else False if the path has already been defined or does not exist in the file system. Source code in src/cplus_plugin/models/base.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def add_carbon_path ( self , carbon_path : str ) -> bool : \"\"\"Add a carbon layer path. Checks if the path has already been defined or if it exists in the file system. :returns: True if the carbon layer path was successfully added, else False if the path has already been defined or does not exist in the file system. :rtype: bool \"\"\" if carbon_path in self . carbon_paths : return False if not os . path . exists ( carbon_path ): return False self . carbon_paths . append ( carbon_path ) return True","title":"add_carbon_path()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.carbon_layers","text":"carbon_layers () Returns the list of carbon layers whose path is defined under the :py:attr: ~carbon_paths attribute. The caller should check the validity of the layers or use :py:meth: ~is_carbon_valid function. Returns: Type Description list Carbon layers for the NCS pathway or an empty list if the path is not defined. Source code in src/cplus_plugin/models/base.py 273 274 275 276 277 278 279 280 281 282 283 284 def carbon_layers ( self ) -> typing . List [ QgsRasterLayer ]: \"\"\"Returns the list of carbon layers whose path is defined under the :py:attr:`~carbon_paths` attribute. The caller should check the validity of the layers or use :py:meth:`~is_carbon_valid` function. :returns: Carbon layers for the NCS pathway or an empty list if the path is not defined. :rtype: list \"\"\" return [ QgsRasterLayer ( carbon_path ) for carbon_path in self . carbon_paths ]","title":"carbon_layers()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.is_carbon_valid","text":"is_carbon_valid () Checks if the carbon layers are valid. Returns: Type Description bool True if all carbon layers are valid, else False if even one is invalid. If there are no carbon layers defined, it will always return True. Source code in src/cplus_plugin/models/base.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def is_carbon_valid ( self ) -> bool : \"\"\"Checks if the carbon layers are valid. :returns: True if all carbon layers are valid, else False if even one is invalid. If there are no carbon layers defined, it will always return True. :rtype: bool \"\"\" is_valid = True for cl in self . carbon_layers (): if not cl . isValid (): is_valid = False break return is_valid","title":"is_carbon_valid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.is_valid","text":"is_valid () Additional check to include validity of carbon layers. Source code in src/cplus_plugin/models/base.py 302 303 304 305 306 307 308 309 310 311 312 def is_valid ( self ) -> bool : \"\"\"Additional check to include validity of carbon layers.\"\"\" valid = super () . is_valid () if not valid : return False carbon_valid = self . is_carbon_valid () if not carbon_valid : return False return True","title":"is_valid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.PRIORITY_GROUP","text":"Bases: Enum Represents priority groups types","title":"PRIORITY_GROUP"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.PriorityLayer","text":"Bases: BaseModelComponent Base class for model components storing priority weighting layers.","title":"PriorityLayer"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Scenario","text":"Bases: BaseModelComponent Object for the handling workflow scenario information.","title":"Scenario"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ScenarioResult","text":"Scenario result details.","title":"ScenarioResult"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ScenarioState","text":"Bases: Enum Defines scenario analysis process states","title":"ScenarioState"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.SpatialExtent","text":"Extent object that stores the coordinates of the area of interest","title":"SpatialExtent"},{"location":"developer/api/models/api_helpers/","text":"Helpers Helper functions for supporting model management. clone_implementation_model clone_implementation_model ( implementation_model ) Creates a deep copy of the given implementation model. Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model to clone. required Returns: Type Description ImplementationModel A deep copy of the original implementation model object. Source code in src/cplus_plugin/models/helpers.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def clone_implementation_model ( implementation_model : ImplementationModel , ) -> ImplementationModel : \"\"\"Creates a deep copy of the given implementation model. :param implementation_model: Implementation model to clone. :type implementation_model: ImplementationModel :returns: A deep copy of the original implementation model object. :rtype: ImplementationModel \"\"\" imp_model = clone_layer_component ( implementation_model , ImplementationModel ) if imp_model is None : return None pathways = implementation_model . pathways cloned_pathways = [] for p in pathways : cloned_ncs = clone_ncs_pathway ( p ) if cloned_ncs is not None : cloned_pathways . append ( cloned_ncs ) imp_model . pathways = cloned_pathways return imp_model clone_layer_component clone_layer_component ( layer_component , model_cls ) Clones a layer-based model component. Parameters: Name Type Description Default layer_component LayerModelComponent Layer-based model component to clone. required model_cls Callable [[ UUID , str , str ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent A new instance of the cloned model component. It will return None if the input is not a layer-based model component. Source code in src/cplus_plugin/models/helpers.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def clone_layer_component ( layer_component : LayerModelComponent , model_cls : typing . Callable [[ uuid . UUID , str , str ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Clones a layer-based model component. :param layer_component: Layer-based model component to clone. :type layer_component: LayerModelComponent :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: A new instance of the cloned model component. It will return None if the input is not a layer-based model component. :rtype: LayerModelComponent \"\"\" if not isinstance ( layer_component , LayerModelComponent ): return None cloned_component = model_cls ( layer_component . uuid , layer_component . name , layer_component . description ) for f in fields ( layer_component ): attr_val = getattr ( layer_component , f . name ) setattr ( cloned_component , f . name , attr_val ) return cloned_component clone_ncs_pathway clone_ncs_pathway ( ncs ) Creates a deep copy of the given NCS pathway. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to clone. required Returns: Type Description NcsPathway A deep copy of the original NCS pathway object. Source code in src/cplus_plugin/models/helpers.py 284 285 286 287 288 289 290 291 292 293 def clone_ncs_pathway ( ncs : NcsPathway ) -> NcsPathway : \"\"\"Creates a deep copy of the given NCS pathway. :param ncs: NCS pathway to clone. :type ncs: NcsPathway :returns: A deep copy of the original NCS pathway object. :rtype: NcsPathway \"\"\" return clone_layer_component ( ncs , NcsPathway ) copy_layer_component_attributes copy_layer_component_attributes ( target , source ) Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. Parameters: Name Type Description Default target LayerModelComponent Target object whose attribute values will be updated. required source LayerModelComponent Source object whose attribute values will be copied to the target. required Returns: Type Description LayerModelComponent Target object containing the updated attribute values apart for the uuid whose value will not change. Source code in src/cplus_plugin/models/helpers.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def copy_layer_component_attributes ( target : LayerModelComponent , source : LayerModelComponent ) -> LayerModelComponent : \"\"\"Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. :param target: Target object whose attribute values will be updated. :type target: LayerModelComponent :param source: Source object whose attribute values will be copied to the target. :type source: LayerModelComponent :returns: Target object containing the updated attribute values apart for the uuid whose value will not change. :rtype: LayerModelComponent \"\"\" if not isinstance ( target , LayerModelComponent ) or not isinstance ( source , LayerModelComponent ): raise TypeError ( \"Source or target objects are not of type 'LayerModelComponent'\" ) for f in fields ( source ): # Exclude uuid if f . name == UUID_ATTRIBUTE : continue attr_val = getattr ( source , f . name ) setattr ( target , f . name , attr_val ) # Force layer to be set/updated target . update_layer_type () return target create_implementation_model create_implementation_model ( source_dict ) Factory method for creating an implementation model using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description ImplementationModel Implementation model with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def create_implementation_model ( source_dict ) -> typing . Union [ ImplementationModel , None ]: \"\"\"Factory method for creating an implementation model using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: Implementation model with property values set from the dictionary. :rtype: ImplementationModel \"\"\" implementation_model = create_layer_component ( source_dict , ImplementationModel ) if PRIORITY_LAYERS_SEGMENT in source_dict . keys (): implementation_model . priority_layers = source_dict [ PRIORITY_LAYERS_SEGMENT ] # Set style if STYLE_ATTRIBUTE in source_dict . keys (): implementation_model . layer_styles = source_dict [ STYLE_ATTRIBUTE ] # Set styling pixel value if PIXEL_VALUE_ATTRIBUTE in source_dict . keys (): implementation_model . style_pixel_value = source_dict [ PIXEL_VALUE_ATTRIBUTE ] return implementation_model create_layer_component create_layer_component ( source_dict , model_cls ) Factory method for creating a layer model component using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required model_cls Callable [[ UUID , str , str , str , LayerType , bool ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent Layer model component object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def create_layer_component ( source_dict , model_cls : typing . Callable [ [ uuid . UUID , str , str , str , LayerType , bool ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Factory method for creating a layer model component using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: Layer model component object with property values set from the dictionary. :rtype: LayerModelComponent \"\"\" if UUID_ATTRIBUTE not in source_dict : return None source_uuid = source_dict [ UUID_ATTRIBUTE ] if isinstance ( source_uuid , str ): source_uuid = uuid . UUID ( source_uuid ) kwargs = {} if PATH_ATTRIBUTE in source_dict : kwargs [ PATH_ATTRIBUTE ] = source_dict [ PATH_ATTRIBUTE ] if LAYER_TYPE_ATTRIBUTE in source_dict : kwargs [ LAYER_TYPE_ATTRIBUTE ] = LayerType ( int ( source_dict [ LAYER_TYPE_ATTRIBUTE ])) if USER_DEFINED_ATTRIBUTE in source_dict : kwargs [ USER_DEFINED_ATTRIBUTE ] = bool ( source_dict [ USER_DEFINED_ATTRIBUTE ]) return model_cls ( source_uuid , source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], ** kwargs , ) create_model_component create_model_component ( source_dict , model_cls ) Factory method for creating and setting attribute values for a base model component object. Parameters: Name Type Description Default source_dict dict Dictionary containing attribute values. required model_cls Callable [[ UUID , str , str ], BaseModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description BaseModelComponent Base model component object with property values derived from the dictionary. Source code in src/cplus_plugin/models/helpers.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def create_model_component ( source_dict : dict , model_cls : typing . Callable [[ uuid . UUID , str , str ], BaseModelComponentType ], ) -> typing . Union [ BaseModelComponentType , None ]: \"\"\"Factory method for creating and setting attribute values for a base model component object. :param source_dict: Dictionary containing attribute values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: BaseModelComponent :returns: Base model component object with property values derived from the dictionary. :rtype: BaseModelComponent \"\"\" if not issubclass ( model_cls , BaseModelComponent ): return None return model_cls ( uuid . UUID ( source_dict [ UUID_ATTRIBUTE ]), source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], ) create_ncs_pathway create_ncs_pathway ( source_dict ) Factory method for creating an NcsPathway object using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description NcsPathway NCS pathway object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def create_ncs_pathway ( source_dict ) -> typing . Union [ NcsPathway , None ]: \"\"\"Factory method for creating an NcsPathway object using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: NCS pathway object with property values set from the dictionary. :rtype: NcsPathway \"\"\" ncs = create_layer_component ( source_dict , NcsPathway ) # We are checking because of the various iterations of the attributes # in the NcsPathway class where some of these attributes might # be missing. if CARBON_PATHS_ATTRIBUTE in source_dict : ncs . carbon_paths = source_dict [ CARBON_PATHS_ATTRIBUTE ] return ncs extent_to_project_crs_extent extent_to_project_crs_extent ( spatial_extent , project = None ) Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required project QgsProject Project whose CRS will be used to determine the values of the output extent. None Returns: Type Description QgsRectangle Output extent in the project's CRS. If the input extent is invalid, this function will return None. Source code in src/cplus_plugin/models/helpers.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 def extent_to_project_crs_extent ( spatial_extent : SpatialExtent , project : QgsProject = None ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :param project: Project whose CRS will be used to determine the values of the output extent. :type project: QgsProject :returns: Output extent in the project's CRS. If the input extent is invalid, this function will return None. :rtype: QgsRectangle \"\"\" input_rect = extent_to_qgs_rectangle ( spatial_extent ) if input_rect is None : return None default_crs = QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) if not default_crs . isValid (): return None if project is None : project = QgsProject . instance () target_crs = project . crs () if default_crs == target_crs : # No need for transformation return input_rect try : coordinate_xform = QgsCoordinateTransform ( default_crs , project . crs (), project ) return coordinate_xform . transformBoundingBox ( input_rect ) except Exception as e : log ( f \" { e } , using the default input extent.\" ) return input_rect extent_to_qgs_rectangle extent_to_qgs_rectangle ( spatial_extent ) Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required Returns: Type Description QgsRectangle QGIS rectangle defining the bounds for the scenario. Source code in src/cplus_plugin/models/helpers.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def extent_to_qgs_rectangle ( spatial_extent : SpatialExtent , ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :returns: QGIS rectangle defining the bounds for the scenario. :rtype: QgsRectangle \"\"\" if len ( spatial_extent . bbox ) < 4 : return None return QgsRectangle ( spatial_extent . bbox [ 0 ], spatial_extent . bbox [ 2 ], spatial_extent . bbox [ 1 ], spatial_extent . bbox [ 3 ], ) layer_component_to_dict layer_component_to_dict ( layer_component , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from a layer model component object. Parameters: Name Type Description Default layer_component LayerModelComponentType Source layer model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def layer_component_to_dict ( layer_component : LayerModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a layer model component object. :param layer_component: Source layer model component object whose values are to be mapped to the corresponding attribute names. :type layer_component: LayerModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_attrs = model_component_to_dict ( layer_component , uuid_to_str ) base_attrs [ PATH_ATTRIBUTE ] = layer_component . path base_attrs [ LAYER_TYPE_ATTRIBUTE ] = int ( layer_component . layer_type ) base_attrs [ USER_DEFINED_ATTRIBUTE ] = layer_component . user_defined return base_attrs model_component_to_dict model_component_to_dict ( model_component , uuid_to_str = True ) Creates a dictionary containing the base attribute name-value pairs from a model component object. Parameters: Name Type Description Default model_component BaseModelComponentType Source model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def model_component_to_dict ( model_component : BaseModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing the base attribute name-value pairs from a model component object. :param model_component: Source model component object whose values are to be mapped to the corresponding attribute names. :type model_component: BaseModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" model_uuid = model_component . uuid if uuid_to_str : model_uuid = str ( model_uuid ) return { UUID_ATTRIBUTE : model_uuid , NAME_ATTRIBUTE : model_component . name , DESCRIPTION_ATTRIBUTE : model_component . description , } ncs_pathway_to_dict ncs_pathway_to_dict ( ncs_pathway , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. Parameters: Name Type Description Default ncs_pathway NcsPathway Source NCS pathway object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def ncs_pathway_to_dict ( ncs_pathway : NcsPathway , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. :param ncs_pathway: Source NCS pathway object whose values are to be mapped to the corresponding attribute names. :type ncs_pathway: NcsPathway :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_ncs_dict = layer_component_to_dict ( ncs_pathway , uuid_to_str ) base_ncs_dict [ CARBON_PATHS_ATTRIBUTE ] = ncs_pathway . carbon_paths return base_ncs_dict","title":"Helpers"},{"location":"developer/api/models/api_helpers/#helpers","text":"Helper functions for supporting model management.","title":"Helpers"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.clone_implementation_model","text":"clone_implementation_model ( implementation_model ) Creates a deep copy of the given implementation model. Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model to clone. required Returns: Type Description ImplementationModel A deep copy of the original implementation model object. Source code in src/cplus_plugin/models/helpers.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def clone_implementation_model ( implementation_model : ImplementationModel , ) -> ImplementationModel : \"\"\"Creates a deep copy of the given implementation model. :param implementation_model: Implementation model to clone. :type implementation_model: ImplementationModel :returns: A deep copy of the original implementation model object. :rtype: ImplementationModel \"\"\" imp_model = clone_layer_component ( implementation_model , ImplementationModel ) if imp_model is None : return None pathways = implementation_model . pathways cloned_pathways = [] for p in pathways : cloned_ncs = clone_ncs_pathway ( p ) if cloned_ncs is not None : cloned_pathways . append ( cloned_ncs ) imp_model . pathways = cloned_pathways return imp_model","title":"clone_implementation_model()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.clone_layer_component","text":"clone_layer_component ( layer_component , model_cls ) Clones a layer-based model component. Parameters: Name Type Description Default layer_component LayerModelComponent Layer-based model component to clone. required model_cls Callable [[ UUID , str , str ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent A new instance of the cloned model component. It will return None if the input is not a layer-based model component. Source code in src/cplus_plugin/models/helpers.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def clone_layer_component ( layer_component : LayerModelComponent , model_cls : typing . Callable [[ uuid . UUID , str , str ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Clones a layer-based model component. :param layer_component: Layer-based model component to clone. :type layer_component: LayerModelComponent :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: A new instance of the cloned model component. It will return None if the input is not a layer-based model component. :rtype: LayerModelComponent \"\"\" if not isinstance ( layer_component , LayerModelComponent ): return None cloned_component = model_cls ( layer_component . uuid , layer_component . name , layer_component . description ) for f in fields ( layer_component ): attr_val = getattr ( layer_component , f . name ) setattr ( cloned_component , f . name , attr_val ) return cloned_component","title":"clone_layer_component()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.clone_ncs_pathway","text":"clone_ncs_pathway ( ncs ) Creates a deep copy of the given NCS pathway. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to clone. required Returns: Type Description NcsPathway A deep copy of the original NCS pathway object. Source code in src/cplus_plugin/models/helpers.py 284 285 286 287 288 289 290 291 292 293 def clone_ncs_pathway ( ncs : NcsPathway ) -> NcsPathway : \"\"\"Creates a deep copy of the given NCS pathway. :param ncs: NCS pathway to clone. :type ncs: NcsPathway :returns: A deep copy of the original NCS pathway object. :rtype: NcsPathway \"\"\" return clone_layer_component ( ncs , NcsPathway )","title":"clone_ncs_pathway()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.copy_layer_component_attributes","text":"copy_layer_component_attributes ( target , source ) Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. Parameters: Name Type Description Default target LayerModelComponent Target object whose attribute values will be updated. required source LayerModelComponent Source object whose attribute values will be copied to the target. required Returns: Type Description LayerModelComponent Target object containing the updated attribute values apart for the uuid whose value will not change. Source code in src/cplus_plugin/models/helpers.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def copy_layer_component_attributes ( target : LayerModelComponent , source : LayerModelComponent ) -> LayerModelComponent : \"\"\"Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. :param target: Target object whose attribute values will be updated. :type target: LayerModelComponent :param source: Source object whose attribute values will be copied to the target. :type source: LayerModelComponent :returns: Target object containing the updated attribute values apart for the uuid whose value will not change. :rtype: LayerModelComponent \"\"\" if not isinstance ( target , LayerModelComponent ) or not isinstance ( source , LayerModelComponent ): raise TypeError ( \"Source or target objects are not of type 'LayerModelComponent'\" ) for f in fields ( source ): # Exclude uuid if f . name == UUID_ATTRIBUTE : continue attr_val = getattr ( source , f . name ) setattr ( target , f . name , attr_val ) # Force layer to be set/updated target . update_layer_type () return target","title":"copy_layer_component_attributes()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_implementation_model","text":"create_implementation_model ( source_dict ) Factory method for creating an implementation model using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description ImplementationModel Implementation model with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def create_implementation_model ( source_dict ) -> typing . Union [ ImplementationModel , None ]: \"\"\"Factory method for creating an implementation model using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: Implementation model with property values set from the dictionary. :rtype: ImplementationModel \"\"\" implementation_model = create_layer_component ( source_dict , ImplementationModel ) if PRIORITY_LAYERS_SEGMENT in source_dict . keys (): implementation_model . priority_layers = source_dict [ PRIORITY_LAYERS_SEGMENT ] # Set style if STYLE_ATTRIBUTE in source_dict . keys (): implementation_model . layer_styles = source_dict [ STYLE_ATTRIBUTE ] # Set styling pixel value if PIXEL_VALUE_ATTRIBUTE in source_dict . keys (): implementation_model . style_pixel_value = source_dict [ PIXEL_VALUE_ATTRIBUTE ] return implementation_model","title":"create_implementation_model()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_layer_component","text":"create_layer_component ( source_dict , model_cls ) Factory method for creating a layer model component using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required model_cls Callable [[ UUID , str , str , str , LayerType , bool ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent Layer model component object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def create_layer_component ( source_dict , model_cls : typing . Callable [ [ uuid . UUID , str , str , str , LayerType , bool ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Factory method for creating a layer model component using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: Layer model component object with property values set from the dictionary. :rtype: LayerModelComponent \"\"\" if UUID_ATTRIBUTE not in source_dict : return None source_uuid = source_dict [ UUID_ATTRIBUTE ] if isinstance ( source_uuid , str ): source_uuid = uuid . UUID ( source_uuid ) kwargs = {} if PATH_ATTRIBUTE in source_dict : kwargs [ PATH_ATTRIBUTE ] = source_dict [ PATH_ATTRIBUTE ] if LAYER_TYPE_ATTRIBUTE in source_dict : kwargs [ LAYER_TYPE_ATTRIBUTE ] = LayerType ( int ( source_dict [ LAYER_TYPE_ATTRIBUTE ])) if USER_DEFINED_ATTRIBUTE in source_dict : kwargs [ USER_DEFINED_ATTRIBUTE ] = bool ( source_dict [ USER_DEFINED_ATTRIBUTE ]) return model_cls ( source_uuid , source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], ** kwargs , )","title":"create_layer_component()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_model_component","text":"create_model_component ( source_dict , model_cls ) Factory method for creating and setting attribute values for a base model component object. Parameters: Name Type Description Default source_dict dict Dictionary containing attribute values. required model_cls Callable [[ UUID , str , str ], BaseModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description BaseModelComponent Base model component object with property values derived from the dictionary. Source code in src/cplus_plugin/models/helpers.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def create_model_component ( source_dict : dict , model_cls : typing . Callable [[ uuid . UUID , str , str ], BaseModelComponentType ], ) -> typing . Union [ BaseModelComponentType , None ]: \"\"\"Factory method for creating and setting attribute values for a base model component object. :param source_dict: Dictionary containing attribute values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: BaseModelComponent :returns: Base model component object with property values derived from the dictionary. :rtype: BaseModelComponent \"\"\" if not issubclass ( model_cls , BaseModelComponent ): return None return model_cls ( uuid . UUID ( source_dict [ UUID_ATTRIBUTE ]), source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], )","title":"create_model_component()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_ncs_pathway","text":"create_ncs_pathway ( source_dict ) Factory method for creating an NcsPathway object using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description NcsPathway NCS pathway object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def create_ncs_pathway ( source_dict ) -> typing . Union [ NcsPathway , None ]: \"\"\"Factory method for creating an NcsPathway object using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: NCS pathway object with property values set from the dictionary. :rtype: NcsPathway \"\"\" ncs = create_layer_component ( source_dict , NcsPathway ) # We are checking because of the various iterations of the attributes # in the NcsPathway class where some of these attributes might # be missing. if CARBON_PATHS_ATTRIBUTE in source_dict : ncs . carbon_paths = source_dict [ CARBON_PATHS_ATTRIBUTE ] return ncs","title":"create_ncs_pathway()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.extent_to_project_crs_extent","text":"extent_to_project_crs_extent ( spatial_extent , project = None ) Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required project QgsProject Project whose CRS will be used to determine the values of the output extent. None Returns: Type Description QgsRectangle Output extent in the project's CRS. If the input extent is invalid, this function will return None. Source code in src/cplus_plugin/models/helpers.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 def extent_to_project_crs_extent ( spatial_extent : SpatialExtent , project : QgsProject = None ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :param project: Project whose CRS will be used to determine the values of the output extent. :type project: QgsProject :returns: Output extent in the project's CRS. If the input extent is invalid, this function will return None. :rtype: QgsRectangle \"\"\" input_rect = extent_to_qgs_rectangle ( spatial_extent ) if input_rect is None : return None default_crs = QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) if not default_crs . isValid (): return None if project is None : project = QgsProject . instance () target_crs = project . crs () if default_crs == target_crs : # No need for transformation return input_rect try : coordinate_xform = QgsCoordinateTransform ( default_crs , project . crs (), project ) return coordinate_xform . transformBoundingBox ( input_rect ) except Exception as e : log ( f \" { e } , using the default input extent.\" ) return input_rect","title":"extent_to_project_crs_extent()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.extent_to_qgs_rectangle","text":"extent_to_qgs_rectangle ( spatial_extent ) Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required Returns: Type Description QgsRectangle QGIS rectangle defining the bounds for the scenario. Source code in src/cplus_plugin/models/helpers.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def extent_to_qgs_rectangle ( spatial_extent : SpatialExtent , ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :returns: QGIS rectangle defining the bounds for the scenario. :rtype: QgsRectangle \"\"\" if len ( spatial_extent . bbox ) < 4 : return None return QgsRectangle ( spatial_extent . bbox [ 0 ], spatial_extent . bbox [ 2 ], spatial_extent . bbox [ 1 ], spatial_extent . bbox [ 3 ], )","title":"extent_to_qgs_rectangle()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.layer_component_to_dict","text":"layer_component_to_dict ( layer_component , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from a layer model component object. Parameters: Name Type Description Default layer_component LayerModelComponentType Source layer model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def layer_component_to_dict ( layer_component : LayerModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a layer model component object. :param layer_component: Source layer model component object whose values are to be mapped to the corresponding attribute names. :type layer_component: LayerModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_attrs = model_component_to_dict ( layer_component , uuid_to_str ) base_attrs [ PATH_ATTRIBUTE ] = layer_component . path base_attrs [ LAYER_TYPE_ATTRIBUTE ] = int ( layer_component . layer_type ) base_attrs [ USER_DEFINED_ATTRIBUTE ] = layer_component . user_defined return base_attrs","title":"layer_component_to_dict()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.model_component_to_dict","text":"model_component_to_dict ( model_component , uuid_to_str = True ) Creates a dictionary containing the base attribute name-value pairs from a model component object. Parameters: Name Type Description Default model_component BaseModelComponentType Source model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def model_component_to_dict ( model_component : BaseModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing the base attribute name-value pairs from a model component object. :param model_component: Source model component object whose values are to be mapped to the corresponding attribute names. :type model_component: BaseModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" model_uuid = model_component . uuid if uuid_to_str : model_uuid = str ( model_uuid ) return { UUID_ATTRIBUTE : model_uuid , NAME_ATTRIBUTE : model_component . name , DESCRIPTION_ATTRIBUTE : model_component . description , }","title":"model_component_to_dict()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.ncs_pathway_to_dict","text":"ncs_pathway_to_dict ( ncs_pathway , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. Parameters: Name Type Description Default ncs_pathway NcsPathway Source NCS pathway object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def ncs_pathway_to_dict ( ncs_pathway : NcsPathway , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. :param ncs_pathway: Source NCS pathway object whose values are to be mapped to the corresponding attribute names. :type ncs_pathway: NcsPathway :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_ncs_dict = layer_component_to_dict ( ncs_pathway , uuid_to_str ) base_ncs_dict [ CARBON_PATHS_ATTRIBUTE ] = ncs_pathway . carbon_paths return base_ncs_dict","title":"ncs_pathway_to_dict()"},{"location":"developer/api/models/api_report/","text":"Report Data models for report production. ReportContext dataclass Context information for generating a report. ReportResult dataclass Detailed result information from a report generation run. pdf_path property pdf_path Returns the absolute path to the PDF file if the process completed successfully. Caller needs to verify if the file actually exists in the given location. :returns: Absolute path to the PDF file if the process completed successfully else an empty string. ReportSubmitStatus dataclass Result of report submission process.","title":"Report"},{"location":"developer/api/models/api_report/#report","text":"Data models for report production.","title":"Report"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportContext","text":"Context information for generating a report.","title":"ReportContext"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportResult","text":"Detailed result information from a report generation run.","title":"ReportResult"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportResult.pdf_path","text":"pdf_path Returns the absolute path to the PDF file if the process completed successfully. Caller needs to verify if the file actually exists in the given location. :returns: Absolute path to the PDF file if the process completed successfully else an empty string.","title":"pdf_path"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportSubmitStatus","text":"Result of report submission process.","title":"ReportSubmitStatus"},{"location":"developer/architecture/","text":"Architecture Frameworks used High-level system architecture Data model","title":"Architecture"},{"location":"developer/architecture/#architecture","text":"","title":"Architecture"},{"location":"developer/architecture/#frameworks-used","text":"","title":"Frameworks used"},{"location":"developer/architecture/#high-level-system-architecture","text":"","title":"High-level system architecture"},{"location":"developer/architecture/#data-model","text":"","title":"Data model"},{"location":"developer/documentation/","text":"Working with documentation Documentation is written using mkdocs . A detailed description on getting-started with mkdocs is available here . Developer documentation will be created and generated using mkdocstrings . Install mkdocs Open the terminal Run \"pip install mkdocs\" This should install mkdocs and all requirements Creating a new project This should not be required as the mkdocs has been created already, but serves more of a guide for a user whom are new to mkdocs. Open the terminal Run \"mkdocs new .\" This will generate the documents folder with the home page index markdown file Updating the mkdocs.yml file Mostly, the only changes a user will need to make is to the nav section in the mkdocs.yml file ( Figure 1 ). Other options, such as the themes, plugins and extensions, should require no changes. Figure 1: Navigation example of mkdocs Here is an explanation on how the nav should be updated: It is important to keep to the structure of the mkdocs Each section focusses on a particular aspect, for example User will provide information on installing the plugin, a guide on how to use the plugin, etc. The order in which the nav is structured will determine the tabs order on the site, as shown in Figure 2 Figure 2: Tabs in a generated site Each tab, or group, will then be structured as in Figure 3 Figure 3: Structure created by markdown headings The additional titles (in the Plugin guide section in the above example) is based on the headings provided in the guide markdown file ( cplus_ui_guide.md in this case) Headings for each section should be short, but descriptive The section itself can have a more detailed description Add screenshots where possible. This will make the guide(s) user-friendly mkdocstrings This is an important aspect of documenting code. Using mkdocstrings is an easy and effective way of keeping track of classes, functions, etc. Any changes to the code will automatically update here, but the developer needs to make the changes in the code (comments) for this to happen. The comments for mkdocstrings is three sections: Description: A description on what the function does. A destailed description are welcome param: List of parameters for the function. Type and description should be included returns: A list of values which the function would return. Type should be included, with a description Here is an example of the end-result: mkdocstrings options The user can also do fine-tuning of the resulting site. Here is a list of important options to be aware of: members, show_root_directory, show_source, and heading_level. heading_level : The header level of the content (functions, etc.) which will be added members : Only these function/classes will be shown show_root_directory : The root directory of the code Best will be to disable this, as it looks neater Here is an example of show_root_directory enabled, followed by an example when it is disabled: show_source : Shows the directory of the source code and a snippet of the code More information on this can be found here . Serving the pages locally This step is useful when making changes and the user wants to test and review their changes to the mkdocs before creating a pull request. Open the terminal Run \"mkdocs serve\" Figure 4 shows an example of the result Figure 4: Console example of serving mkdocs On default, mkdocs is served to localhost:8000. But if the port is already in use, the user needs to provide a port number Run \"mkdocs serve -a localhost:8001\". The user can use a port number of their choosing Open the URL in a browser: localhost:8000 The Home page should be similar to Figure 5 Figure 5: Site example. This is the Home page Errors When performing the serve, mkdocs will automatically check for any errors. An example will be when a file linked in the documentation cannot be found ( Figure 6 ). Figure 6: Missing file example when serving mkdocs Be sure to check for such errors in the console prior to creating a pull request for your documentation changes. GitHub pages This is only required if it has not been set up on GitHub for the repository, or if it has been disabled. Only a user with admin rights to the repository will be able to do this. Go to the repository and click on Settings Click on Pages Set the branch to \"gh-pages\" Click Save Select the action Select Deploy Open the Run mkdocs gh-deploy section The URL should be https://kartoza.github.io/cplus-plugin/","title":"Documentation"},{"location":"developer/documentation/#working-with-documentation","text":"Documentation is written using mkdocs . A detailed description on getting-started with mkdocs is available here . Developer documentation will be created and generated using mkdocstrings .","title":"Working with documentation"},{"location":"developer/documentation/#install-mkdocs","text":"Open the terminal Run \"pip install mkdocs\" This should install mkdocs and all requirements","title":"Install mkdocs"},{"location":"developer/documentation/#creating-a-new-project","text":"This should not be required as the mkdocs has been created already, but serves more of a guide for a user whom are new to mkdocs. Open the terminal Run \"mkdocs new .\" This will generate the documents folder with the home page index markdown file","title":"Creating a new project"},{"location":"developer/documentation/#updating-the-mkdocsyml-file","text":"Mostly, the only changes a user will need to make is to the nav section in the mkdocs.yml file ( Figure 1 ). Other options, such as the themes, plugins and extensions, should require no changes. Figure 1: Navigation example of mkdocs Here is an explanation on how the nav should be updated: It is important to keep to the structure of the mkdocs Each section focusses on a particular aspect, for example User will provide information on installing the plugin, a guide on how to use the plugin, etc. The order in which the nav is structured will determine the tabs order on the site, as shown in Figure 2 Figure 2: Tabs in a generated site Each tab, or group, will then be structured as in Figure 3 Figure 3: Structure created by markdown headings The additional titles (in the Plugin guide section in the above example) is based on the headings provided in the guide markdown file ( cplus_ui_guide.md in this case) Headings for each section should be short, but descriptive The section itself can have a more detailed description Add screenshots where possible. This will make the guide(s) user-friendly","title":"Updating the mkdocs.yml file"},{"location":"developer/documentation/#mkdocstrings","text":"This is an important aspect of documenting code. Using mkdocstrings is an easy and effective way of keeping track of classes, functions, etc. Any changes to the code will automatically update here, but the developer needs to make the changes in the code (comments) for this to happen. The comments for mkdocstrings is three sections: Description: A description on what the function does. A destailed description are welcome param: List of parameters for the function. Type and description should be included returns: A list of values which the function would return. Type should be included, with a description Here is an example of the end-result:","title":"mkdocstrings"},{"location":"developer/documentation/#mkdocstrings-options","text":"The user can also do fine-tuning of the resulting site. Here is a list of important options to be aware of: members, show_root_directory, show_source, and heading_level. heading_level : The header level of the content (functions, etc.) which will be added members : Only these function/classes will be shown show_root_directory : The root directory of the code Best will be to disable this, as it looks neater Here is an example of show_root_directory enabled, followed by an example when it is disabled: show_source : Shows the directory of the source code and a snippet of the code More information on this can be found here .","title":"mkdocstrings options"},{"location":"developer/documentation/#serving-the-pages-locally","text":"This step is useful when making changes and the user wants to test and review their changes to the mkdocs before creating a pull request. Open the terminal Run \"mkdocs serve\" Figure 4 shows an example of the result Figure 4: Console example of serving mkdocs On default, mkdocs is served to localhost:8000. But if the port is already in use, the user needs to provide a port number Run \"mkdocs serve -a localhost:8001\". The user can use a port number of their choosing Open the URL in a browser: localhost:8000 The Home page should be similar to Figure 5 Figure 5: Site example. This is the Home page","title":"Serving the pages locally"},{"location":"developer/documentation/#errors","text":"When performing the serve, mkdocs will automatically check for any errors. An example will be when a file linked in the documentation cannot be found ( Figure 6 ). Figure 6: Missing file example when serving mkdocs Be sure to check for such errors in the console prior to creating a pull request for your documentation changes.","title":"Errors"},{"location":"developer/documentation/#github-pages","text":"This is only required if it has not been set up on GitHub for the repository, or if it has been disabled. Only a user with admin rights to the repository will be able to do this. Go to the repository and click on Settings Click on Pages Set the branch to \"gh-pages\" Click Save Select the action Select Deploy Open the Run mkdocs gh-deploy section The URL should be https://kartoza.github.io/cplus-plugin/","title":"GitHub pages"},{"location":"developer/setup/","text":"Setup To use the plugin for development purposes, clone the repository locally, install pip, a python dependencies management tool see https://pypi.org/project/pip/ Create virtual environment Using any python virtual environment manager create project environment. Recommending to use virtualenv-wrapper . It can be installed using python pip pip install virtualenvwrapper Create virtual environment mkvirtualenv cplus Using the pip, install plugin development dependencies by running pip install -r requirements-dev.txt To install the plugin into the QGIS application, activate virtual environment and then use the below command python admin.py install","title":"Setup"},{"location":"developer/setup/#setup","text":"To use the plugin for development purposes, clone the repository locally, install pip, a python dependencies management tool see https://pypi.org/project/pip/","title":"Setup"},{"location":"developer/setup/#create-virtual-environment","text":"Using any python virtual environment manager create project environment. Recommending to use virtualenv-wrapper . It can be installed using python pip pip install virtualenvwrapper Create virtual environment mkvirtualenv cplus Using the pip, install plugin development dependencies by running pip install -r requirements-dev.txt To install the plugin into the QGIS application, activate virtual environment and then use the below command python admin.py install","title":"Create virtual environment"},{"location":"user/","text":"Users The following sections aims at guiding and helping a user on how to use the plugin. This is split into three sections: The quickstart tutorial shows how to install the plugin and help the user to get familiar with the platform. The user guide details common workflows in a tutorial format. The user manual describes the user interface and the various options of the plugin.","title":"Users"},{"location":"user/#users","text":"The following sections aims at guiding and helping a user on how to use the plugin. This is split into three sections: The quickstart tutorial shows how to install the plugin and help the user to get familiar with the platform. The user guide details common workflows in a tutorial format. The user manual describes the user interface and the various options of the plugin.","title":"Users"},{"location":"user/guide/","text":"Guide Preparing data Data preparation is an important step prior to performing data analysis. This is especially true for spatial data (rasters and vector layers), as there is a lot of factors which plays a role in the end result. Here are some factors which needs to be considered: The data should cover the same spatial extent or overlap each other Coordinate systems are very important when it comes to the accuracy of your spatial analysis. For most analysis a projected coordinate system (e.g. UTM, Albers Equal Area Conic, South African LO-system, etc) is preferred above a geographic coordinate system (WGS84, Hartebeesthoek84, etc). This is because calculating distances and areas is much more accurate with projected coordinate systems Best practice will be to make use of the same coordinate system for each layer. Having a geographic coordinate for some layers, and projected coordinate systems for other, can have negative impacts on your results When working with rasters, be sure that the nodata value is set correctly, otherwise the nodata value will be unknown during analysis and will be considered as a normal pixel value The plugin can only work with raster layers. If you have data in vector format, consider converting it to a raster Any outlier values needs to be removed from the spatial data prior to performing analysis Taking into account the above can greatly improve the analysis and the results produced from the analysis. This section will further deal with how to prepare your data using tools available in QGIS. Click Processing -> Toolbox to open the QGIS toolbox The toolbox will be used for each section Carbon and Priority weighted layers Both Carbon and Priority weighted layers (PWL) should not contain any nodata values. If the nodata pixels is not removed from the rasters, the user's analysis will be less efficient and likely result in a reduction in results (e.g. all nodata pixels will end up as nodata). Figure 1 shows a Carbon raster with nodata pixels. Figure 1: Raster with nodata pixels Follow these easy steps to remove nodata pixels from a raster: In the toolbox search, type \"fill nodata\" Open the tool Fill NoData cells Provide the parameters as follows: Raster input : Raster layer with nodata pixels which should be removed Fill value : Zero should suffice for most cases Output raster : Directory to which the filled raster should be stored Figure 2: QGIS Fill nodata cells Click Run Figure 3 shows a nodata filled raster. Figure 3: Raster with nodata pixels remove/filled Coordinate systems Fix layers with an undefined CRS Sometimes a spatial dataset might not have its coordinate system defined. This can cause issues and needs to be resolved prior to perform analysis. An unknown coordinate system can be identified as follows: Open the layer in QGIS QGIS will show a warning next to the layer This warning will explain that the coordinate system is not defined Figure 4: Unknown CRS for a layer in QGIS Further investigation can be done by right-clicking on the layer and select Properties Click on the Information tab Scroll down to Coordinate Reference System (CRS) Unknown will be shown if the CRS is not set Figure 5: QGIS layer properties To define the CRS, do the following: Type \"assign projection\" in the toolbox search Open the Assign Projection tool in the Raster Projections section If its a vector layer, open the Assign Projection tool in the Vector general section Set the parameters as follows: Input layer : Layer which has an undefined CRS Desired CRS : CRS which the layer coordinates is using Click Run Check if the layer is at its correct position in the QGIS canvas Figure 6: QGIS Assign projection tool Be sure you are using the correct coordinate system when defining an unknown coordinate system to a layer. If the incorrect coordinate system is selected, the data will likely not be at the correct position spatially. Reprojecting (Warping) Best will be to convert each dataset in a geographic coordinate system to a projected coordinate system Type warp in the QGIS toolbox search Under Raster projections , select Warp Figure 7: QGIS Warp tool Provide the following parameters: Input layer : Layer thee user wants to reproject Source CRS : Current CRS of the layer Target CRS : The CRS to what the layer should be projected Resampling method to use : Nearest Neighbour. Using other options will change pixel values, which we don't want Nodata value : Leave empty, except if the user wants to change the nodata value Reprojected : The output file Click Run Do this for all geographic coordinate system rasters As mentioned above, best will be for all layers to make use of the same coordinate system Nodata value If a nodata value for a raster is not set correctly, it will be considered as a pixel value which is part of the analysis. This can have a negative impact on the analysis results. How to check if a raster's nodata is set correctly Right-click on the raster in QGIS Select Properties Select the Information tab Scroll down to the Bands section Under No-data there should be a value If there is no value, this means that the nodata is not set correctly and therefore needs to be fixed Figure 8: Layer properties to check for nodata value To fix a nodata issue, do the following: Type Translate in the toolbox search Open the Translate tool under Raster Conversion Figure 9: QGIS Translate tool Provide the following parameters: Input layer : Raster layer Assign a specific nodata value to output bands : Provide a desired value here. -9999 will suffice for most cases Converted : Output raster This should solve a nodata issue with a raster. The Translate tool is to convert a raster to another format, but the user can still make use of the same format. This tool is useful to correctly set nodata values when needed. Outlier pixels/values A user must check if the raster data only include pixel values within the range it should be. If there are any pixels values outside the range of accepted values, those pixels needs to be removed. This can be accomplished using the Reclassify by table tool. Type reclassify by table in the QGIS toolbox search Select the Reclassify by table tool Set the parameters as follows: Raster layer : Layer to be reclassed Band number : Like the first band Reclassified raster : Output raster Reclassification table : Rules for the reclassification (explanation follows) Figure 10: QGIS Reclassify by Table tool Open the Reclassification table so that the user can set the value reclassifcations. Atleast one row needs to be provided Click Add Row Provide a Minimum and Maximum value. Consider the following: Minimum must be less than maximum if providing a range If only a single value needs to be reclassified, set the Minimum and Maximum to the same value Set the new Value for each row: Value has to be numeric If a user wants to remove a pixel/value from the analysis, the value needs to be set to the nodata value of the raster (e.g. -9999). See the above section on the Nodata value on how to find the nodata value of a raster Figure 11: Reclassify table Click Run An example of the resulting raster compared to the original raster is shown in Figure 12 Figure 12: Reclassified raster compared to the original raster Vector to raster As mentioned above, the plugin can only work with raster layers. But often a user might have some data in vector format. This can easily be resolved by converting the vector layer to a raster, which can then be used as input to the plugin. Firstly, we want to convert the vector layer to make use of the same projected coordinate system than other data. This can be done as follows: Type 'Reproject layer' in the QGIS toolbox search Select the 'Reproject layer' tool in the 'Vector general' section Figure 13: QGIS Reproject tool for vector layers Set the parameters as follows: Input layer : Vector layer which needs to be reprojected Target CRS : Coordinate system to which the layer should be reprojected, preferrably a projected coordinate system Reprojected : The output layer Click Run Now that the vector layer is in the correct coordinate system, the user can convert the vector layer to a raster: Type 'rasterize' in the QGIS toolbox search Select 'Rasterize (vector to raster)' Figure 14: QGIS Rasterize tool Set the parameters as follows: Input layer : The vector layer to convert to a raster Field to use to burn : Attribute field to use as the raster pixel values A fixed value to burn : A default value for empty fields for a feature. Otherwise leave as is Output raster size units : Georeferenced units Width and Height : Spatial resolution in meters. If the vector layer is in geograpghic coordinates, this distance will be degrees not meters Output extent : Leave as is, except if the user wants to limit the output to an extent Assign a specific nodata value to output bands : -9999 will suffice for most cases Rasterized : The output raster Click Run The user's data should now be ready for analysis. CPLUS settings The user can follow two approaches to open the CPLUS settings. QGIS options ( Figure 15 ): Click on Settings -> Options Figure 15: QGIS settings Select the CPLUS tab to the left This will open the CPLUS settings dialog. See Figure 16 for an example Figure 16: CPLUS section as loaded in the QGIS settings dialog CPLUS toolbar ( Figure 17 ): - Click on the CPLUS toolbar drop-down - Select Settings - This will take you directly to the CPLUS settings dialog in the QGIS options Figure 17: CPLUS toolbar button A short description of each available setting a user can change. Most are optional, but the user needs to set the base directory as its a requirement for the processing to work (e.g. outputs are stored in the base directory). Another important option to consider is snapping, as it will improve analysis results. Configure Analysis : Settings will be added as the plugin development continues Reports : Information which will be included when a report is generated. These settings are optional, and will be excluded from the report if not provided Organization : The organization(s) to be included in the report Contact Email : Contact email for the author Website : A website link to the project or company Custom logo : Enable and provide a custom logo of your choosing. If disabled, the CI logo will be used in the report Footer : Footer section for the report Disclaimer : A disclaimer to be added to the report License : A license to be added to the report Advanced : Base data directory (required): Data accessed and download by the plugin will be stored here Coefficient for carbon layers : Value applied during processing to the carbon-based layers. Default is 0 Pathway suitability index : Index multiplied to the pathways. Lower values means the pathway is less important, higher means its more important Snapping : Will set rasters to match the cell alignment of a reference layer Resample method : Resampling performed on pixel values Reference layer : The reference layer to which the cell alignment will be applied Rescale values : Rescale values according to cell size Figure 18 shows an example of updating and applying CPLUS settings. Figure 18: CPLUS settings example Perform analysis Figure 19 shows the toolbar button/menu for the plugin. Clicking on the icon will open the plugin. When a user clicks on the drop-down button, they will be presented with four options: CPLUS : Close or open the plugin dock widget Settings : Open the settings for the plugin Help : Takes the user to the online guide for the plugin About : Will take the user to the About section on the GH pages Figure 19: CPLUS toolbar icon Open the CPLUS dockwidget by clicking on the CPLUS toolbar icon ( Figure 19 ). Step 1: Scenario Information The first step focuses on the Scenario Information . A Scenario refers to an overall analysis done in an area of interest (AOI). Different criteria and priorities for spatial decision-making and comparison will be considered for each scenario. Scenario name : A name for the analysis to be performed Scenario description : A detailed description of the analysis Extent : The area of interest for this analysis. This can be calculated from the current canvas view extent, a layer, or an extent drawn by the user Figure 20 shows an example of Step 1 Once the information has been provided, click Step 2 If the QGIS canvas CRS is not set to WGS84 (EPSG: 4326), the zoom to pilot area will not happen. Figure 20: Step 1 focuses on Scenario Information Pilot area The pilot study area covers Bushback Ridge, South Africa. When a user's study area is outside of this region, some of the Implementation models and Priority weighted layers will be disabled. This is because those datasets are specific to the Bushback Ridge study area and are of no use for other AOIs. It's important for a user to take this into account, as step 2 and step 3 will be affected by this. If the selected extent is outside of this region, the Bushback Ridge Implementation models will be disabled. The same goes for the Priority Weighted layers. If a user is outside the Bushback Ridge region, they will need to create custom IMs and/or PWLs. Explanation on these follows in the following sections. Step 2: Pathways and models This step deals with the Natural Climate Solution (NCS) pathways and the Implementation models (IM) . A NCS pathway can be defined as a composite spatial layer on specific land use classes and other factors that determine areas ideal for a specific use case (e.g. Animal mangement). An IM is a combination of NCS pathways represented in an AOI spatial layer. Figure 21 shows the UI. Figure 22: Step 2 allows the user to create and edit NCS pathways and Implementation Models Step 2 buttons ( Figure 18 ): Add : Adds a new pathway or model Delete : Delete a pathway or model Editing : Edit and existing pathway or model Refresh view : Checks the base directory for data Figure 23: Create, delete, and edit buttons NCS Pathway Click on the left green plus button to add a new pathway ( Figure 24 ) Provide a Name and Description for the pathway Two approaches to select a layer: A layer from the QGIS canvas , or Upload from a file Add Carbon layers as desired. Multiple carbon layers can be provided. These layers will be averaged Click OK The new NCS pathway will be added If the NCS pathway is broken (e.g. layer or file cannot be found), the pathway text will have an exclamation mark next to it. The user will need to rectify the issue before continuing to step 3. Figure 24: NCS Pathway creator/editor Be sure each NCS pathway's Carbon layers is set up correctly before setting up the Implementation models in the steps which follows. Changes to the Carbon layers afterward will require the user to set up the Implementation model again. Implementation model Add pathways to an existing IM: Select the IM to which a pathway should be added Select the pathway you want to add to the IM Click the right arrow to add a pathway to the selected IM Click the double right arrow to add all pathways to the IM The user can also drag-and-drop a pathway onto the desired IM How to add a new IM: Click on the right green plus button to add an Implementation model ( Figure 25 ) Provide a Name and Description (optional) The user can provide an existing raster for the IM. Enable Map layer to do this Click OK The new Implementation model will be added Figure 25: Implementation Model creator/editor Open the Style pixel value editor by clicking on the button Select the IM which needs to be moved up or down in the stack Drag-and-drop the IM where it needs to be in the stack Click OK once done The final step is to select each of the IMs a user want to include in the scenario run A user can exclude IMs if they don't want to include it, even if the IM has pathways Figure 26: Selected Implementation models Before proceeding to Step 3, a user needs to define at least one NCS pathway layer for an implementation model, otherwise a warning message will be displayed. Step 3: Priority weighting The final step deals with the Weighting priorities and Priority groups . These weights will be applied when the user starts running the scenario. An example is shown in Figure 27 . Weight values ranges from 0 to 5, and affects how important a PWL is compared to other layers A value of 0 indicates that the PWL has a lower importance A value of 5 means that the PWL has a higher importance Figure 27: Step 3 allows the user to set the Weights of each Priority Group The priority weighting layers can be selected and added and removed into each priority group by using the arrow buttons. Add priority layers Select the target layer from the priority weighting layers list and the destination group from the priority groups and use the left arrow button to add the layer into the group. Remove priority layers Select the target layer from the priority weighting layers list from its priority group and use the right arrow button to remove the layer into the group. Create custom priority layers Click on to add a new custom priority layer, or to edit an existing priority layer This will open the Priority Layer dialog (see Figure 23 ) The following parameters needs to be set: Priority layer : The layer which represents the priority layer Priority layer name : A unique identifier for the priority layer Priority layer description : A detailed description of the priority layer Click the Assign implementation models button to select IMs to be associated with the priority layer (see Figure 28 ) Figure 28: Priority layer dialog Select the IMs you want to be associated with the priority layer Click OK Figure 29: Implementation model selection for priority layers : Remove the selected PWL Setting groups values Move the slider to adjust the weight of each group, values can also be set manually, by using the left input spin box. Once done selecting weights, click Run Scenario button to run the analysis. Steps 1 to 3 example The following recording ( Figure 25 ) shows an example on how to do Step 1, 2 and 3. This is based on the pilot study area. Figure 30: Shows how to implement Step 1, 2 and 3 in QGIS Processing Once the user has provided all desired parameters, click Run Scenario The processing dialog will open ( Figure 31 ) The processing will take a while, depending on the number of IMs and pathways provided for each IM Click the Cancel button to stop the processing Figure 31: Processing dialog while the algorithm is running Figure 32 will be the result if the processing succceeded The user should take note that the View Report button is now available Figure 32: Processing dialog if successfull Processing results The following groups and layers will be added to the QGIS canvas once the processing finishes (see Figure 33 ): - A group containing the Scenario results - Implementation Model Maps : Non-weighted IMs created by the user in Step 2 - Weighted Implementation Model Maps : Weighted IMs based on the IMs added in Step 2 and weighing set in Step 3 - NCS Pathways Maps : Pathways used for each IM in Step 2. If a IM layer were provided as the IM in Step 2, this will contain no pathways Figure 33: Groups and layers added to the QGIS canvas An example of output results in QGIS is detailed by Figure 33 Figure 34: A recording example of an example scenario Report generating Click the View Report button The user will have the following options: Layout designer : Opens the report in the QGIS layout designer Open PDF : Opens the report in PDF format Help : Open the help documentation related to the reports Figure 35: Report options Figure 35 shows an example of a report opened in the layout designer Figure 36: Report opened in the QGIS layout designer Figure 36 shows a report in PDF format Figure 37: PDF version of a report Generated report example Here is an example on how to open a report in the QGIS layout designer, or as a PDF ( Figure 33 ). Figure 38: Example of a generated report in PDF and layout designer formats","title":"Guide"},{"location":"user/guide/#guide","text":"","title":"Guide"},{"location":"user/guide/#preparing-data","text":"Data preparation is an important step prior to performing data analysis. This is especially true for spatial data (rasters and vector layers), as there is a lot of factors which plays a role in the end result. Here are some factors which needs to be considered: The data should cover the same spatial extent or overlap each other Coordinate systems are very important when it comes to the accuracy of your spatial analysis. For most analysis a projected coordinate system (e.g. UTM, Albers Equal Area Conic, South African LO-system, etc) is preferred above a geographic coordinate system (WGS84, Hartebeesthoek84, etc). This is because calculating distances and areas is much more accurate with projected coordinate systems Best practice will be to make use of the same coordinate system for each layer. Having a geographic coordinate for some layers, and projected coordinate systems for other, can have negative impacts on your results When working with rasters, be sure that the nodata value is set correctly, otherwise the nodata value will be unknown during analysis and will be considered as a normal pixel value The plugin can only work with raster layers. If you have data in vector format, consider converting it to a raster Any outlier values needs to be removed from the spatial data prior to performing analysis Taking into account the above can greatly improve the analysis and the results produced from the analysis. This section will further deal with how to prepare your data using tools available in QGIS. Click Processing -> Toolbox to open the QGIS toolbox The toolbox will be used for each section","title":"Preparing data"},{"location":"user/guide/#carbon-and-priority-weighted-layers","text":"Both Carbon and Priority weighted layers (PWL) should not contain any nodata values. If the nodata pixels is not removed from the rasters, the user's analysis will be less efficient and likely result in a reduction in results (e.g. all nodata pixels will end up as nodata). Figure 1 shows a Carbon raster with nodata pixels. Figure 1: Raster with nodata pixels Follow these easy steps to remove nodata pixels from a raster: In the toolbox search, type \"fill nodata\" Open the tool Fill NoData cells Provide the parameters as follows: Raster input : Raster layer with nodata pixels which should be removed Fill value : Zero should suffice for most cases Output raster : Directory to which the filled raster should be stored Figure 2: QGIS Fill nodata cells Click Run Figure 3 shows a nodata filled raster. Figure 3: Raster with nodata pixels remove/filled","title":"Carbon and Priority weighted layers"},{"location":"user/guide/#coordinate-systems","text":"","title":"Coordinate systems"},{"location":"user/guide/#fix-layers-with-an-undefined-crs","text":"Sometimes a spatial dataset might not have its coordinate system defined. This can cause issues and needs to be resolved prior to perform analysis. An unknown coordinate system can be identified as follows: Open the layer in QGIS QGIS will show a warning next to the layer This warning will explain that the coordinate system is not defined Figure 4: Unknown CRS for a layer in QGIS Further investigation can be done by right-clicking on the layer and select Properties Click on the Information tab Scroll down to Coordinate Reference System (CRS) Unknown will be shown if the CRS is not set Figure 5: QGIS layer properties To define the CRS, do the following: Type \"assign projection\" in the toolbox search Open the Assign Projection tool in the Raster Projections section If its a vector layer, open the Assign Projection tool in the Vector general section Set the parameters as follows: Input layer : Layer which has an undefined CRS Desired CRS : CRS which the layer coordinates is using Click Run Check if the layer is at its correct position in the QGIS canvas Figure 6: QGIS Assign projection tool Be sure you are using the correct coordinate system when defining an unknown coordinate system to a layer. If the incorrect coordinate system is selected, the data will likely not be at the correct position spatially.","title":"Fix layers with an undefined CRS"},{"location":"user/guide/#reprojecting-warping","text":"Best will be to convert each dataset in a geographic coordinate system to a projected coordinate system Type warp in the QGIS toolbox search Under Raster projections , select Warp Figure 7: QGIS Warp tool Provide the following parameters: Input layer : Layer thee user wants to reproject Source CRS : Current CRS of the layer Target CRS : The CRS to what the layer should be projected Resampling method to use : Nearest Neighbour. Using other options will change pixel values, which we don't want Nodata value : Leave empty, except if the user wants to change the nodata value Reprojected : The output file Click Run Do this for all geographic coordinate system rasters As mentioned above, best will be for all layers to make use of the same coordinate system","title":"Reprojecting (Warping)"},{"location":"user/guide/#nodata-value","text":"If a nodata value for a raster is not set correctly, it will be considered as a pixel value which is part of the analysis. This can have a negative impact on the analysis results. How to check if a raster's nodata is set correctly Right-click on the raster in QGIS Select Properties Select the Information tab Scroll down to the Bands section Under No-data there should be a value If there is no value, this means that the nodata is not set correctly and therefore needs to be fixed Figure 8: Layer properties to check for nodata value To fix a nodata issue, do the following: Type Translate in the toolbox search Open the Translate tool under Raster Conversion Figure 9: QGIS Translate tool Provide the following parameters: Input layer : Raster layer Assign a specific nodata value to output bands : Provide a desired value here. -9999 will suffice for most cases Converted : Output raster This should solve a nodata issue with a raster. The Translate tool is to convert a raster to another format, but the user can still make use of the same format. This tool is useful to correctly set nodata values when needed.","title":"Nodata value"},{"location":"user/guide/#outlier-pixelsvalues","text":"A user must check if the raster data only include pixel values within the range it should be. If there are any pixels values outside the range of accepted values, those pixels needs to be removed. This can be accomplished using the Reclassify by table tool. Type reclassify by table in the QGIS toolbox search Select the Reclassify by table tool Set the parameters as follows: Raster layer : Layer to be reclassed Band number : Like the first band Reclassified raster : Output raster Reclassification table : Rules for the reclassification (explanation follows) Figure 10: QGIS Reclassify by Table tool Open the Reclassification table so that the user can set the value reclassifcations. Atleast one row needs to be provided Click Add Row Provide a Minimum and Maximum value. Consider the following: Minimum must be less than maximum if providing a range If only a single value needs to be reclassified, set the Minimum and Maximum to the same value Set the new Value for each row: Value has to be numeric If a user wants to remove a pixel/value from the analysis, the value needs to be set to the nodata value of the raster (e.g. -9999). See the above section on the Nodata value on how to find the nodata value of a raster Figure 11: Reclassify table Click Run An example of the resulting raster compared to the original raster is shown in Figure 12 Figure 12: Reclassified raster compared to the original raster","title":"Outlier pixels/values"},{"location":"user/guide/#vector-to-raster","text":"As mentioned above, the plugin can only work with raster layers. But often a user might have some data in vector format. This can easily be resolved by converting the vector layer to a raster, which can then be used as input to the plugin. Firstly, we want to convert the vector layer to make use of the same projected coordinate system than other data. This can be done as follows: Type 'Reproject layer' in the QGIS toolbox search Select the 'Reproject layer' tool in the 'Vector general' section Figure 13: QGIS Reproject tool for vector layers Set the parameters as follows: Input layer : Vector layer which needs to be reprojected Target CRS : Coordinate system to which the layer should be reprojected, preferrably a projected coordinate system Reprojected : The output layer Click Run Now that the vector layer is in the correct coordinate system, the user can convert the vector layer to a raster: Type 'rasterize' in the QGIS toolbox search Select 'Rasterize (vector to raster)' Figure 14: QGIS Rasterize tool Set the parameters as follows: Input layer : The vector layer to convert to a raster Field to use to burn : Attribute field to use as the raster pixel values A fixed value to burn : A default value for empty fields for a feature. Otherwise leave as is Output raster size units : Georeferenced units Width and Height : Spatial resolution in meters. If the vector layer is in geograpghic coordinates, this distance will be degrees not meters Output extent : Leave as is, except if the user wants to limit the output to an extent Assign a specific nodata value to output bands : -9999 will suffice for most cases Rasterized : The output raster Click Run The user's data should now be ready for analysis.","title":"Vector to raster"},{"location":"user/guide/#cplus-settings","text":"The user can follow two approaches to open the CPLUS settings. QGIS options ( Figure 15 ): Click on Settings -> Options Figure 15: QGIS settings Select the CPLUS tab to the left This will open the CPLUS settings dialog. See Figure 16 for an example Figure 16: CPLUS section as loaded in the QGIS settings dialog CPLUS toolbar ( Figure 17 ): - Click on the CPLUS toolbar drop-down - Select Settings - This will take you directly to the CPLUS settings dialog in the QGIS options Figure 17: CPLUS toolbar button A short description of each available setting a user can change. Most are optional, but the user needs to set the base directory as its a requirement for the processing to work (e.g. outputs are stored in the base directory). Another important option to consider is snapping, as it will improve analysis results. Configure Analysis : Settings will be added as the plugin development continues Reports : Information which will be included when a report is generated. These settings are optional, and will be excluded from the report if not provided Organization : The organization(s) to be included in the report Contact Email : Contact email for the author Website : A website link to the project or company Custom logo : Enable and provide a custom logo of your choosing. If disabled, the CI logo will be used in the report Footer : Footer section for the report Disclaimer : A disclaimer to be added to the report License : A license to be added to the report Advanced : Base data directory (required): Data accessed and download by the plugin will be stored here Coefficient for carbon layers : Value applied during processing to the carbon-based layers. Default is 0 Pathway suitability index : Index multiplied to the pathways. Lower values means the pathway is less important, higher means its more important Snapping : Will set rasters to match the cell alignment of a reference layer Resample method : Resampling performed on pixel values Reference layer : The reference layer to which the cell alignment will be applied Rescale values : Rescale values according to cell size Figure 18 shows an example of updating and applying CPLUS settings. Figure 18: CPLUS settings example","title":"CPLUS settings"},{"location":"user/guide/#perform-analysis","text":"Figure 19 shows the toolbar button/menu for the plugin. Clicking on the icon will open the plugin. When a user clicks on the drop-down button, they will be presented with four options: CPLUS : Close or open the plugin dock widget Settings : Open the settings for the plugin Help : Takes the user to the online guide for the plugin About : Will take the user to the About section on the GH pages Figure 19: CPLUS toolbar icon Open the CPLUS dockwidget by clicking on the CPLUS toolbar icon ( Figure 19 ).","title":"Perform analysis"},{"location":"user/guide/#step-1-scenario-information","text":"The first step focuses on the Scenario Information . A Scenario refers to an overall analysis done in an area of interest (AOI). Different criteria and priorities for spatial decision-making and comparison will be considered for each scenario. Scenario name : A name for the analysis to be performed Scenario description : A detailed description of the analysis Extent : The area of interest for this analysis. This can be calculated from the current canvas view extent, a layer, or an extent drawn by the user Figure 20 shows an example of Step 1 Once the information has been provided, click Step 2 If the QGIS canvas CRS is not set to WGS84 (EPSG: 4326), the zoom to pilot area will not happen. Figure 20: Step 1 focuses on Scenario Information","title":"Step 1: Scenario Information"},{"location":"user/guide/#pilot-area","text":"The pilot study area covers Bushback Ridge, South Africa. When a user's study area is outside of this region, some of the Implementation models and Priority weighted layers will be disabled. This is because those datasets are specific to the Bushback Ridge study area and are of no use for other AOIs. It's important for a user to take this into account, as step 2 and step 3 will be affected by this. If the selected extent is outside of this region, the Bushback Ridge Implementation models will be disabled. The same goes for the Priority Weighted layers. If a user is outside the Bushback Ridge region, they will need to create custom IMs and/or PWLs. Explanation on these follows in the following sections.","title":"Pilot area"},{"location":"user/guide/#step-2-pathways-and-models","text":"This step deals with the Natural Climate Solution (NCS) pathways and the Implementation models (IM) . A NCS pathway can be defined as a composite spatial layer on specific land use classes and other factors that determine areas ideal for a specific use case (e.g. Animal mangement). An IM is a combination of NCS pathways represented in an AOI spatial layer. Figure 21 shows the UI. Figure 22: Step 2 allows the user to create and edit NCS pathways and Implementation Models Step 2 buttons ( Figure 18 ): Add : Adds a new pathway or model Delete : Delete a pathway or model Editing : Edit and existing pathway or model Refresh view : Checks the base directory for data Figure 23: Create, delete, and edit buttons","title":"Step 2: Pathways and models"},{"location":"user/guide/#ncs-pathway","text":"Click on the left green plus button to add a new pathway ( Figure 24 ) Provide a Name and Description for the pathway Two approaches to select a layer: A layer from the QGIS canvas , or Upload from a file Add Carbon layers as desired. Multiple carbon layers can be provided. These layers will be averaged Click OK The new NCS pathway will be added If the NCS pathway is broken (e.g. layer or file cannot be found), the pathway text will have an exclamation mark next to it. The user will need to rectify the issue before continuing to step 3. Figure 24: NCS Pathway creator/editor Be sure each NCS pathway's Carbon layers is set up correctly before setting up the Implementation models in the steps which follows. Changes to the Carbon layers afterward will require the user to set up the Implementation model again.","title":"NCS Pathway"},{"location":"user/guide/#implementation-model","text":"Add pathways to an existing IM: Select the IM to which a pathway should be added Select the pathway you want to add to the IM Click the right arrow to add a pathway to the selected IM Click the double right arrow to add all pathways to the IM The user can also drag-and-drop a pathway onto the desired IM How to add a new IM: Click on the right green plus button to add an Implementation model ( Figure 25 ) Provide a Name and Description (optional) The user can provide an existing raster for the IM. Enable Map layer to do this Click OK The new Implementation model will be added Figure 25: Implementation Model creator/editor Open the Style pixel value editor by clicking on the button Select the IM which needs to be moved up or down in the stack Drag-and-drop the IM where it needs to be in the stack Click OK once done The final step is to select each of the IMs a user want to include in the scenario run A user can exclude IMs if they don't want to include it, even if the IM has pathways Figure 26: Selected Implementation models Before proceeding to Step 3, a user needs to define at least one NCS pathway layer for an implementation model, otherwise a warning message will be displayed.","title":"Implementation model"},{"location":"user/guide/#step-3-priority-weighting","text":"The final step deals with the Weighting priorities and Priority groups . These weights will be applied when the user starts running the scenario. An example is shown in Figure 27 . Weight values ranges from 0 to 5, and affects how important a PWL is compared to other layers A value of 0 indicates that the PWL has a lower importance A value of 5 means that the PWL has a higher importance Figure 27: Step 3 allows the user to set the Weights of each Priority Group The priority weighting layers can be selected and added and removed into each priority group by using the arrow buttons.","title":"Step 3: Priority weighting"},{"location":"user/guide/#add-priority-layers","text":"Select the target layer from the priority weighting layers list and the destination group from the priority groups and use the left arrow button to add the layer into the group.","title":"Add priority layers"},{"location":"user/guide/#remove-priority-layers","text":"Select the target layer from the priority weighting layers list from its priority group and use the right arrow button to remove the layer into the group.","title":"Remove priority layers"},{"location":"user/guide/#create-custom-priority-layers","text":"Click on to add a new custom priority layer, or to edit an existing priority layer This will open the Priority Layer dialog (see Figure 23 ) The following parameters needs to be set: Priority layer : The layer which represents the priority layer Priority layer name : A unique identifier for the priority layer Priority layer description : A detailed description of the priority layer Click the Assign implementation models button to select IMs to be associated with the priority layer (see Figure 28 ) Figure 28: Priority layer dialog Select the IMs you want to be associated with the priority layer Click OK Figure 29: Implementation model selection for priority layers : Remove the selected PWL","title":"Create custom priority layers"},{"location":"user/guide/#setting-groups-values","text":"Move the slider to adjust the weight of each group, values can also be set manually, by using the left input spin box. Once done selecting weights, click Run Scenario button to run the analysis.","title":"Setting groups values"},{"location":"user/guide/#steps-1-to-3-example","text":"The following recording ( Figure 25 ) shows an example on how to do Step 1, 2 and 3. This is based on the pilot study area. Figure 30: Shows how to implement Step 1, 2 and 3 in QGIS","title":"Steps 1 to 3 example"},{"location":"user/guide/#processing","text":"Once the user has provided all desired parameters, click Run Scenario The processing dialog will open ( Figure 31 ) The processing will take a while, depending on the number of IMs and pathways provided for each IM Click the Cancel button to stop the processing Figure 31: Processing dialog while the algorithm is running Figure 32 will be the result if the processing succceeded The user should take note that the View Report button is now available Figure 32: Processing dialog if successfull","title":"Processing"},{"location":"user/guide/#processing-results","text":"The following groups and layers will be added to the QGIS canvas once the processing finishes (see Figure 33 ): - A group containing the Scenario results - Implementation Model Maps : Non-weighted IMs created by the user in Step 2 - Weighted Implementation Model Maps : Weighted IMs based on the IMs added in Step 2 and weighing set in Step 3 - NCS Pathways Maps : Pathways used for each IM in Step 2. If a IM layer were provided as the IM in Step 2, this will contain no pathways Figure 33: Groups and layers added to the QGIS canvas An example of output results in QGIS is detailed by Figure 33 Figure 34: A recording example of an example scenario","title":"Processing results"},{"location":"user/guide/#report-generating","text":"Click the View Report button The user will have the following options: Layout designer : Opens the report in the QGIS layout designer Open PDF : Opens the report in PDF format Help : Open the help documentation related to the reports Figure 35: Report options Figure 35 shows an example of a report opened in the layout designer Figure 36: Report opened in the QGIS layout designer Figure 36 shows a report in PDF format Figure 37: PDF version of a report","title":"Report generating"},{"location":"user/guide/#generated-report-example","text":"Here is an example on how to open a report in the QGIS layout designer, or as a PDF ( Figure 33 ). Figure 38: Example of a generated report in PDF and layout designer formats","title":"Generated report example"},{"location":"user/manual/","text":"Manual The manual covers two sections. Firstly the workflow will be covered. This includes a discussion on the calculations and formulas. This is so that a user can understand how the CPLUS processing workflow and calculations for each step is done when processing the pathways and carbon layers, how the implementations models (IM) are created, algorithms applied to create the priority weighted layer (weighted IM), and the last step, which is the highest position calculation. The second section deals with the plugin itself. It covers each step, explains each element of each step and why its needed. A description of the generated report are also provided. CPLUS calculations and formulas Figure 1 shows the workflow of the CPLUS model. The workflow can be split into four parts: Natural climate solution (NCS) weighted carbon pathway(s) Implementation model (IM) Priority weighted layer (Weighted IM) Highest position (Scenario result) Figure 1: CPLUS workflow NCS weighted carbon The following steps/rules are considered to create the NCS weighted carbon layer(s): Carbon layers: When multiple Carbon layers are provided, the average is calculated from the layers to create a single Carbon layer The produced Carbon layer is multiplied by the Carbon coefficient provided by the user in the settings If the Carbon coefficient is zero, the value is ignored NCS pathways: Multiply the pathway raster with the Suitability index If the index is zero, the pathway raster is used as-is Equation 1 shows how the NCS weighted carbon layer is calculated \\[ \\operatorname{NCS weighted carbon} ={CarbonCoefficient}\\times{\\frac{(Carbon_1 + Carbon_2 + .... + Carbon_n)}{n}} + ({SuitabilityIndex}\\times{NcsPathway}) \\] Equation 1: NCS weighted carbon where CarbonCoefficient is the carbon coefficient value multiplied with the averaged carbon raster; \u2003\u2003 Carbon is a carbon raster; \u2003\u2003 SuitabilityIndex is the NCS pathway index value; \u2003\u2003 NcsPathway is the NCS pathway raster; and \u2003\u2003 n is the number of carbon rasters. The results from the above calculation are normalized to create the normalized NCS Weighted Carbon layer A normalized raster's pixel values range from 0 to 1 Normalization is done as shown in Equation 2 \\[ \\operatorname{Normalized NCS weighted carbon} =\\frac{value - min}{max - min} \\] Equation 2: Normalized NCS weighted carbon where value is the pixel value; \u2003\u2003 min is the minimum value of the raster; and \u2003\u2003 max is the maximum value of the raster. Implementation model Because an IM can consist of multiple pathways, the normalized results will be summed All NCS weighted carbon layers, as created from Equation 2 , is summed as shown in Equation 3 to create the IM from the pathways \\[ \\operatorname{Summed pathways} = NcsWeightedCarbon_1 + NcsWeightedCarbon_2 + ... + NcsWeightedCarbon_n \\] Equation 3: Summed pathways for the IM where NcsWeightedCarbon is a pathway set up by the user; and \u2003\u2003 n is the number of pathways. Now that the pathways has been summed for the IM, the result needs to be normalized The Suitability index and the Carbon coefficient then needs to be taken into account after the normalized raster has been created This calculation is shown in Equation 4 \\[ \\operatorname{Final IM} ={(SuitabilityIndex + CarbonCoefficient)}\\times{\\frac{value - min}{max - min}} \\] Equation 4: Final IM created from pathways where value is the pixel value; \u2003\u2003 min is the minimum value of the raster; \u2003\u2003 max is the maximum value of the raster; \u2003\u2003 SuitabilityIndex is the NCS pathway index value; and \u2003\u2003 CarbonCoefficient is the carbon coefficient value multiplied with the averaged carbon raster. The resulting output is the final IM Priority weighted layer (Weighted IM) This step is performed after the IMs has been created The PWL is more important, and will therefore be multiplied by five to take this into account The PWL weighted is calculated as shown in Equation 5 \\[ \\operatorname{Priority weighted layer} ={FinalImplementationModel} + ({5}\\times{Priority weighted layer}) \\] Equation 5: Priority weighted layer (Weighted IM) calculation The resulting PWL will then be used as input to the Highest position calculation Highest Position The Highest position tool determines the raster in a stack with the highest value at a given pixel. Essentially the result is a classification, where each class represents a specific IM. If multiple rasters has the highest pixel value at a given pixel, the first raster with that pixel value in the stack will be used. Figure 2 shows an example from the QGIS description of the Highest position tool. Figure 2: Highest position example In the plugin the nodata values are ignored. This means that if atleast one raster has a pixel value at that cell there will be a raster stack value. If none of the rasters in the stack has a pixel value at that cell (e.g. each raster pixel is nodata) the output will be nodata at that pixel. Here is an explanation on how-to use the Highest position tool: Figure 3 shows the layer for the Highest position at stack position 1 Figure 3: Layer 1 used as highest position input Figure 4 shows the layer for the Highest position at stack position 2 Figure 4: Layer 2 used as highest position input Figure 5 shows the result from the Highest position calculation (Scenario result) Stack layer 1 (blue): Figure 2 raster had the highest pixel value Stack layer 2 (red): Figure 3 raster had the highest pixel value Figure 5: Highest position result This concludes the section on how the calculations is done References https://www.pnas.org/doi/10.1073/pnas.1710465114 https://royalsocietypublishing.org/doi/10.1098/rstb.2019.0126 Plugin Detailed descriptions for each UI element of the plugin. This covers steps 1 to 3, dialogs, and the settings UI. Dock widget This is the main UI of the plugin. The dock widget opens on the right side of QGIS. The dock widget consist of three tabs, each focussing on a particular phase of the analyis. Here is a short description of those steps: Step 1 : Scenario information Step 2 : NCS pathways and IMs Step 3 : Weighting priorities (weighted IMs) Step 1: Scenario information Figure 6: Step 1 of the dock widget Step 1 allows a user to set up the scenario details and parameters. Scenario name : This title will be used throughout the processing, will be used for the groups added to the QGIS canvas, and in the generated report Scenario description : A detailed description of the scenario the user will be running. This information will be added to the final report Extent : The area of interest (AOI) for analysis. Any spatial data outside this region will be ignored Map Canvas Extent : The AOI will be the current extent the user has in QGIS Draw on Canvas : Allows the user to manually draw the AOI Zoom to Pilot Area : Zooms to the Bushbuckridge pilot study area Figure 7: Bushbuckridge study area Step 2: NCS pathways and Implementation models Step 2 focuses on the implementation models (IMs) and pathways. Figure 8: Step 2 of the dock widget NCS pathways : Pathways which can be added to IMs. Multiple pathways can be added to each IM Implementation models : Each selected model will be created in used to perform the analysis Description : A description of the IM or pathway selected : Add the selected pathway to the selected IM : Adds all pathways to the selected IM : Add a new IM : Remove the selected IM or pathway : Edit the selected IM : Order the pixel values (IMs) will be in the scenario output Implementation Model Editor dialog Figure 9: Implementation model editing/adding dialog Name : The name of the new IM or IM being edited. IM title will be used in the report Description : A detailed description of the IM. This will be used in the report Style : Styles used for the IM Scenario layer : Colouring which will be used in the Scenario output for this IM Output model layer : Colour ramp which will be applied to the IM raster output Map layer : If enabled, a user can provide an existing IM. This has to be a raster Ordering of the pixel values for the scenario output A user can order the stack using the Style pixel value editor . Step 3: Weighting priorities Figure 10: Step 3 of the dock widget Priority groups : Groups to which PWLs can be assigned Priority weighted layers (PWL) : Importance of each priority group : Remove the selected PWL from the priority group : Add the selected PWL to the selected priority group : Add a new PWL : Remove the selected PWL : Edit the selected PWL Run Scenario : Starts running the analysis. The progress dialog will open when the user clicks this button Priority Weighted Layers Editor dialog Figure 11: Priority layer dialog Priority layer : Select the priority layer Priority layer name : A unique name for the priority layer Priority layer description : A detailed description for the priority layer Assign implementation models : Selected IMs associated with the priority layer Figure 12: Selection of IMs for a custom priority layer List of IMs a user can select. Multiple IMs can be selected OK : Save the selected models Select All : Selects each of the available IMs Clear Selection : Deselects each of the selected IMs Toggle Selection : Switches each option from deselected to selected, or selected to deselected Progress dialog Figure 13: Processing dialog which will show the status of the analysis Analysis Progress : Progress of the current step Status : A status message on the current analysis being performed View Report : This button will remain disabled until the processing is done Cancel : Clicking this button will stop the processing Close : Only visible once the processing stops. Will close the progress dialog Report options These options will be available once the analysis has finished. The options will stay disabled if the analysis failed Figure 14: Options available to the user related to the generated report Layout designer : Opens the report in the QGIS layout designer Open PDF : Opens the created PDF Help : Takes the user to the Users documentation site Settings Figure 15: Settings available to the user Reports : Information to be added to the report Organization : (optional) Organization or institute name Contact email : (optional) Contact email of the user Website : (optional) Link to website of your company or institute Custom logo : (optional) If enabled, the user needs to provide a custom logo. Most formats should suffice (png, jpeg, etc.) Logo preview : Visual previre of the default CI logo, or the custom logo a user selected Footer : (optional) Will be added to the report Disclaimer : Change as desired, otherwise use the default disclaimer License : Change as desired, otherwise use the default license description Advanced : Base data directory : Directory to read data from, and to which results will be written Coefficient for carbon layers : Applied to carbon layers during processing Pathway suitability index : Index multiplied to the pathways. Lower values means the pathway is less important, higher means its more important Snapping : Will set rasters to match the cell alignment of a reference layer Resample method : Resampling performed on pixel values. Nearest neighbour : Closest pixel value. This will be best to use if a user wants to preserve the original pixel values Bilinear : Computes the pixel values from the two closest pixels (2 x 2 kernel) Cubic : Computes the pixel values from the four closest pixels (4 x 4 kernel) Cubic B-Spline : Cubic resampling based on B-Spline (4 x 4 kernel) Lanczos : Lanczos windowed sinc interpolation (6 x 6 kernel) Average : Computes the average of all non-nodata contributing pixels Mode : Selects the value which appears most often of all the sampled pixels Maximum : Selects the maximum value which appears of all the sampled pixels Minimum : Selects the minimum value which appears of all the sampled pixels Mediane : Selects the mediane value which appears of all the sampled pixels First quartile (Q1) : Selects the first quartile value which appears of all the sampled pixels Third quartile (Q3) : Selects the third quartile value which appears of all the sampled pixels Reference layer : The reference layer to which the cell alignment will be applied Rescale values : Rescale values according to cell size","title":"Manual"},{"location":"user/manual/#manual","text":"The manual covers two sections. Firstly the workflow will be covered. This includes a discussion on the calculations and formulas. This is so that a user can understand how the CPLUS processing workflow and calculations for each step is done when processing the pathways and carbon layers, how the implementations models (IM) are created, algorithms applied to create the priority weighted layer (weighted IM), and the last step, which is the highest position calculation. The second section deals with the plugin itself. It covers each step, explains each element of each step and why its needed. A description of the generated report are also provided.","title":"Manual"},{"location":"user/manual/#cplus-calculations-and-formulas","text":"Figure 1 shows the workflow of the CPLUS model. The workflow can be split into four parts: Natural climate solution (NCS) weighted carbon pathway(s) Implementation model (IM) Priority weighted layer (Weighted IM) Highest position (Scenario result) Figure 1: CPLUS workflow","title":"CPLUS calculations and formulas"},{"location":"user/manual/#ncs-weighted-carbon","text":"The following steps/rules are considered to create the NCS weighted carbon layer(s): Carbon layers: When multiple Carbon layers are provided, the average is calculated from the layers to create a single Carbon layer The produced Carbon layer is multiplied by the Carbon coefficient provided by the user in the settings If the Carbon coefficient is zero, the value is ignored NCS pathways: Multiply the pathway raster with the Suitability index If the index is zero, the pathway raster is used as-is Equation 1 shows how the NCS weighted carbon layer is calculated \\[ \\operatorname{NCS weighted carbon} ={CarbonCoefficient}\\times{\\frac{(Carbon_1 + Carbon_2 + .... + Carbon_n)}{n}} + ({SuitabilityIndex}\\times{NcsPathway}) \\] Equation 1: NCS weighted carbon where CarbonCoefficient is the carbon coefficient value multiplied with the averaged carbon raster; \u2003\u2003 Carbon is a carbon raster; \u2003\u2003 SuitabilityIndex is the NCS pathway index value; \u2003\u2003 NcsPathway is the NCS pathway raster; and \u2003\u2003 n is the number of carbon rasters. The results from the above calculation are normalized to create the normalized NCS Weighted Carbon layer A normalized raster's pixel values range from 0 to 1 Normalization is done as shown in Equation 2 \\[ \\operatorname{Normalized NCS weighted carbon} =\\frac{value - min}{max - min} \\] Equation 2: Normalized NCS weighted carbon where value is the pixel value; \u2003\u2003 min is the minimum value of the raster; and \u2003\u2003 max is the maximum value of the raster.","title":"NCS weighted carbon"},{"location":"user/manual/#implementation-model","text":"Because an IM can consist of multiple pathways, the normalized results will be summed All NCS weighted carbon layers, as created from Equation 2 , is summed as shown in Equation 3 to create the IM from the pathways \\[ \\operatorname{Summed pathways} = NcsWeightedCarbon_1 + NcsWeightedCarbon_2 + ... + NcsWeightedCarbon_n \\] Equation 3: Summed pathways for the IM where NcsWeightedCarbon is a pathway set up by the user; and \u2003\u2003 n is the number of pathways. Now that the pathways has been summed for the IM, the result needs to be normalized The Suitability index and the Carbon coefficient then needs to be taken into account after the normalized raster has been created This calculation is shown in Equation 4 \\[ \\operatorname{Final IM} ={(SuitabilityIndex + CarbonCoefficient)}\\times{\\frac{value - min}{max - min}} \\] Equation 4: Final IM created from pathways where value is the pixel value; \u2003\u2003 min is the minimum value of the raster; \u2003\u2003 max is the maximum value of the raster; \u2003\u2003 SuitabilityIndex is the NCS pathway index value; and \u2003\u2003 CarbonCoefficient is the carbon coefficient value multiplied with the averaged carbon raster. The resulting output is the final IM","title":"Implementation model"},{"location":"user/manual/#priority-weighted-layer-weighted-im","text":"This step is performed after the IMs has been created The PWL is more important, and will therefore be multiplied by five to take this into account The PWL weighted is calculated as shown in Equation 5 \\[ \\operatorname{Priority weighted layer} ={FinalImplementationModel} + ({5}\\times{Priority weighted layer}) \\] Equation 5: Priority weighted layer (Weighted IM) calculation The resulting PWL will then be used as input to the Highest position calculation","title":"Priority weighted layer (Weighted IM)"},{"location":"user/manual/#highest-position","text":"The Highest position tool determines the raster in a stack with the highest value at a given pixel. Essentially the result is a classification, where each class represents a specific IM. If multiple rasters has the highest pixel value at a given pixel, the first raster with that pixel value in the stack will be used. Figure 2 shows an example from the QGIS description of the Highest position tool. Figure 2: Highest position example In the plugin the nodata values are ignored. This means that if atleast one raster has a pixel value at that cell there will be a raster stack value. If none of the rasters in the stack has a pixel value at that cell (e.g. each raster pixel is nodata) the output will be nodata at that pixel. Here is an explanation on how-to use the Highest position tool: Figure 3 shows the layer for the Highest position at stack position 1 Figure 3: Layer 1 used as highest position input Figure 4 shows the layer for the Highest position at stack position 2 Figure 4: Layer 2 used as highest position input Figure 5 shows the result from the Highest position calculation (Scenario result) Stack layer 1 (blue): Figure 2 raster had the highest pixel value Stack layer 2 (red): Figure 3 raster had the highest pixel value Figure 5: Highest position result This concludes the section on how the calculations is done","title":"Highest Position"},{"location":"user/manual/#references","text":"https://www.pnas.org/doi/10.1073/pnas.1710465114 https://royalsocietypublishing.org/doi/10.1098/rstb.2019.0126","title":"References"},{"location":"user/manual/#plugin","text":"Detailed descriptions for each UI element of the plugin. This covers steps 1 to 3, dialogs, and the settings UI.","title":"Plugin"},{"location":"user/manual/#dock-widget","text":"This is the main UI of the plugin. The dock widget opens on the right side of QGIS. The dock widget consist of three tabs, each focussing on a particular phase of the analyis. Here is a short description of those steps: Step 1 : Scenario information Step 2 : NCS pathways and IMs Step 3 : Weighting priorities (weighted IMs)","title":"Dock widget"},{"location":"user/manual/#step-1-scenario-information","text":"Figure 6: Step 1 of the dock widget Step 1 allows a user to set up the scenario details and parameters. Scenario name : This title will be used throughout the processing, will be used for the groups added to the QGIS canvas, and in the generated report Scenario description : A detailed description of the scenario the user will be running. This information will be added to the final report Extent : The area of interest (AOI) for analysis. Any spatial data outside this region will be ignored Map Canvas Extent : The AOI will be the current extent the user has in QGIS Draw on Canvas : Allows the user to manually draw the AOI Zoom to Pilot Area : Zooms to the Bushbuckridge pilot study area Figure 7: Bushbuckridge study area","title":"Step 1: Scenario information"},{"location":"user/manual/#step-2-ncs-pathways-and-implementation-models","text":"Step 2 focuses on the implementation models (IMs) and pathways. Figure 8: Step 2 of the dock widget NCS pathways : Pathways which can be added to IMs. Multiple pathways can be added to each IM Implementation models : Each selected model will be created in used to perform the analysis Description : A description of the IM or pathway selected : Add the selected pathway to the selected IM : Adds all pathways to the selected IM : Add a new IM : Remove the selected IM or pathway : Edit the selected IM : Order the pixel values (IMs) will be in the scenario output","title":"Step 2: NCS pathways and Implementation models"},{"location":"user/manual/#implementation-model-editor-dialog","text":"Figure 9: Implementation model editing/adding dialog Name : The name of the new IM or IM being edited. IM title will be used in the report Description : A detailed description of the IM. This will be used in the report Style : Styles used for the IM Scenario layer : Colouring which will be used in the Scenario output for this IM Output model layer : Colour ramp which will be applied to the IM raster output Map layer : If enabled, a user can provide an existing IM. This has to be a raster","title":"Implementation Model Editor dialog"},{"location":"user/manual/#ordering-of-the-pixel-values-for-the-scenario-output","text":"A user can order the stack using the Style pixel value editor .","title":"Ordering of the pixel values for the scenario output"},{"location":"user/manual/#step-3-weighting-priorities","text":"Figure 10: Step 3 of the dock widget Priority groups : Groups to which PWLs can be assigned Priority weighted layers (PWL) : Importance of each priority group : Remove the selected PWL from the priority group : Add the selected PWL to the selected priority group : Add a new PWL : Remove the selected PWL : Edit the selected PWL Run Scenario : Starts running the analysis. The progress dialog will open when the user clicks this button","title":"Step 3: Weighting priorities"},{"location":"user/manual/#priority-weighted-layers-editor-dialog","text":"Figure 11: Priority layer dialog Priority layer : Select the priority layer Priority layer name : A unique name for the priority layer Priority layer description : A detailed description for the priority layer Assign implementation models : Selected IMs associated with the priority layer Figure 12: Selection of IMs for a custom priority layer List of IMs a user can select. Multiple IMs can be selected OK : Save the selected models Select All : Selects each of the available IMs Clear Selection : Deselects each of the selected IMs Toggle Selection : Switches each option from deselected to selected, or selected to deselected","title":"Priority Weighted Layers Editor dialog"},{"location":"user/manual/#progress-dialog","text":"Figure 13: Processing dialog which will show the status of the analysis Analysis Progress : Progress of the current step Status : A status message on the current analysis being performed View Report : This button will remain disabled until the processing is done Cancel : Clicking this button will stop the processing Close : Only visible once the processing stops. Will close the progress dialog","title":"Progress dialog"},{"location":"user/manual/#report-options","text":"These options will be available once the analysis has finished. The options will stay disabled if the analysis failed Figure 14: Options available to the user related to the generated report Layout designer : Opens the report in the QGIS layout designer Open PDF : Opens the created PDF Help : Takes the user to the Users documentation site","title":"Report options"},{"location":"user/manual/#settings","text":"Figure 15: Settings available to the user Reports : Information to be added to the report Organization : (optional) Organization or institute name Contact email : (optional) Contact email of the user Website : (optional) Link to website of your company or institute Custom logo : (optional) If enabled, the user needs to provide a custom logo. Most formats should suffice (png, jpeg, etc.) Logo preview : Visual previre of the default CI logo, or the custom logo a user selected Footer : (optional) Will be added to the report Disclaimer : Change as desired, otherwise use the default disclaimer License : Change as desired, otherwise use the default license description Advanced : Base data directory : Directory to read data from, and to which results will be written Coefficient for carbon layers : Applied to carbon layers during processing Pathway suitability index : Index multiplied to the pathways. Lower values means the pathway is less important, higher means its more important Snapping : Will set rasters to match the cell alignment of a reference layer Resample method : Resampling performed on pixel values. Nearest neighbour : Closest pixel value. This will be best to use if a user wants to preserve the original pixel values Bilinear : Computes the pixel values from the two closest pixels (2 x 2 kernel) Cubic : Computes the pixel values from the four closest pixels (4 x 4 kernel) Cubic B-Spline : Cubic resampling based on B-Spline (4 x 4 kernel) Lanczos : Lanczos windowed sinc interpolation (6 x 6 kernel) Average : Computes the average of all non-nodata contributing pixels Mode : Selects the value which appears most often of all the sampled pixels Maximum : Selects the maximum value which appears of all the sampled pixels Minimum : Selects the minimum value which appears of all the sampled pixels Mediane : Selects the mediane value which appears of all the sampled pixels First quartile (Q1) : Selects the first quartile value which appears of all the sampled pixels Third quartile (Q3) : Selects the third quartile value which appears of all the sampled pixels Reference layer : The reference layer to which the cell alignment will be applied Rescale values : Rescale values according to cell size","title":"Settings"},{"location":"user/quickstart/","text":"Quick start Instructions for a user on how to get the plugin working. First section deals with QGIS, and what versions are best to work with. This is followed by a section on how to install the CPLUS plugin, ending with a short tutorial accompanied by a video to show the user how to use the plugin. QGIS version The CPLUS plugin might have issues with older versions of QGIS. QGIS 3.32 or higher has thoroughly been tested with no major known issues. Here is a list of possible issues which may occur if using an outdated version of QGIS are being used: Processing stalls and does not continue Symbologies (e.g. colour ramps) cannot be applied to the output layers Reports cannot be generated Best will be to update QGIS to the latest version, even for other plugins, as bugs and improvements will be available for those versions. To update QGIS, a user can do the following: Go to the QGIS download webpage Download or follow the instructions for the OS on which QGIS needs to be installed If a specific version (not the latest version) of QGIS needs to be installed, click on the All releases tab OSGeo4W network installer This section will only be helpful for Windows users. The OSGeo4W network installer provides much more option in a user-friendly UI. Advantages of using this installer: Easily allows a user to install both the latest and the latest LTR versions of QGIS User can select the exact libraries and versions they want to install (e.g. gdal) Option to include (or not include) GRASS and SAGA Extensions for QGIS If a user wants to update an existing QGIS installation, simply run the osgeo.exe in the installation directory Simply run the osgeo.exe to update already installed libraries, or install new libraries Easy to remove libraries or extensions Python modules And much more Installation Plugin repository During the development phase the plugin is available to install via a dedicated plugin repository. This link should be used: https://raw.githubusercontent.com/kartoza/cplus-plugin/release/docs/repository/plugins.xml Open QGIS application and open plugin manager. Click on Plugins -> Manage and Install Plugins (see Figure 1 ) Open the Settings tab Click the Add button Provide the following parameters: Name : Provide a name for the repository URL : Paste the above repository URL Click OK The result should be similar to the following: Install from QGIS plugin repository Open QGIS application and open plugin manager. Click on Plugins -> Manage and Install Plugins (see Figure 1 ) Figure 1: QGIS plugin manager Search for CPLUS in the All page of the plugin manager. From the found results, click on the CPLUS result item and a page with plugin information will show up. Click the Install Plugin button at the bottom of the dialog to install the plugin. Install from ZIP file Alternatively the plugin can be installed using Install from ZIP option on the QGIS plugin manager. Download zip file from the required plugin released version https://github.com/kartoza/cplus-plugin/releases/download/{tagname}/cplus.{version}.zip Open QGIS application and open plugin manager Click on Plugins -> Manage and Install Plugins Click on Install from ZIP ( Figure 2 ) Select the zip file which contains the plugin Click Install Plugin Figure 2: Plugin manager install from zip option From the Install from ZIP page, select the zip file and click the Install button to install plugin Install from custom plugin repository Current repository: https://raw.githubusercontent.com/kartoza/cplus-plugin/release/docs/repository/plugins.xml Open the QGIS plugin manager, then select the Settings page ( Figure 3 ) NOTE: The plugin is currently in experimental phase, so enable Show also Experimental Plugins Figure 3: Custom repository installation Click Add button on the Plugin Repositories group box and use the above url to create the new plugin repository. The plugin should now be available from the list of all plugins that can be installed. Disable QGIS official plugin repository in order to not fetch plugins from it. NOTE: While the development phase is on going the plugin will be flagged as experimental, make sure to enable the QGIS plugin manager in the Settings page to show the experimental plugins in order to be able to install it. When the development work is complete the plugin will be available on the QGIS official plugin repository. Short tutorial Short example ( Figure 4 ) on how to set parameters in step 1, implementation models in step 2, and weighing in step 3. For a more detailed instructions on how to use the plugin, see the guide and the manual . Figure 4: Quick guide on how to use the plugin","title":"Quick Start"},{"location":"user/quickstart/#quick-start","text":"Instructions for a user on how to get the plugin working. First section deals with QGIS, and what versions are best to work with. This is followed by a section on how to install the CPLUS plugin, ending with a short tutorial accompanied by a video to show the user how to use the plugin.","title":"Quick start"},{"location":"user/quickstart/#qgis-version","text":"The CPLUS plugin might have issues with older versions of QGIS. QGIS 3.32 or higher has thoroughly been tested with no major known issues. Here is a list of possible issues which may occur if using an outdated version of QGIS are being used: Processing stalls and does not continue Symbologies (e.g. colour ramps) cannot be applied to the output layers Reports cannot be generated Best will be to update QGIS to the latest version, even for other plugins, as bugs and improvements will be available for those versions. To update QGIS, a user can do the following: Go to the QGIS download webpage Download or follow the instructions for the OS on which QGIS needs to be installed If a specific version (not the latest version) of QGIS needs to be installed, click on the All releases tab","title":"QGIS version"},{"location":"user/quickstart/#osgeo4w-network-installer","text":"This section will only be helpful for Windows users. The OSGeo4W network installer provides much more option in a user-friendly UI. Advantages of using this installer: Easily allows a user to install both the latest and the latest LTR versions of QGIS User can select the exact libraries and versions they want to install (e.g. gdal) Option to include (or not include) GRASS and SAGA Extensions for QGIS If a user wants to update an existing QGIS installation, simply run the osgeo.exe in the installation directory Simply run the osgeo.exe to update already installed libraries, or install new libraries Easy to remove libraries or extensions Python modules And much more","title":"OSGeo4W network installer"},{"location":"user/quickstart/#installation","text":"","title":"Installation"},{"location":"user/quickstart/#plugin-repository","text":"During the development phase the plugin is available to install via a dedicated plugin repository. This link should be used: https://raw.githubusercontent.com/kartoza/cplus-plugin/release/docs/repository/plugins.xml Open QGIS application and open plugin manager. Click on Plugins -> Manage and Install Plugins (see Figure 1 ) Open the Settings tab Click the Add button Provide the following parameters: Name : Provide a name for the repository URL : Paste the above repository URL Click OK The result should be similar to the following:","title":"Plugin repository"},{"location":"user/quickstart/#install-from-qgis-plugin-repository","text":"Open QGIS application and open plugin manager. Click on Plugins -> Manage and Install Plugins (see Figure 1 ) Figure 1: QGIS plugin manager Search for CPLUS in the All page of the plugin manager. From the found results, click on the CPLUS result item and a page with plugin information will show up. Click the Install Plugin button at the bottom of the dialog to install the plugin.","title":"Install from QGIS plugin repository"},{"location":"user/quickstart/#install-from-zip-file","text":"Alternatively the plugin can be installed using Install from ZIP option on the QGIS plugin manager. Download zip file from the required plugin released version https://github.com/kartoza/cplus-plugin/releases/download/{tagname}/cplus.{version}.zip Open QGIS application and open plugin manager Click on Plugins -> Manage and Install Plugins Click on Install from ZIP ( Figure 2 ) Select the zip file which contains the plugin Click Install Plugin Figure 2: Plugin manager install from zip option From the Install from ZIP page, select the zip file and click the Install button to install plugin","title":"Install from ZIP file"},{"location":"user/quickstart/#install-from-custom-plugin-repository","text":"Current repository: https://raw.githubusercontent.com/kartoza/cplus-plugin/release/docs/repository/plugins.xml Open the QGIS plugin manager, then select the Settings page ( Figure 3 ) NOTE: The plugin is currently in experimental phase, so enable Show also Experimental Plugins Figure 3: Custom repository installation Click Add button on the Plugin Repositories group box and use the above url to create the new plugin repository. The plugin should now be available from the list of all plugins that can be installed. Disable QGIS official plugin repository in order to not fetch plugins from it. NOTE: While the development phase is on going the plugin will be flagged as experimental, make sure to enable the QGIS plugin manager in the Settings page to show the experimental plugins in order to be able to install it. When the development work is complete the plugin will be available on the QGIS official plugin repository.","title":"Install from custom plugin repository"},{"location":"user/quickstart/#short-tutorial","text":"Short example ( Figure 4 ) on how to set parameters in step 1, implementation models in step 2, and weighing in step 3. For a more detailed instructions on how to use the plugin, see the guide and the manual . Figure 4: Quick guide on how to use the plugin","title":"Short tutorial"}]}